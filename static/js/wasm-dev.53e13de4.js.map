{"version":3,"file":"static/js/wasm-dev.53e13de4.js","mappings":"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","sources":["webpack://wasm-boids/./src/wasm/build/dev/wasm_boids.js"],"sourcesContent":["var createBoidsModule = (() => {\r\n  \r\n  return (\r\nasync function(moduleArg = {}) {\r\n  var moduleRtn;\r\n\r\n// include: shell.js\r\n// The Module object: Our interface to the outside world. We import\r\n// and export values on it. There are various ways Module can be used:\r\n// 1. Not defined. We create it here\r\n// 2. A function parameter, function(moduleArg) => Promise<Module>\r\n// 3. pre-run appended it, var Module = {}; ..generated code..\r\n// 4. External script tag defines var Module.\r\n// We need to check if Module already exists (e.g. case 3 above).\r\n// Substitution will be replaced with actual code on later stage of the build,\r\n// this way Closure Compiler will not mangle it (e.g. case 4. above).\r\n// Note that if you want to run closure, and also to use Module\r\n// after the generated code, you will need to define   var Module = {};\r\n// before the code. Then that object will be used in the code, and you\r\n// can continue to use Module afterwards as well.\r\nvar Module = moduleArg;\r\n\r\n// Set up the promise that indicates the Module is initialized\r\nvar readyPromiseResolve, readyPromiseReject;\r\n\r\nvar readyPromise = new Promise((resolve, reject) => {\r\n  readyPromiseResolve = resolve;\r\n  readyPromiseReject = reject;\r\n});\r\n\r\n// Determine the runtime environment we are in. You can customize this by\r\n// setting the ENVIRONMENT setting at compile time (see settings.js).\r\n// Attempt to auto-detect the environment\r\nvar ENVIRONMENT_IS_WEB = typeof window == \"object\";\r\n\r\nvar ENVIRONMENT_IS_WORKER = typeof WorkerGlobalScope != \"undefined\";\r\n\r\n// N.b. Electron.js environment is simultaneously a NODE-environment, but\r\n// also a web environment.\r\nvar ENVIRONMENT_IS_NODE = typeof process == \"object\" && typeof process.versions == \"object\" && typeof process.versions.node == \"string\" && process.type != \"renderer\";\r\n\r\nvar ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\r\n\r\n// Three configurations we can be running in:\r\n// 1) We could be the application main() thread running in the main JS UI thread. (ENVIRONMENT_IS_WORKER == false and ENVIRONMENT_IS_PTHREAD == false)\r\n// 2) We could be the application main() thread proxied to worker. (with Emscripten -sPROXY_TO_WORKER) (ENVIRONMENT_IS_WORKER == true, ENVIRONMENT_IS_PTHREAD == false)\r\n// 3) We could be an application pthread running in a worker. (ENVIRONMENT_IS_WORKER == true and ENVIRONMENT_IS_PTHREAD == true)\r\n// The way we signal to a worker that it is hosting a pthread is to construct\r\n// it with a specific name.\r\nvar ENVIRONMENT_IS_PTHREAD = ENVIRONMENT_IS_WORKER && self.name?.startsWith(\"em-pthread\");\r\n\r\nif (ENVIRONMENT_IS_PTHREAD) {\r\n  assert(!globalThis.moduleLoaded, \"module should only be loaded once on each pthread worker\");\r\n  globalThis.moduleLoaded = true;\r\n}\r\n\r\nif (ENVIRONMENT_IS_NODE) {\r\n  // When building an ES module `require` is not normally available.\r\n  // We need to use `createRequire()` to construct the require()` function.\r\n  const {createRequire} = await import(\"module\");\r\n  /** @suppress{duplicate} */ var require = createRequire(import.meta.url);\r\n  var worker_threads = require(\"worker_threads\");\r\n  global.Worker = worker_threads.Worker;\r\n  ENVIRONMENT_IS_WORKER = !worker_threads.isMainThread;\r\n  // Under node we set `workerData` to `em-pthread` to signal that the worker\r\n  // is hosting a pthread.\r\n  ENVIRONMENT_IS_PTHREAD = ENVIRONMENT_IS_WORKER && worker_threads[\"workerData\"] == \"em-pthread\";\r\n}\r\n\r\n// --pre-jses are emitted after the Module integration code, so that they can\r\n// refer to Module (if they choose; they can also define Module)\r\nvar arguments_ = [];\r\n\r\nvar thisProgram = \"./this.program\";\r\n\r\nvar quit_ = (status, toThrow) => {\r\n  throw toThrow;\r\n};\r\n\r\nvar _scriptName = import.meta.url;\r\n\r\n// `/` should be present at the end if `scriptDirectory` is not empty\r\nvar scriptDirectory = \"\";\r\n\r\nfunction locateFile(path) {\r\n  if (Module[\"locateFile\"]) {\r\n    return Module[\"locateFile\"](path, scriptDirectory);\r\n  }\r\n  return scriptDirectory + path;\r\n}\r\n\r\n// Hooks that are implemented differently in different runtime environments.\r\nvar readAsync, readBinary;\r\n\r\nif (ENVIRONMENT_IS_NODE) {\r\n  if (typeof process == \"undefined\" || !process.release || process.release.name !== \"node\") throw new Error(\"not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)\");\r\n  var nodeVersion = process.versions.node;\r\n  var numericVersion = nodeVersion.split(\".\").slice(0, 3);\r\n  numericVersion = (numericVersion[0] * 1e4) + (numericVersion[1] * 100) + (numericVersion[2].split(\"-\")[0] * 1);\r\n  var minVersion = 160400;\r\n  if (numericVersion < 160400) {\r\n    throw new Error(\"This emscripten-generated code requires node v16.04.4.0 (detected v\" + nodeVersion + \")\");\r\n  }\r\n  // These modules will usually be used on Node.js. Load them eagerly to avoid\r\n  // the complexity of lazy-loading.\r\n  var fs = require(\"fs\");\r\n  var nodePath = require(\"path\");\r\n  if (_scriptName.startsWith(\"file:\")) {\r\n    scriptDirectory = nodePath.dirname(require(\"url\").fileURLToPath(_scriptName)) + \"/\";\r\n  }\r\n  // include: node_shell_read.js\r\n  readBinary = filename => {\r\n    // We need to re-wrap `file://` strings to URLs.\r\n    filename = isFileURI(filename) ? new URL(filename) : filename;\r\n    var ret = fs.readFileSync(filename);\r\n    assert(Buffer.isBuffer(ret));\r\n    return ret;\r\n  };\r\n  readAsync = async (filename, binary = true) => {\r\n    // See the comment in the `readBinary` function.\r\n    filename = isFileURI(filename) ? new URL(filename) : filename;\r\n    var ret = fs.readFileSync(filename, binary ? undefined : \"utf8\");\r\n    assert(binary ? Buffer.isBuffer(ret) : typeof ret == \"string\");\r\n    return ret;\r\n  };\r\n  // end include: node_shell_read.js\r\n  if (process.argv.length > 1) {\r\n    thisProgram = process.argv[1].replace(/\\\\/g, \"/\");\r\n  }\r\n  arguments_ = process.argv.slice(2);\r\n  quit_ = (status, toThrow) => {\r\n    process.exitCode = status;\r\n    throw toThrow;\r\n  };\r\n} else if (ENVIRONMENT_IS_SHELL) {\r\n  if ((typeof process == \"object\" && typeof require === \"function\") || typeof window == \"object\" || typeof WorkerGlobalScope != \"undefined\") throw new Error(\"not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)\");\r\n} else // Note that this includes Node.js workers when relevant (pthreads is enabled).\r\n// Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and\r\n// ENVIRONMENT_IS_NODE.\r\nif (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\r\n  try {\r\n    scriptDirectory = new URL(\".\", _scriptName).href;\r\n  } catch {}\r\n  if (!(typeof window == \"object\" || typeof WorkerGlobalScope != \"undefined\")) throw new Error(\"not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)\");\r\n  // Differentiate the Web Worker from the Node Worker case, as reading must\r\n  // be done differently.\r\n  if (!ENVIRONMENT_IS_NODE) {\r\n    // include: web_or_worker_shell_read.js\r\n    if (ENVIRONMENT_IS_WORKER) {\r\n      readBinary = url => {\r\n        var xhr = new XMLHttpRequest;\r\n        xhr.open(\"GET\", url, false);\r\n        xhr.responseType = \"arraybuffer\";\r\n        xhr.send(null);\r\n        return new Uint8Array(/** @type{!ArrayBuffer} */ (xhr.response));\r\n      };\r\n    }\r\n    readAsync = async url => {\r\n      assert(!isFileURI(url), \"readAsync does not work with file:// URLs\");\r\n      var response = await fetch(url, {\r\n        credentials: \"same-origin\"\r\n      });\r\n      if (response.ok) {\r\n        return response.arrayBuffer();\r\n      }\r\n      throw new Error(response.status + \" : \" + response.url);\r\n    };\r\n  }\r\n} else {\r\n  throw new Error(\"environment detection error\");\r\n}\r\n\r\n// Set up the out() and err() hooks, which are how we can print to stdout or\r\n// stderr, respectively.\r\n// Normally just binding console.log/console.error here works fine, but\r\n// under node (with workers) we see missing/out-of-order messages so route\r\n// directly to stdout and stderr.\r\n// See https://github.com/emscripten-core/emscripten/issues/14804\r\nvar defaultPrint = console.log.bind(console);\r\n\r\nvar defaultPrintErr = console.error.bind(console);\r\n\r\nif (ENVIRONMENT_IS_NODE) {\r\n  var utils = require(\"util\");\r\n  var stringify = a => typeof a == \"object\" ? utils.inspect(a) : a;\r\n  defaultPrint = (...args) => fs.writeSync(1, args.map(stringify).join(\" \") + \"\\n\");\r\n  defaultPrintErr = (...args) => fs.writeSync(2, args.map(stringify).join(\" \") + \"\\n\");\r\n}\r\n\r\nvar out = defaultPrint;\r\n\r\nvar err = defaultPrintErr;\r\n\r\nvar IDBFS = \"IDBFS is no longer included by default; build with -lidbfs.js\";\r\n\r\nvar PROXYFS = \"PROXYFS is no longer included by default; build with -lproxyfs.js\";\r\n\r\nvar WORKERFS = \"WORKERFS is no longer included by default; build with -lworkerfs.js\";\r\n\r\nvar FETCHFS = \"FETCHFS is no longer included by default; build with -lfetchfs.js\";\r\n\r\nvar ICASEFS = \"ICASEFS is no longer included by default; build with -licasefs.js\";\r\n\r\nvar JSFILEFS = \"JSFILEFS is no longer included by default; build with -ljsfilefs.js\";\r\n\r\nvar OPFS = \"OPFS is no longer included by default; build with -lopfs.js\";\r\n\r\nvar NODEFS = \"NODEFS is no longer included by default; build with -lnodefs.js\";\r\n\r\n// perform assertions in shell.js after we set up out() and err(), as otherwise\r\n// if an assertion fails it cannot print the message\r\nassert(ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER || ENVIRONMENT_IS_NODE, \"Pthreads do not work in this environment yet (need Web Workers, or an alternative to them)\");\r\n\r\nassert(!ENVIRONMENT_IS_SHELL, \"shell environment detected but not enabled at build time.  Add `shell` to `-sENVIRONMENT` to enable.\");\r\n\r\n// end include: shell.js\r\n// include: preamble.js\r\n// === Preamble library stuff ===\r\n// Documentation for the public APIs defined in this file must be updated in:\r\n//    site/source/docs/api_reference/preamble.js.rst\r\n// A prebuilt local version of the documentation is available at:\r\n//    site/build/text/docs/api_reference/preamble.js.txt\r\n// You can also build docs locally as HTML or other formats in site/\r\n// An online HTML version (which may be of a different version of Emscripten)\r\n//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html\r\nvar wasmBinary;\r\n\r\nif (typeof WebAssembly != \"object\") {\r\n  err(\"no native wasm support detected\");\r\n}\r\n\r\n// Wasm globals\r\nvar wasmMemory;\r\n\r\n// For sending to workers.\r\nvar wasmModule;\r\n\r\n//========================================\r\n// Runtime essentials\r\n//========================================\r\n// whether we are quitting the application. no code should run after this.\r\n// set in exit() and abort()\r\nvar ABORT = false;\r\n\r\n// set by exit() and abort().  Passed to 'onExit' handler.\r\n// NOTE: This is also used as the process return code code in shell environments\r\n// but only when noExitRuntime is false.\r\nvar EXITSTATUS;\r\n\r\n// In STRICT mode, we only define assert() when ASSERTIONS is set.  i.e. we\r\n// don't define it at all in release modes.  This matches the behaviour of\r\n// MINIMAL_RUNTIME.\r\n// TODO(sbc): Make this the default even without STRICT enabled.\r\n/** @type {function(*, string=)} */ function assert(condition, text) {\r\n  if (!condition) {\r\n    abort(\"Assertion failed\" + (text ? \": \" + text : \"\"));\r\n  }\r\n}\r\n\r\n// We used to include malloc/free by default in the past. Show a helpful error in\r\n// builds with assertions.\r\n// Memory management\r\nvar HEAP, /** @type {!Int8Array} */ HEAP8, /** @type {!Uint8Array} */ HEAPU8, /** @type {!Int16Array} */ HEAP16, /** @type {!Uint16Array} */ HEAPU16, /** @type {!Int32Array} */ HEAP32, /** @type {!Uint32Array} */ HEAPU32, /** @type {!Float32Array} */ HEAPF32, /* BigInt64Array type is not correctly defined in closure\r\n/** not-@type {!BigInt64Array} */ HEAP64, /* BigUint64Array type is not correctly defined in closure\r\n/** not-t@type {!BigUint64Array} */ HEAPU64, /** @type {!Float64Array} */ HEAPF64;\r\n\r\nvar runtimeInitialized = false;\r\n\r\n/**\r\n * Indicates whether filename is delivered via file protocol (as opposed to http/https)\r\n * @noinline\r\n */ var isFileURI = filename => filename.startsWith(\"file://\");\r\n\r\n// include: runtime_shared.js\r\n// include: runtime_stack_check.js\r\n// Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.\r\nfunction writeStackCookie() {\r\n  var max = _emscripten_stack_get_end();\r\n  assert((max & 3) == 0);\r\n  // If the stack ends at address zero we write our cookies 4 bytes into the\r\n  // stack.  This prevents interference with SAFE_HEAP and ASAN which also\r\n  // monitor writes to address zero.\r\n  if (max == 0) {\r\n    max += 4;\r\n  }\r\n  // The stack grow downwards towards _emscripten_stack_get_end.\r\n  // We write cookies to the final two words in the stack and detect if they are\r\n  // ever overwritten.\r\n  GROWABLE_HEAP_U32()[((max) >> 2)] = 34821223;\r\n  GROWABLE_HEAP_U32()[(((max) + (4)) >> 2)] = 2310721022;\r\n  // Also test the global address 0 for integrity.\r\n  GROWABLE_HEAP_U32()[((0) >> 2)] = 1668509029;\r\n}\r\n\r\nfunction checkStackCookie() {\r\n  if (ABORT) return;\r\n  var max = _emscripten_stack_get_end();\r\n  // See writeStackCookie().\r\n  if (max == 0) {\r\n    max += 4;\r\n  }\r\n  var cookie1 = GROWABLE_HEAP_U32()[((max) >> 2)];\r\n  var cookie2 = GROWABLE_HEAP_U32()[(((max) + (4)) >> 2)];\r\n  if (cookie1 != 34821223 || cookie2 != 2310721022) {\r\n    abort(`Stack overflow! Stack cookie has been overwritten at ${ptrToString(max)}, expected hex dwords 0x89BACDFE and 0x2135467, but received ${ptrToString(cookie2)} ${ptrToString(cookie1)}`);\r\n  }\r\n  // Also test the global address 0 for integrity.\r\n  if (GROWABLE_HEAP_U32()[((0) >> 2)] != 1668509029) {\r\n    abort(\"Runtime error: The application has corrupted its heap memory area (address zero)!\");\r\n  }\r\n}\r\n\r\n// end include: runtime_stack_check.js\r\n// include: runtime_exceptions.js\r\n// Base Emscripten EH error class\r\nclass EmscriptenEH extends Error {}\r\n\r\nclass EmscriptenSjLj extends EmscriptenEH {}\r\n\r\nclass CppException extends EmscriptenEH {\r\n  constructor(excPtr) {\r\n    super(excPtr);\r\n    this.excPtr = excPtr;\r\n    const excInfo = getExceptionMessage(excPtr);\r\n    this.name = excInfo[0];\r\n    this.message = excInfo[1];\r\n  }\r\n}\r\n\r\n// end include: runtime_exceptions.js\r\n// include: runtime_debug.js\r\nvar runtimeDebug = true;\r\n\r\n// Switch to false at runtime to disable logging at the right times\r\n// Used by XXXXX_DEBUG settings to output debug messages.\r\nfunction dbg(...args) {\r\n  if (!runtimeDebug && typeof runtimeDebug != \"undefined\") return;\r\n  // Avoid using the console for debugging in multi-threaded node applications\r\n  // See https://github.com/emscripten-core/emscripten/issues/14804\r\n  if (ENVIRONMENT_IS_NODE) {\r\n    // TODO(sbc): Unify with err/out implementation in shell.sh.\r\n    var fs = require(\"fs\");\r\n    var utils = require(\"util\");\r\n    var stringify = a => typeof a == \"object\" ? utils.inspect(a) : a;\r\n    fs.writeSync(1, args.map(stringify).join(\" \") + \"\\n\");\r\n  } else // TODO(sbc): Make this configurable somehow.  Its not always convenient for\r\n  // logging to show up as warnings.\r\n  console.warn(...args);\r\n}\r\n\r\n// Endianness check\r\n(() => {\r\n  var h16 = new Int16Array(1);\r\n  var h8 = new Int8Array(h16.buffer);\r\n  h16[0] = 25459;\r\n  if (h8[0] !== 115 || h8[1] !== 99) throw \"Runtime error: expected the system to be little-endian! (Run with -sSUPPORT_BIG_ENDIAN to bypass)\";\r\n})();\r\n\r\nfunction consumedModuleProp(prop) {\r\n  if (!Object.getOwnPropertyDescriptor(Module, prop)) {\r\n    Object.defineProperty(Module, prop, {\r\n      configurable: true,\r\n      set() {\r\n        abort(`Attempt to set \\`Module.${prop}\\` after it has already been processed.  This can happen, for example, when code is injected via '--post-js' rather than '--pre-js'`);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction ignoredModuleProp(prop) {\r\n  if (Object.getOwnPropertyDescriptor(Module, prop)) {\r\n    abort(`\\`Module.${prop}\\` was supplied but \\`${prop}\\` not included in INCOMING_MODULE_JS_API`);\r\n  }\r\n}\r\n\r\n// forcing the filesystem exports a few things by default\r\nfunction isExportedByForceFilesystem(name) {\r\n  return name === \"FS_createPath\" || name === \"FS_createDataFile\" || name === \"FS_createPreloadedFile\" || name === \"FS_unlink\" || name === \"addRunDependency\" || // The old FS has some functionality that WasmFS lacks.\r\n  name === \"FS_createLazyFile\" || name === \"FS_createDevice\" || name === \"removeRunDependency\";\r\n}\r\n\r\n/**\r\n * Intercept access to a global symbol.  This enables us to give informative\r\n * warnings/errors when folks attempt to use symbols they did not include in\r\n * their build, or no symbols that no longer exist.\r\n */ function hookGlobalSymbolAccess(sym, func) {\r\n  if (typeof globalThis != \"undefined\" && !Object.getOwnPropertyDescriptor(globalThis, sym)) {\r\n    Object.defineProperty(globalThis, sym, {\r\n      configurable: true,\r\n      get() {\r\n        func();\r\n        return undefined;\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction missingGlobal(sym, msg) {\r\n  hookGlobalSymbolAccess(sym, () => {\r\n    warnOnce(`\\`${sym}\\` is not longer defined by emscripten. ${msg}`);\r\n  });\r\n}\r\n\r\nmissingGlobal(\"buffer\", \"Please use HEAP8.buffer or wasmMemory.buffer\");\r\n\r\nmissingGlobal(\"asm\", \"Please use wasmExports instead\");\r\n\r\nfunction missingLibrarySymbol(sym) {\r\n  hookGlobalSymbolAccess(sym, () => {\r\n    // Can't `abort()` here because it would break code that does runtime\r\n    // checks.  e.g. `if (typeof SDL === 'undefined')`.\r\n    var msg = `\\`${sym}\\` is a library symbol and not included by default; add it to your library.js __deps or to DEFAULT_LIBRARY_FUNCS_TO_INCLUDE on the command line`;\r\n    // DEFAULT_LIBRARY_FUNCS_TO_INCLUDE requires the name as it appears in\r\n    // library.js, which means $name for a JS name with no prefix, or name\r\n    // for a JS name like _name.\r\n    var librarySymbol = sym;\r\n    if (!librarySymbol.startsWith(\"_\")) {\r\n      librarySymbol = \"$\" + sym;\r\n    }\r\n    msg += ` (e.g. -sDEFAULT_LIBRARY_FUNCS_TO_INCLUDE='${librarySymbol}')`;\r\n    if (isExportedByForceFilesystem(sym)) {\r\n      msg += \". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you\";\r\n    }\r\n    warnOnce(msg);\r\n  });\r\n  // Any symbol that is not included from the JS library is also (by definition)\r\n  // not exported on the Module object.\r\n  unexportedRuntimeSymbol(sym);\r\n}\r\n\r\nfunction unexportedRuntimeSymbol(sym) {\r\n  if (ENVIRONMENT_IS_PTHREAD) {\r\n    return;\r\n  }\r\n  if (!Object.getOwnPropertyDescriptor(Module, sym)) {\r\n    Object.defineProperty(Module, sym, {\r\n      configurable: true,\r\n      get() {\r\n        var msg = `'${sym}' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the Emscripten FAQ)`;\r\n        if (isExportedByForceFilesystem(sym)) {\r\n          msg += \". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you\";\r\n        }\r\n        abort(msg);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Override `err`/`out`/`dbg` to report thread / worker information\r\n */ function initWorkerLogging() {\r\n  function getLogPrefix() {\r\n    var t = 0;\r\n    if (runtimeInitialized && typeof _pthread_self != \"undefined\") {\r\n      t = _pthread_self();\r\n    }\r\n    return `w:${workerID},t:${ptrToString(t)}:`;\r\n  }\r\n  // Prefix all dbg() messages with the calling thread info.\r\n  var origDbg = dbg;\r\n  dbg = (...args) => origDbg(getLogPrefix(), ...args);\r\n}\r\n\r\ninitWorkerLogging();\r\n\r\n// end include: runtime_debug.js\r\n// include: memoryprofiler.js\r\n// end include: memoryprofiler.js\r\n// include: growableHeap.js\r\n// Support for growable heap + pthreads, where the buffer may change, so JS views\r\n// must be updated.\r\nfunction GROWABLE_HEAP_I8() {\r\n  if (wasmMemory.buffer != HEAP8.buffer) {\r\n    updateMemoryViews();\r\n  }\r\n  return HEAP8;\r\n}\r\n\r\nfunction GROWABLE_HEAP_U8() {\r\n  if (wasmMemory.buffer != HEAP8.buffer) {\r\n    updateMemoryViews();\r\n  }\r\n  return HEAPU8;\r\n}\r\n\r\nfunction GROWABLE_HEAP_I16() {\r\n  if (wasmMemory.buffer != HEAP8.buffer) {\r\n    updateMemoryViews();\r\n  }\r\n  return HEAP16;\r\n}\r\n\r\nfunction GROWABLE_HEAP_U16() {\r\n  if (wasmMemory.buffer != HEAP8.buffer) {\r\n    updateMemoryViews();\r\n  }\r\n  return HEAPU16;\r\n}\r\n\r\nfunction GROWABLE_HEAP_I32() {\r\n  if (wasmMemory.buffer != HEAP8.buffer) {\r\n    updateMemoryViews();\r\n  }\r\n  return HEAP32;\r\n}\r\n\r\nfunction GROWABLE_HEAP_U32() {\r\n  if (wasmMemory.buffer != HEAP8.buffer) {\r\n    updateMemoryViews();\r\n  }\r\n  return HEAPU32;\r\n}\r\n\r\nfunction GROWABLE_HEAP_F32() {\r\n  if (wasmMemory.buffer != HEAP8.buffer) {\r\n    updateMemoryViews();\r\n  }\r\n  return HEAPF32;\r\n}\r\n\r\nfunction GROWABLE_HEAP_F64() {\r\n  if (wasmMemory.buffer != HEAP8.buffer) {\r\n    updateMemoryViews();\r\n  }\r\n  return HEAPF64;\r\n}\r\n\r\n// end include: growableHeap.js\r\nvar wasmModuleReceived;\r\n\r\nif (ENVIRONMENT_IS_NODE && (ENVIRONMENT_IS_PTHREAD)) {\r\n  // Create as web-worker-like an environment as we can.\r\n  var parentPort = worker_threads[\"parentPort\"];\r\n  parentPort.on(\"message\", msg => global.onmessage?.({\r\n    data: msg\r\n  }));\r\n  Object.assign(globalThis, {\r\n    self: global,\r\n    postMessage: msg => parentPort[\"postMessage\"](msg)\r\n  });\r\n}\r\n\r\n// include: runtime_pthread.js\r\n// Pthread Web Worker handling code.\r\n// This code runs only on pthread web workers and handles pthread setup\r\n// and communication with the main thread via postMessage.\r\n// Unique ID of the current pthread worker (zero on non-pthread-workers\r\n// including the main thread).\r\nvar workerID = 0;\r\n\r\nif (ENVIRONMENT_IS_PTHREAD) {\r\n  // Thread-local guard variable for one-time init of the JS state\r\n  var initializedJS = false;\r\n  // Turn unhandled rejected promises into errors so that the main thread will be\r\n  // notified about them.\r\n  self.onunhandledrejection = e => {\r\n    throw e.reason || e;\r\n  };\r\n  function handleMessage(e) {\r\n    try {\r\n      var msgData = e[\"data\"];\r\n      //dbg('msgData: ' + Object.keys(msgData));\r\n      var cmd = msgData.cmd;\r\n      if (cmd === \"load\") {\r\n        // Preload command that is called once per worker to parse and load the Emscripten code.\r\n        workerID = msgData.workerID;\r\n        // Until we initialize the runtime, queue up any further incoming messages.\r\n        let messageQueue = [];\r\n        self.onmessage = e => messageQueue.push(e);\r\n        // And add a callback for when the runtime is initialized.\r\n        self.startWorker = instance => {\r\n          // Notify the main thread that this thread has loaded.\r\n          postMessage({\r\n            cmd: \"loaded\"\r\n          });\r\n          // Process any messages that were queued before the thread was ready.\r\n          for (let msg of messageQueue) {\r\n            handleMessage(msg);\r\n          }\r\n          // Restore the real message handler.\r\n          self.onmessage = handleMessage;\r\n        };\r\n        // Use `const` here to ensure that the variable is scoped only to\r\n        // that iteration, allowing safe reference from a closure.\r\n        for (const handler of msgData.handlers) {\r\n          // The the main module has a handler for a certain even, but no\r\n          // handler exists on the pthread worker, then proxy that handler\r\n          // back to the main thread.\r\n          if (!Module[handler] || Module[handler].proxy) {\r\n            Module[handler] = (...args) => {\r\n              postMessage({\r\n                cmd: \"callHandler\",\r\n                handler,\r\n                args\r\n              });\r\n            };\r\n            // Rebind the out / err handlers if needed\r\n            if (handler == \"print\") out = Module[handler];\r\n            if (handler == \"printErr\") err = Module[handler];\r\n          }\r\n        }\r\n        wasmMemory = msgData.wasmMemory;\r\n        updateMemoryViews();\r\n        wasmModuleReceived(msgData.wasmModule);\r\n      } else if (cmd === \"run\") {\r\n        assert(msgData.pthread_ptr);\r\n        // Call inside JS module to set up the stack frame for this pthread in JS module scope.\r\n        // This needs to be the first thing that we do, as we cannot call to any C/C++ functions\r\n        // until the thread stack is initialized.\r\n        establishStackSpace(msgData.pthread_ptr);\r\n        // Pass the thread address to wasm to store it for fast access.\r\n        __emscripten_thread_init(msgData.pthread_ptr, /*is_main=*/ 0, /*is_runtime=*/ 0, /*can_block=*/ 1, 0, 0);\r\n        PThread.threadInitTLS();\r\n        // Await mailbox notifications with `Atomics.waitAsync` so we can start\r\n        // using the fast `Atomics.notify` notification path.\r\n        __emscripten_thread_mailbox_await(msgData.pthread_ptr);\r\n        if (!initializedJS) {\r\n          // Embind must initialize itself on all threads, as it generates support JS.\r\n          // We only do this once per worker since they get reused\r\n          __embind_initialize_bindings();\r\n          initializedJS = true;\r\n        }\r\n        try {\r\n          invokeEntryPoint(msgData.start_routine, msgData.arg);\r\n        } catch (ex) {\r\n          if (ex != \"unwind\") {\r\n            // The pthread \"crashed\".  Do not call `_emscripten_thread_exit` (which\r\n            // would make this thread joinable).  Instead, re-throw the exception\r\n            // and let the top level handler propagate it back to the main thread.\r\n            throw ex;\r\n          }\r\n        }\r\n      } else if (msgData.target === \"setimmediate\") {} else if (cmd === \"checkMailbox\") {\r\n        if (initializedJS) {\r\n          checkMailbox();\r\n        }\r\n      } else if (cmd) {\r\n        // The received message looks like something that should be handled by this message\r\n        // handler, (since there is a cmd field present), but is not one of the\r\n        // recognized commands:\r\n        err(`worker: received unknown command ${cmd}`);\r\n        err(msgData);\r\n      }\r\n    } catch (ex) {\r\n      err(`worker: onmessage() captured an uncaught exception: ${ex}`);\r\n      if (ex?.stack) err(ex.stack);\r\n      __emscripten_thread_crashed();\r\n      throw ex;\r\n    }\r\n  }\r\n  self.onmessage = handleMessage;\r\n}\r\n\r\n// ENVIRONMENT_IS_PTHREAD\r\n// end include: runtime_pthread.js\r\nfunction updateMemoryViews() {\r\n  var b = wasmMemory.buffer;\r\n  HEAP8 = new Int8Array(b);\r\n  HEAP16 = new Int16Array(b);\r\n  Module[\"HEAPU8\"] = HEAPU8 = new Uint8Array(b);\r\n  HEAPU16 = new Uint16Array(b);\r\n  Module[\"HEAP32\"] = HEAP32 = new Int32Array(b);\r\n  HEAPU32 = new Uint32Array(b);\r\n  Module[\"HEAPF32\"] = HEAPF32 = new Float32Array(b);\r\n  HEAPF64 = new Float64Array(b);\r\n  HEAP64 = new BigInt64Array(b);\r\n  HEAPU64 = new BigUint64Array(b);\r\n}\r\n\r\n// end include: runtime_shared.js\r\nassert(typeof Int32Array != \"undefined\" && typeof Float64Array !== \"undefined\" && Int32Array.prototype.subarray != undefined && Int32Array.prototype.set != undefined, \"JS engine does not provide full typed array support\");\r\n\r\n// In non-standalone/normal mode, we create the memory here.\r\n// include: runtime_init_memory.js\r\n// Create the wasm memory. (Note: this only applies if IMPORTED_MEMORY is defined)\r\n// check for full engine support (use string 'subarray' to avoid closure compiler confusion)\r\nfunction initMemory() {\r\n  if ((ENVIRONMENT_IS_PTHREAD)) {\r\n    return;\r\n  }\r\n  {\r\n    var INITIAL_MEMORY = 134217728;\r\n    assert(INITIAL_MEMORY >= 2097152, \"INITIAL_MEMORY should be larger than STACK_SIZE, was \" + INITIAL_MEMORY + \"! (STACK_SIZE=\" + 2097152 + \")\");\r\n    /** @suppress {checkTypes} */ wasmMemory = new WebAssembly.Memory({\r\n      \"initial\": INITIAL_MEMORY / 65536,\r\n      // In theory we should not need to emit the maximum if we want \"unlimited\"\r\n      // or 4GB of memory, but VMs error on that atm, see\r\n      // https://github.com/emscripten-core/emscripten/issues/14130\r\n      // And in the pthreads case we definitely need to emit a maximum. So\r\n      // always emit one.\r\n      \"maximum\": 32768,\r\n      \"shared\": true\r\n    });\r\n  }\r\n  updateMemoryViews();\r\n}\r\n\r\n// end include: runtime_init_memory.js\r\nfunction preRun() {\r\n  assert(!ENVIRONMENT_IS_PTHREAD);\r\n  // PThreads reuse the runtime from the main thread.\r\n  // Begin ATPRERUNS hooks\r\n  callRuntimeCallbacks(onPreRuns);\r\n}\r\n\r\nfunction initRuntime() {\r\n  assert(!runtimeInitialized);\r\n  runtimeInitialized = true;\r\n  if (ENVIRONMENT_IS_PTHREAD) return startWorker(Module);\r\n  checkStackCookie();\r\n  // Begin ATINITS hooks\r\n  if (!Module[\"noFSInit\"] && !FS.initialized) FS.init();\r\n  TTY.init();\r\n  // End ATINITS hooks\r\n  wasmExports[\"__wasm_call_ctors\"]();\r\n  // Begin ATPOSTCTORS hooks\r\n  FS.ignorePermissions = false;\r\n}\r\n\r\nfunction preMain() {\r\n  checkStackCookie();\r\n}\r\n\r\nfunction postRun() {\r\n  checkStackCookie();\r\n  if ((ENVIRONMENT_IS_PTHREAD)) {\r\n    return;\r\n  }\r\n}\r\n\r\n// A counter of dependencies for calling run(). If we need to\r\n// do asynchronous work before running, increment this and\r\n// decrement it. Incrementing must happen in a place like\r\n// Module.preRun (used by emcc to add file preloading).\r\n// Note that you can add dependencies in preRun, even though\r\n// it happens right before run - run will be postponed until\r\n// the dependencies are met.\r\nvar runDependencies = 0;\r\n\r\nvar dependenciesFulfilled = null;\r\n\r\n// overridden to take different actions when all run dependencies are fulfilled\r\nvar runDependencyTracking = {};\r\n\r\nvar runDependencyWatcher = null;\r\n\r\nfunction getUniqueRunDependency(id) {\r\n  var orig = id;\r\n  while (1) {\r\n    if (!runDependencyTracking[id]) return id;\r\n    id = orig + Math.random();\r\n  }\r\n}\r\n\r\nfunction addRunDependency(id) {\r\n  runDependencies++;\r\n  if (id) {\r\n    assert(!runDependencyTracking[id]);\r\n    runDependencyTracking[id] = 1;\r\n    if (runDependencyWatcher === null && typeof setInterval != \"undefined\") {\r\n      // Check for missing dependencies every few seconds\r\n      runDependencyWatcher = setInterval(() => {\r\n        if (ABORT) {\r\n          clearInterval(runDependencyWatcher);\r\n          runDependencyWatcher = null;\r\n          return;\r\n        }\r\n        var shown = false;\r\n        for (var dep in runDependencyTracking) {\r\n          if (!shown) {\r\n            shown = true;\r\n            err(\"still waiting on run dependencies:\");\r\n          }\r\n          err(`dependency: ${dep}`);\r\n        }\r\n        if (shown) {\r\n          err(\"(end of list)\");\r\n        }\r\n      }, 1e4);\r\n    }\r\n  } else {\r\n    err(\"warning: run dependency added without ID\");\r\n  }\r\n}\r\n\r\nfunction removeRunDependency(id) {\r\n  runDependencies--;\r\n  if (id) {\r\n    assert(runDependencyTracking[id]);\r\n    delete runDependencyTracking[id];\r\n  } else {\r\n    err(\"warning: run dependency removed without ID\");\r\n  }\r\n  if (runDependencies == 0) {\r\n    if (runDependencyWatcher !== null) {\r\n      clearInterval(runDependencyWatcher);\r\n      runDependencyWatcher = null;\r\n    }\r\n    if (dependenciesFulfilled) {\r\n      var callback = dependenciesFulfilled;\r\n      dependenciesFulfilled = null;\r\n      callback();\r\n    }\r\n  }\r\n}\r\n\r\n/** @param {string|number=} what */ function abort(what) {\r\n  what = \"Aborted(\" + what + \")\";\r\n  // TODO(sbc): Should we remove printing and leave it up to whoever\r\n  // catches the exception?\r\n  err(what);\r\n  ABORT = true;\r\n  // Use a wasm runtime error, because a JS error might be seen as a foreign\r\n  // exception, which means we'd run destructors on it. We need the error to\r\n  // simply make the program stop.\r\n  // FIXME This approach does not work in Wasm EH because it currently does not assume\r\n  // all RuntimeErrors are from traps; it decides whether a RuntimeError is from\r\n  // a trap or not based on a hidden field within the object. So at the moment\r\n  // we don't have a way of throwing a wasm trap from JS. TODO Make a JS API that\r\n  // allows this in the wasm spec.\r\n  // Suppress closure compiler warning here. Closure compiler's builtin extern\r\n  // definition for WebAssembly.RuntimeError claims it takes no arguments even\r\n  // though it can.\r\n  // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure gets fixed.\r\n  /** @suppress {checkTypes} */ var e = new WebAssembly.RuntimeError(what);\r\n  readyPromiseReject(e);\r\n  // Throw the error whether or not MODULARIZE is set because abort is used\r\n  // in code paths apart from instantiation where an exception is expected\r\n  // to be thrown when abort is called.\r\n  throw e;\r\n}\r\n\r\nfunction createExportWrapper(name, nargs) {\r\n  return (...args) => {\r\n    assert(runtimeInitialized, `native function \\`${name}\\` called before runtime initialization`);\r\n    var f = wasmExports[name];\r\n    assert(f, `exported native function \\`${name}\\` not found`);\r\n    // Only assert for too many arguments. Too few can be valid since the missing arguments will be zero filled.\r\n    assert(args.length <= nargs, `native function \\`${name}\\` called with ${args.length} args but expects ${nargs}`);\r\n    return f(...args);\r\n  };\r\n}\r\n\r\nvar wasmBinaryFile;\r\n\r\nfunction findWasmBinary() {\r\n  if (Module[\"locateFile\"]) {\r\n    return locateFile(\"wasm_boids.wasm\");\r\n  }\r\n  // Use bundler-friendly `new URL(..., import.meta.url)` pattern; works in browsers too.\r\n  return new URL(\"wasm_boids.wasm\", import.meta.url).href;\r\n}\r\n\r\nfunction getBinarySync(file) {\r\n  if (readBinary) {\r\n    return readBinary(file);\r\n  }\r\n  throw \"both async and sync fetching of the wasm failed\";\r\n}\r\n\r\nasync function getWasmBinary(binaryFile) {\r\n  // If we don't have the binary yet, load it asynchronously using readAsync.\r\n  if (!wasmBinary) {\r\n    // Fetch the binary using readAsync\r\n    try {\r\n      var response = await readAsync(binaryFile);\r\n      return new Uint8Array(response);\r\n    } catch {}\r\n  }\r\n  // Otherwise, getBinarySync should be able to get it synchronously\r\n  return getBinarySync(binaryFile);\r\n}\r\n\r\nasync function instantiateArrayBuffer(binaryFile, imports) {\r\n  try {\r\n    var binary = await getWasmBinary(binaryFile);\r\n    var instance = await WebAssembly.instantiate(binary, imports);\r\n    return instance;\r\n  } catch (reason) {\r\n    err(`failed to asynchronously prepare wasm: ${reason}`);\r\n    // Warn on some common problems.\r\n    if (isFileURI(wasmBinaryFile)) {\r\n      err(`warning: Loading from a file URI (${wasmBinaryFile}) is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing`);\r\n    }\r\n    abort(reason);\r\n  }\r\n}\r\n\r\nasync function instantiateAsync(binary, binaryFile, imports) {\r\n  if (!binary && typeof WebAssembly.instantiateStreaming == \"function\" && !ENVIRONMENT_IS_NODE) {\r\n    try {\r\n      var response = fetch(binaryFile, {\r\n        credentials: \"same-origin\"\r\n      });\r\n      var instantiationResult = await WebAssembly.instantiateStreaming(response, imports);\r\n      return instantiationResult;\r\n    } catch (reason) {\r\n      // We expect the most common failure cause to be a bad MIME type for the binary,\r\n      // in which case falling back to ArrayBuffer instantiation should work.\r\n      err(`wasm streaming compile failed: ${reason}`);\r\n      err(\"falling back to ArrayBuffer instantiation\");\r\n    }\r\n  }\r\n  return instantiateArrayBuffer(binaryFile, imports);\r\n}\r\n\r\nfunction getWasmImports() {\r\n  assignWasmImports();\r\n  // prepare imports\r\n  return {\r\n    \"env\": wasmImports,\r\n    \"wasi_snapshot_preview1\": wasmImports\r\n  };\r\n}\r\n\r\n// Create the wasm instance.\r\n// Receives the wasm imports, returns the exports.\r\nasync function createWasm() {\r\n  // Load the wasm module and create an instance of using native support in the JS engine.\r\n  // handle a generated wasm instance, receiving its exports and\r\n  // performing other necessary setup\r\n  /** @param {WebAssembly.Module=} module*/ function receiveInstance(instance, module) {\r\n    wasmExports = instance.exports;\r\n    registerTLSInit(wasmExports[\"_emscripten_tls_init\"]);\r\n    wasmTable = wasmExports[\"__indirect_function_table\"];\r\n    assert(wasmTable, \"table not found in wasm exports\");\r\n    // We now have the Wasm module loaded up, keep a reference to the compiled module so we can post it to the workers.\r\n    wasmModule = module;\r\n    removeRunDependency(\"wasm-instantiate\");\r\n    return wasmExports;\r\n  }\r\n  // wait for the pthread pool (if any)\r\n  addRunDependency(\"wasm-instantiate\");\r\n  // Prefer streaming instantiation if available.\r\n  // Async compilation can be confusing when an error on the page overwrites Module\r\n  // (for example, if the order of elements is wrong, and the one defining Module is\r\n  // later), so we save Module and check it later.\r\n  var trueModule = Module;\r\n  function receiveInstantiationResult(result) {\r\n    // 'result' is a ResultObject object which has both the module and instance.\r\n    // receiveInstance() will swap in the exports (to Module.asm) so they can be called\r\n    assert(Module === trueModule, \"the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?\");\r\n    trueModule = null;\r\n    return receiveInstance(result[\"instance\"], result[\"module\"]);\r\n  }\r\n  var info = getWasmImports();\r\n  if ((ENVIRONMENT_IS_PTHREAD)) {\r\n    return new Promise(resolve => {\r\n      wasmModuleReceived = module => {\r\n        // Instantiate from the module posted from the main thread.\r\n        // We can just use sync instantiation in the worker.\r\n        var instance = new WebAssembly.Instance(module, getWasmImports());\r\n        resolve(receiveInstance(instance, module));\r\n      };\r\n    });\r\n  }\r\n  wasmBinaryFile ??= findWasmBinary();\r\n  try {\r\n    var result = await instantiateAsync(wasmBinary, wasmBinaryFile, info);\r\n    var exports = receiveInstantiationResult(result);\r\n    return exports;\r\n  } catch (e) {\r\n    // If instantiation fails, reject the module ready promise.\r\n    readyPromiseReject(e);\r\n    return Promise.reject(e);\r\n  }\r\n}\r\n\r\n// end include: preamble.js\r\n// Begin JS library code\r\nclass ExitStatus {\r\n  name=\"ExitStatus\";\r\n  constructor(status) {\r\n    this.message = `Program terminated with exit(${status})`;\r\n    this.status = status;\r\n  }\r\n}\r\n\r\nvar terminateWorker = worker => {\r\n  worker.terminate();\r\n  // terminate() can be asynchronous, so in theory the worker can continue\r\n  // to run for some amount of time after termination.  However from our POV\r\n  // the worker now dead and we don't want to hear from it again, so we stub\r\n  // out its message handler here.  This avoids having to check in each of\r\n  // the onmessage handlers if the message was coming from valid worker.\r\n  worker.onmessage = e => {\r\n    var cmd = e[\"data\"].cmd;\r\n    err(`received \"${cmd}\" command from terminated worker: ${worker.workerID}`);\r\n  };\r\n};\r\n\r\nvar cleanupThread = pthread_ptr => {\r\n  assert(!ENVIRONMENT_IS_PTHREAD, \"Internal Error! cleanupThread() can only ever be called from main application thread!\");\r\n  assert(pthread_ptr, \"Internal Error! Null pthread_ptr in cleanupThread!\");\r\n  var worker = PThread.pthreads[pthread_ptr];\r\n  assert(worker);\r\n  PThread.returnWorkerToPool(worker);\r\n};\r\n\r\nvar callRuntimeCallbacks = callbacks => {\r\n  while (callbacks.length > 0) {\r\n    // Pass the module as the first argument.\r\n    callbacks.shift()(Module);\r\n  }\r\n};\r\n\r\nvar onPreRuns = [];\r\n\r\nvar addOnPreRun = cb => onPreRuns.push(cb);\r\n\r\nvar spawnThread = threadParams => {\r\n  assert(!ENVIRONMENT_IS_PTHREAD, \"Internal Error! spawnThread() can only ever be called from main application thread!\");\r\n  assert(threadParams.pthread_ptr, \"Internal error, no pthread ptr!\");\r\n  var worker = PThread.getNewWorker();\r\n  if (!worker) {\r\n    // No available workers in the PThread pool.\r\n    return 6;\r\n  }\r\n  assert(!worker.pthread_ptr, \"Internal error!\");\r\n  PThread.runningWorkers.push(worker);\r\n  // Add to pthreads map\r\n  PThread.pthreads[threadParams.pthread_ptr] = worker;\r\n  worker.pthread_ptr = threadParams.pthread_ptr;\r\n  var msg = {\r\n    cmd: \"run\",\r\n    start_routine: threadParams.startRoutine,\r\n    arg: threadParams.arg,\r\n    pthread_ptr: threadParams.pthread_ptr\r\n  };\r\n  if (ENVIRONMENT_IS_NODE) {\r\n    // Mark worker as weakly referenced once we start executing a pthread,\r\n    // so that its existence does not prevent Node.js from exiting.  This\r\n    // has no effect if the worker is already weakly referenced (e.g. if\r\n    // this worker was previously idle/unused).\r\n    worker.unref();\r\n  }\r\n  // Ask the worker to start executing its pthread entry point function.\r\n  worker.postMessage(msg, threadParams.transferList);\r\n  return 0;\r\n};\r\n\r\nvar runtimeKeepaliveCounter = 0;\r\n\r\nvar keepRuntimeAlive = () => runtimeKeepaliveCounter > 0;\r\n\r\nvar stackSave = () => _emscripten_stack_get_current();\r\n\r\nvar stackRestore = val => __emscripten_stack_restore(val);\r\n\r\nvar stackAlloc = sz => __emscripten_stack_alloc(sz);\r\n\r\n/** @type{function(number, (number|boolean), ...number)} */ var proxyToMainThread = (funcIndex, emAsmAddr, sync, ...callArgs) => {\r\n  // EM_ASM proxying is done by passing a pointer to the address of the EM_ASM\r\n  // content as `emAsmAddr`.  JS library proxying is done by passing an index\r\n  // into `proxiedJSCallArgs` as `funcIndex`. If `emAsmAddr` is non-zero then\r\n  // `funcIndex` will be ignored.\r\n  // Additional arguments are passed after the first three are the actual\r\n  // function arguments.\r\n  // The serialization buffer contains the number of call params, and then\r\n  // all the args here.\r\n  // We also pass 'sync' to C separately, since C needs to look at it.\r\n  // Allocate a buffer, which will be copied by the C code.\r\n  // First passed parameter specifies the number of arguments to the function.\r\n  // When BigInt support is enabled, we must handle types in a more complex\r\n  // way, detecting at runtime if a value is a BigInt or not (as we have no\r\n  // type info here). To do that, add a \"prefix\" before each value that\r\n  // indicates if it is a BigInt, which effectively doubles the number of\r\n  // values we serialize for proxying. TODO: pack this?\r\n  var serializedNumCallArgs = callArgs.length * 2;\r\n  var sp = stackSave();\r\n  var args = stackAlloc(serializedNumCallArgs * 8);\r\n  var b = ((args) >> 3);\r\n  for (var i = 0; i < callArgs.length; i++) {\r\n    var arg = callArgs[i];\r\n    if (typeof arg == \"bigint\") {\r\n      // The prefix is non-zero to indicate a bigint.\r\n      HEAP64[b + 2 * i] = 1n;\r\n      HEAP64[b + 2 * i + 1] = arg;\r\n    } else {\r\n      // The prefix is zero to indicate a JS Number.\r\n      HEAP64[b + 2 * i] = 0n;\r\n      GROWABLE_HEAP_F64()[b + 2 * i + 1] = arg;\r\n    }\r\n  }\r\n  var rtn = __emscripten_run_on_main_thread_js(funcIndex, emAsmAddr, serializedNumCallArgs, args, sync);\r\n  stackRestore(sp);\r\n  return rtn;\r\n};\r\n\r\nfunction _proc_exit(code) {\r\n  if (ENVIRONMENT_IS_PTHREAD) return proxyToMainThread(0, 0, 1, code);\r\n  EXITSTATUS = code;\r\n  if (!keepRuntimeAlive()) {\r\n    PThread.terminateAllThreads();\r\n    ABORT = true;\r\n  }\r\n  quit_(code, new ExitStatus(code));\r\n}\r\n\r\nvar runtimeKeepalivePop = () => {\r\n  assert(runtimeKeepaliveCounter > 0);\r\n  runtimeKeepaliveCounter -= 1;\r\n};\r\n\r\nfunction exitOnMainThread(returnCode) {\r\n  if (ENVIRONMENT_IS_PTHREAD) return proxyToMainThread(1, 0, 0, returnCode);\r\n  runtimeKeepalivePop();\r\n  _exit(returnCode);\r\n}\r\n\r\n/** @suppress {duplicate } */ /** @param {boolean|number=} implicit */ var exitJS = (status, implicit) => {\r\n  EXITSTATUS = status;\r\n  checkUnflushedContent();\r\n  if (ENVIRONMENT_IS_PTHREAD) {\r\n    // implicit exit can never happen on a pthread\r\n    assert(!implicit);\r\n    // When running in a pthread we propagate the exit back to the main thread\r\n    // where it can decide if the whole process should be shut down or not.\r\n    // The pthread may have decided not to exit its own runtime, for example\r\n    // because it runs a main loop, but that doesn't affect the main thread.\r\n    exitOnMainThread(status);\r\n    throw \"unwind\";\r\n  }\r\n  // if exit() was called explicitly, warn the user if the runtime isn't actually being shut down\r\n  if (keepRuntimeAlive() && !implicit) {\r\n    var msg = `program exited (with status: ${status}), but keepRuntimeAlive() is set (counter=${runtimeKeepaliveCounter}) due to an async operation, so halting execution but not exiting the runtime or preventing further async execution (you can use emscripten_force_exit, if you want to force a true shutdown)`;\r\n    readyPromiseReject(msg);\r\n    err(msg);\r\n  }\r\n  _proc_exit(status);\r\n};\r\n\r\nvar _exit = exitJS;\r\n\r\nvar ptrToString = ptr => {\r\n  assert(typeof ptr === \"number\");\r\n  // With CAN_ADDRESS_2GB or MEMORY64, pointers are already unsigned.\r\n  ptr >>>= 0;\r\n  return \"0x\" + ptr.toString(16).padStart(8, \"0\");\r\n};\r\n\r\nvar PThread = {\r\n  unusedWorkers: [],\r\n  runningWorkers: [],\r\n  tlsInitFunctions: [],\r\n  pthreads: {},\r\n  nextWorkerID: 1,\r\n  init() {\r\n    if ((!(ENVIRONMENT_IS_PTHREAD))) {\r\n      PThread.initMainThread();\r\n    }\r\n  },\r\n  initMainThread() {\r\n    var pthreadPoolSize = navigator.hardwareConcurrency;\r\n    // Start loading up the Worker pool, if requested.\r\n    while (pthreadPoolSize--) {\r\n      PThread.allocateUnusedWorker();\r\n    }\r\n    // MINIMAL_RUNTIME takes care of calling loadWasmModuleToAllWorkers\r\n    // in postamble_minimal.js\r\n    addOnPreRun(() => {\r\n      addRunDependency(\"loading-workers\");\r\n      PThread.loadWasmModuleToAllWorkers(() => removeRunDependency(\"loading-workers\"));\r\n    });\r\n  },\r\n  terminateAllThreads: () => {\r\n    assert(!ENVIRONMENT_IS_PTHREAD, \"Internal Error! terminateAllThreads() can only ever be called from main application thread!\");\r\n    // Attempt to kill all workers.  Sadly (at least on the web) there is no\r\n    // way to terminate a worker synchronously, or to be notified when a\r\n    // worker in actually terminated.  This means there is some risk that\r\n    // pthreads will continue to be executing after `worker.terminate` has\r\n    // returned.  For this reason, we don't call `returnWorkerToPool` here or\r\n    // free the underlying pthread data structures.\r\n    for (var worker of PThread.runningWorkers) {\r\n      terminateWorker(worker);\r\n    }\r\n    for (var worker of PThread.unusedWorkers) {\r\n      terminateWorker(worker);\r\n    }\r\n    PThread.unusedWorkers = [];\r\n    PThread.runningWorkers = [];\r\n    PThread.pthreads = {};\r\n  },\r\n  returnWorkerToPool: worker => {\r\n    // We don't want to run main thread queued calls here, since we are doing\r\n    // some operations that leave the worker queue in an invalid state until\r\n    // we are completely done (it would be bad if free() ends up calling a\r\n    // queued pthread_create which looks at the global data structures we are\r\n    // modifying). To achieve that, defer the free() til the very end, when\r\n    // we are all done.\r\n    var pthread_ptr = worker.pthread_ptr;\r\n    delete PThread.pthreads[pthread_ptr];\r\n    // Note: worker is intentionally not terminated so the pool can\r\n    // dynamically grow.\r\n    PThread.unusedWorkers.push(worker);\r\n    PThread.runningWorkers.splice(PThread.runningWorkers.indexOf(worker), 1);\r\n    // Not a running Worker anymore\r\n    // Detach the worker from the pthread object, and return it to the\r\n    // worker pool as an unused worker.\r\n    worker.pthread_ptr = 0;\r\n    if (ENVIRONMENT_IS_NODE) {\r\n      // Once the proxied main thread has finished, mark it as weakly\r\n      // referenced so that its existence does not prevent Node.js from\r\n      // exiting.  This has no effect if the worker is already weakly\r\n      // referenced.\r\n      worker.unref();\r\n    }\r\n    // Finally, free the underlying (and now-unused) pthread structure in\r\n    // linear memory.\r\n    __emscripten_thread_free_data(pthread_ptr);\r\n  },\r\n  threadInitTLS() {\r\n    // Call thread init functions (these are the _emscripten_tls_init for each\r\n    // module loaded.\r\n    PThread.tlsInitFunctions.forEach(f => f());\r\n  },\r\n  loadWasmModuleToWorker: worker => new Promise(onFinishedLoading => {\r\n    worker.onmessage = e => {\r\n      var d = e[\"data\"];\r\n      var cmd = d.cmd;\r\n      // If this message is intended to a recipient that is not the main\r\n      // thread, forward it to the target thread.\r\n      if (d.targetThread && d.targetThread != _pthread_self()) {\r\n        var targetWorker = PThread.pthreads[d.targetThread];\r\n        if (targetWorker) {\r\n          targetWorker.postMessage(d, d.transferList);\r\n        } else {\r\n          err(`Internal error! Worker sent a message \"${cmd}\" to target pthread ${d.targetThread}, but that thread no longer exists!`);\r\n        }\r\n        return;\r\n      }\r\n      if (cmd === \"checkMailbox\") {\r\n        checkMailbox();\r\n      } else if (cmd === \"spawnThread\") {\r\n        spawnThread(d);\r\n      } else if (cmd === \"cleanupThread\") {\r\n        cleanupThread(d.thread);\r\n      } else if (cmd === \"loaded\") {\r\n        worker.loaded = true;\r\n        // Check that this worker doesn't have an associated pthread.\r\n        if (ENVIRONMENT_IS_NODE && !worker.pthread_ptr) {\r\n          // Once worker is loaded & idle, mark it as weakly referenced,\r\n          // so that mere existence of a Worker in the pool does not prevent\r\n          // Node.js from exiting the app.\r\n          worker.unref();\r\n        }\r\n        onFinishedLoading(worker);\r\n      } else if (d.target === \"setimmediate\") {\r\n        // Worker wants to postMessage() to itself to implement setImmediate()\r\n        // emulation.\r\n        worker.postMessage(d);\r\n      } else if (cmd === \"callHandler\") {\r\n        Module[d.handler](...d.args);\r\n      } else if (cmd) {\r\n        // The received message looks like something that should be handled by this message\r\n        // handler, (since there is a e.data.cmd field present), but is not one of the\r\n        // recognized commands:\r\n        err(`worker sent an unknown command ${cmd}`);\r\n      }\r\n    };\r\n    worker.onerror = e => {\r\n      var message = \"worker sent an error!\";\r\n      if (worker.pthread_ptr) {\r\n        message = `Pthread ${ptrToString(worker.pthread_ptr)} sent an error!`;\r\n      }\r\n      err(`${message} ${e.filename}:${e.lineno}: ${e.message}`);\r\n      throw e;\r\n    };\r\n    if (ENVIRONMENT_IS_NODE) {\r\n      worker.on(\"message\", data => worker.onmessage({\r\n        data\r\n      }));\r\n      worker.on(\"error\", e => worker.onerror(e));\r\n    }\r\n    assert(wasmMemory instanceof WebAssembly.Memory, \"WebAssembly memory should have been loaded by now!\");\r\n    assert(wasmModule instanceof WebAssembly.Module, \"WebAssembly Module should have been loaded by now!\");\r\n    // When running on a pthread, none of the incoming parameters on the module\r\n    // object are present. Proxy known handlers back to the main thread if specified.\r\n    var handlers = [];\r\n    var knownHandlers = [];\r\n    for (var handler of knownHandlers) {\r\n      if (Module.propertyIsEnumerable(handler)) {\r\n        handlers.push(handler);\r\n      }\r\n    }\r\n    // Ask the new worker to load up the Emscripten-compiled page. This is a heavy operation.\r\n    worker.postMessage({\r\n      cmd: \"load\",\r\n      handlers,\r\n      wasmMemory,\r\n      wasmModule,\r\n      \"workerID\": worker.workerID\r\n    });\r\n  }),\r\n  loadWasmModuleToAllWorkers(onMaybeReady) {\r\n    // Instantiation is synchronous in pthreads.\r\n    if (ENVIRONMENT_IS_PTHREAD) {\r\n      return onMaybeReady();\r\n    }\r\n    let pthreadPoolReady = Promise.all(PThread.unusedWorkers.map(PThread.loadWasmModuleToWorker));\r\n    pthreadPoolReady.then(onMaybeReady);\r\n  },\r\n  allocateUnusedWorker() {\r\n    var worker;\r\n    // If we're using module output, use bundler-friendly pattern.\r\n    // We need to generate the URL with import.meta.url as the base URL of the JS file\r\n    // instead of just using new URL(import.meta.url) because bundler's only recognize\r\n    // the first case in their bundling step. The latter ends up producing an invalid\r\n    // URL to import from the server (e.g., for webpack the file:// path).\r\n    // See https://github.com/webpack/webpack/issues/12638\r\n    worker = new Worker(new URL(\"wasm_boids.js\", import.meta.url), {\r\n      \"type\": \"module\",\r\n      // This is the way that we signal to the node worker that it is hosting\r\n      // a pthread.\r\n      \"workerData\": \"em-pthread\",\r\n      // This is the way that we signal to the Web Worker that it is hosting\r\n      // a pthread.\r\n      \"name\": \"em-pthread-\" + PThread.nextWorkerID\r\n    });\r\n    worker.workerID = PThread.nextWorkerID++;\r\n    PThread.unusedWorkers.push(worker);\r\n  },\r\n  getNewWorker() {\r\n    if (PThread.unusedWorkers.length == 0) {\r\n      // PTHREAD_POOL_SIZE_STRICT should show a warning and, if set to level `2`, return from the function.\r\n      PThread.allocateUnusedWorker();\r\n      PThread.loadWasmModuleToWorker(PThread.unusedWorkers[0]);\r\n    }\r\n    return PThread.unusedWorkers.pop();\r\n  }\r\n};\r\n\r\nvar establishStackSpace = pthread_ptr => {\r\n  // If memory growth is enabled, the memory views may have gotten out of date,\r\n  // so resync them before accessing the pthread ptr below.\r\n  updateMemoryViews();\r\n  var stackHigh = GROWABLE_HEAP_U32()[(((pthread_ptr) + (52)) >> 2)];\r\n  var stackSize = GROWABLE_HEAP_U32()[(((pthread_ptr) + (56)) >> 2)];\r\n  var stackLow = stackHigh - stackSize;\r\n  assert(stackHigh != 0);\r\n  assert(stackLow != 0);\r\n  assert(stackHigh > stackLow, \"stackHigh must be higher then stackLow\");\r\n  // Set stack limits used by `emscripten/stack.h` function.  These limits are\r\n  // cached in wasm-side globals to make checks as fast as possible.\r\n  _emscripten_stack_set_limits(stackHigh, stackLow);\r\n  // Call inside wasm module to set up the stack frame for this pthread in wasm module scope\r\n  stackRestore(stackHigh);\r\n  // Write the stack cookie last, after we have set up the proper bounds and\r\n  // current position of the stack.\r\n  writeStackCookie();\r\n};\r\n\r\n/**\r\n     * @param {number} ptr\r\n     * @param {string} type\r\n     */ function getValue(ptr, type = \"i8\") {\r\n  if (type.endsWith(\"*\")) type = \"*\";\r\n  switch (type) {\r\n   case \"i1\":\r\n    return GROWABLE_HEAP_I8()[ptr];\r\n\r\n   case \"i8\":\r\n    return GROWABLE_HEAP_I8()[ptr];\r\n\r\n   case \"i16\":\r\n    return GROWABLE_HEAP_I16()[((ptr) >> 1)];\r\n\r\n   case \"i32\":\r\n    return GROWABLE_HEAP_I32()[((ptr) >> 2)];\r\n\r\n   case \"i64\":\r\n    return HEAP64[((ptr) >> 3)];\r\n\r\n   case \"float\":\r\n    return GROWABLE_HEAP_F32()[((ptr) >> 2)];\r\n\r\n   case \"double\":\r\n    return GROWABLE_HEAP_F64()[((ptr) >> 3)];\r\n\r\n   case \"*\":\r\n    return GROWABLE_HEAP_U32()[((ptr) >> 2)];\r\n\r\n   default:\r\n    abort(`invalid type for getValue: ${type}`);\r\n  }\r\n}\r\n\r\nvar wasmTableMirror = [];\r\n\r\n/** @type {WebAssembly.Table} */ var wasmTable;\r\n\r\nvar getWasmTableEntry = funcPtr => {\r\n  var func = wasmTableMirror[funcPtr];\r\n  if (!func) {\r\n    /** @suppress {checkTypes} */ wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);\r\n  }\r\n  /** @suppress {checkTypes} */ assert(wasmTable.get(funcPtr) == func, \"JavaScript-side Wasm function table mirror is out of date!\");\r\n  return func;\r\n};\r\n\r\nvar invokeEntryPoint = (ptr, arg) => {\r\n  // An old thread on this worker may have been canceled without returning the\r\n  // `runtimeKeepaliveCounter` to zero. Reset it now so the new thread won't\r\n  // be affected.\r\n  runtimeKeepaliveCounter = 0;\r\n  // pthread entry points are always of signature 'void *ThreadMain(void *arg)'\r\n  // Native codebases sometimes spawn threads with other thread entry point\r\n  // signatures, such as void ThreadMain(void *arg), void *ThreadMain(), or\r\n  // void ThreadMain().  That is not acceptable per C/C++ specification, but\r\n  // x86 compiler ABI extensions enable that to work. If you find the\r\n  // following line to crash, either change the signature to \"proper\" void\r\n  // *ThreadMain(void *arg) form, or try linking with the Emscripten linker\r\n  // flag -sEMULATE_FUNCTION_POINTER_CASTS to add in emulation for this x86\r\n  // ABI extension.\r\n  var result = getWasmTableEntry(ptr)(arg);\r\n  checkStackCookie();\r\n  function finish(result) {\r\n    if (keepRuntimeAlive()) {\r\n      EXITSTATUS = result;\r\n    } else {\r\n      __emscripten_thread_exit(result);\r\n    }\r\n  }\r\n  finish(result);\r\n};\r\n\r\nvar registerTLSInit = tlsInitFunc => PThread.tlsInitFunctions.push(tlsInitFunc);\r\n\r\nvar runtimeKeepalivePush = () => {\r\n  runtimeKeepaliveCounter += 1;\r\n};\r\n\r\n/**\r\n     * @param {number} ptr\r\n     * @param {number} value\r\n     * @param {string} type\r\n     */ function setValue(ptr, value, type = \"i8\") {\r\n  if (type.endsWith(\"*\")) type = \"*\";\r\n  switch (type) {\r\n   case \"i1\":\r\n    GROWABLE_HEAP_I8()[ptr] = value;\r\n    break;\r\n\r\n   case \"i8\":\r\n    GROWABLE_HEAP_I8()[ptr] = value;\r\n    break;\r\n\r\n   case \"i16\":\r\n    GROWABLE_HEAP_I16()[((ptr) >> 1)] = value;\r\n    break;\r\n\r\n   case \"i32\":\r\n    GROWABLE_HEAP_I32()[((ptr) >> 2)] = value;\r\n    break;\r\n\r\n   case \"i64\":\r\n    HEAP64[((ptr) >> 3)] = BigInt(value);\r\n    break;\r\n\r\n   case \"float\":\r\n    GROWABLE_HEAP_F32()[((ptr) >> 2)] = value;\r\n    break;\r\n\r\n   case \"double\":\r\n    GROWABLE_HEAP_F64()[((ptr) >> 3)] = value;\r\n    break;\r\n\r\n   case \"*\":\r\n    GROWABLE_HEAP_U32()[((ptr) >> 2)] = value;\r\n    break;\r\n\r\n   default:\r\n    abort(`invalid type for setValue: ${type}`);\r\n  }\r\n}\r\n\r\nvar warnOnce = text => {\r\n  warnOnce.shown ||= {};\r\n  if (!warnOnce.shown[text]) {\r\n    warnOnce.shown[text] = 1;\r\n    if (ENVIRONMENT_IS_NODE) text = \"warning: \" + text;\r\n    err(text);\r\n  }\r\n};\r\n\r\nvar UTF8Decoder = typeof TextDecoder != \"undefined\" ? new TextDecoder : undefined;\r\n\r\n/**\r\n     * Given a pointer 'idx' to a null-terminated UTF8-encoded string in the given\r\n     * array that contains uint8 values, returns a copy of that string as a\r\n     * Javascript String object.\r\n     * heapOrArray is either a regular array, or a JavaScript typed array view.\r\n     * @param {number=} idx\r\n     * @param {number=} maxBytesToRead\r\n     * @return {string}\r\n     */ var UTF8ArrayToString = (heapOrArray, idx = 0, maxBytesToRead = NaN) => {\r\n  var endIdx = idx + maxBytesToRead;\r\n  var endPtr = idx;\r\n  // TextDecoder needs to know the byte length in advance, it doesn't stop on\r\n  // null terminator by itself.  Also, use the length info to avoid running tiny\r\n  // strings through TextDecoder, since .subarray() allocates garbage.\r\n  // (As a tiny code save trick, compare endPtr against endIdx using a negation,\r\n  // so that undefined/NaN means Infinity)\r\n  while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;\r\n  if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {\r\n    return UTF8Decoder.decode(heapOrArray.buffer instanceof ArrayBuffer ? heapOrArray.subarray(idx, endPtr) : heapOrArray.slice(idx, endPtr));\r\n  }\r\n  var str = \"\";\r\n  // If building with TextDecoder, we have already computed the string length\r\n  // above, so test loop end condition against that\r\n  while (idx < endPtr) {\r\n    // For UTF8 byte structure, see:\r\n    // http://en.wikipedia.org/wiki/UTF-8#Description\r\n    // https://www.ietf.org/rfc/rfc2279.txt\r\n    // https://tools.ietf.org/html/rfc3629\r\n    var u0 = heapOrArray[idx++];\r\n    if (!(u0 & 128)) {\r\n      str += String.fromCharCode(u0);\r\n      continue;\r\n    }\r\n    var u1 = heapOrArray[idx++] & 63;\r\n    if ((u0 & 224) == 192) {\r\n      str += String.fromCharCode(((u0 & 31) << 6) | u1);\r\n      continue;\r\n    }\r\n    var u2 = heapOrArray[idx++] & 63;\r\n    if ((u0 & 240) == 224) {\r\n      u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;\r\n    } else {\r\n      if ((u0 & 248) != 240) warnOnce(\"Invalid UTF-8 leading byte \" + ptrToString(u0) + \" encountered when deserializing a UTF-8 string in wasm memory to a JS string!\");\r\n      u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heapOrArray[idx++] & 63);\r\n    }\r\n    if (u0 < 65536) {\r\n      str += String.fromCharCode(u0);\r\n    } else {\r\n      var ch = u0 - 65536;\r\n      str += String.fromCharCode(55296 | (ch >> 10), 56320 | (ch & 1023));\r\n    }\r\n  }\r\n  return str;\r\n};\r\n\r\n/**\r\n     * Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the\r\n     * emscripten HEAP, returns a copy of that string as a Javascript String object.\r\n     *\r\n     * @param {number} ptr\r\n     * @param {number=} maxBytesToRead - An optional length that specifies the\r\n     *   maximum number of bytes to read. You can omit this parameter to scan the\r\n     *   string until the first 0 byte. If maxBytesToRead is passed, and the string\r\n     *   at [ptr, ptr+maxBytesToReadr[ contains a null byte in the middle, then the\r\n     *   string will cut short at that byte index (i.e. maxBytesToRead will not\r\n     *   produce a string of exact length [ptr, ptr+maxBytesToRead[) N.B. mixing\r\n     *   frequent uses of UTF8ToString() with and without maxBytesToRead may throw\r\n     *   JS JIT optimizations off, so it is worth to consider consistently using one\r\n     * @return {string}\r\n     */ var UTF8ToString = (ptr, maxBytesToRead) => {\r\n  assert(typeof ptr == \"number\", `UTF8ToString expects a number (got ${typeof ptr})`);\r\n  return ptr ? UTF8ArrayToString(GROWABLE_HEAP_U8(), ptr, maxBytesToRead) : \"\";\r\n};\r\n\r\nvar ___assert_fail = (condition, filename, line, func) => abort(`Assertion failed: ${UTF8ToString(condition)}, at: ` + [ filename ? UTF8ToString(filename) : \"unknown filename\", line, func ? UTF8ToString(func) : \"unknown function\" ]);\r\n\r\nvar exceptionCaught = [];\r\n\r\nvar uncaughtExceptionCount = 0;\r\n\r\nvar ___cxa_begin_catch = ptr => {\r\n  var info = new ExceptionInfo(ptr);\r\n  if (!info.get_caught()) {\r\n    info.set_caught(true);\r\n    uncaughtExceptionCount--;\r\n  }\r\n  info.set_rethrown(false);\r\n  exceptionCaught.push(info);\r\n  ___cxa_increment_exception_refcount(ptr);\r\n  return ___cxa_get_exception_ptr(ptr);\r\n};\r\n\r\nvar exceptionLast = 0;\r\n\r\nclass ExceptionInfo {\r\n  // excPtr - Thrown object pointer to wrap. Metadata pointer is calculated from it.\r\n  constructor(excPtr) {\r\n    this.excPtr = excPtr;\r\n    this.ptr = excPtr - 24;\r\n  }\r\n  set_type(type) {\r\n    GROWABLE_HEAP_U32()[(((this.ptr) + (4)) >> 2)] = type;\r\n  }\r\n  get_type() {\r\n    return GROWABLE_HEAP_U32()[(((this.ptr) + (4)) >> 2)];\r\n  }\r\n  set_destructor(destructor) {\r\n    GROWABLE_HEAP_U32()[(((this.ptr) + (8)) >> 2)] = destructor;\r\n  }\r\n  get_destructor() {\r\n    return GROWABLE_HEAP_U32()[(((this.ptr) + (8)) >> 2)];\r\n  }\r\n  set_caught(caught) {\r\n    caught = caught ? 1 : 0;\r\n    GROWABLE_HEAP_I8()[(this.ptr) + (12)] = caught;\r\n  }\r\n  get_caught() {\r\n    return GROWABLE_HEAP_I8()[(this.ptr) + (12)] != 0;\r\n  }\r\n  set_rethrown(rethrown) {\r\n    rethrown = rethrown ? 1 : 0;\r\n    GROWABLE_HEAP_I8()[(this.ptr) + (13)] = rethrown;\r\n  }\r\n  get_rethrown() {\r\n    return GROWABLE_HEAP_I8()[(this.ptr) + (13)] != 0;\r\n  }\r\n  // Initialize native structure fields. Should be called once after allocated.\r\n  init(type, destructor) {\r\n    this.set_adjusted_ptr(0);\r\n    this.set_type(type);\r\n    this.set_destructor(destructor);\r\n  }\r\n  set_adjusted_ptr(adjustedPtr) {\r\n    GROWABLE_HEAP_U32()[(((this.ptr) + (16)) >> 2)] = adjustedPtr;\r\n  }\r\n  get_adjusted_ptr() {\r\n    return GROWABLE_HEAP_U32()[(((this.ptr) + (16)) >> 2)];\r\n  }\r\n}\r\n\r\nvar setTempRet0 = val => __emscripten_tempret_set(val);\r\n\r\nvar findMatchingCatch = args => {\r\n  var thrown = exceptionLast?.excPtr;\r\n  if (!thrown) {\r\n    // just pass through the null ptr\r\n    setTempRet0(0);\r\n    return 0;\r\n  }\r\n  var info = new ExceptionInfo(thrown);\r\n  info.set_adjusted_ptr(thrown);\r\n  var thrownType = info.get_type();\r\n  if (!thrownType) {\r\n    // just pass through the thrown ptr\r\n    setTempRet0(0);\r\n    return thrown;\r\n  }\r\n  // can_catch receives a **, add indirection\r\n  // The different catch blocks are denoted by different types.\r\n  // Due to inheritance, those types may not precisely match the\r\n  // type of the thrown object. Find one which matches, and\r\n  // return the type of the catch block which should be called.\r\n  for (var caughtType of args) {\r\n    if (caughtType === 0 || caughtType === thrownType) {\r\n      // Catch all clause matched or exactly the same type is caught\r\n      break;\r\n    }\r\n    var adjusted_ptr_addr = info.ptr + 16;\r\n    if (___cxa_can_catch(caughtType, thrownType, adjusted_ptr_addr)) {\r\n      setTempRet0(caughtType);\r\n      return thrown;\r\n    }\r\n  }\r\n  setTempRet0(thrownType);\r\n  return thrown;\r\n};\r\n\r\nvar ___cxa_find_matching_catch_2 = () => findMatchingCatch([]);\r\n\r\nvar ___cxa_find_matching_catch_3 = arg0 => findMatchingCatch([ arg0 ]);\r\n\r\nvar ___cxa_rethrow = () => {\r\n  var info = exceptionCaught.pop();\r\n  if (!info) {\r\n    abort(\"no exception to throw\");\r\n  }\r\n  var ptr = info.excPtr;\r\n  if (!info.get_rethrown()) {\r\n    // Only pop if the corresponding push was through rethrow_primary_exception\r\n    exceptionCaught.push(info);\r\n    info.set_rethrown(true);\r\n    info.set_caught(false);\r\n    uncaughtExceptionCount++;\r\n  }\r\n  exceptionLast = new CppException(ptr);\r\n  throw exceptionLast;\r\n};\r\n\r\nvar ___cxa_rethrow_primary_exception = ptr => {\r\n  if (!ptr) return;\r\n  var info = new ExceptionInfo(ptr);\r\n  exceptionCaught.push(info);\r\n  info.set_rethrown(true);\r\n  ___cxa_rethrow();\r\n};\r\n\r\nvar ___cxa_throw = (ptr, type, destructor) => {\r\n  var info = new ExceptionInfo(ptr);\r\n  // Initialize ExceptionInfo content after it was allocated in __cxa_allocate_exception.\r\n  info.init(type, destructor);\r\n  exceptionLast = new CppException(ptr);\r\n  uncaughtExceptionCount++;\r\n  throw exceptionLast;\r\n};\r\n\r\nfunction pthreadCreateProxied(pthread_ptr, attr, startRoutine, arg) {\r\n  if (ENVIRONMENT_IS_PTHREAD) return proxyToMainThread(2, 0, 1, pthread_ptr, attr, startRoutine, arg);\r\n  return ___pthread_create_js(pthread_ptr, attr, startRoutine, arg);\r\n}\r\n\r\nvar _emscripten_has_threading_support = () => typeof SharedArrayBuffer != \"undefined\";\r\n\r\nvar ___pthread_create_js = (pthread_ptr, attr, startRoutine, arg) => {\r\n  if (!_emscripten_has_threading_support()) {\r\n    dbg(\"pthread_create: environment does not support SharedArrayBuffer, pthreads are not available\");\r\n    return 6;\r\n  }\r\n  // List of JS objects that will transfer ownership to the Worker hosting the thread\r\n  var transferList = [];\r\n  var error = 0;\r\n  // Synchronously proxy the thread creation to main thread if possible. If we\r\n  // need to transfer ownership of objects, then proxy asynchronously via\r\n  // postMessage.\r\n  if (ENVIRONMENT_IS_PTHREAD && (transferList.length === 0 || error)) {\r\n    return pthreadCreateProxied(pthread_ptr, attr, startRoutine, arg);\r\n  }\r\n  // If on the main thread, and accessing Canvas/OffscreenCanvas failed, abort\r\n  // with the detected error.\r\n  if (error) return error;\r\n  var threadParams = {\r\n    startRoutine,\r\n    pthread_ptr,\r\n    arg,\r\n    transferList\r\n  };\r\n  if (ENVIRONMENT_IS_PTHREAD) {\r\n    // The prepopulated pool of web workers that can host pthreads is stored\r\n    // in the main JS thread. Therefore if a pthread is attempting to spawn a\r\n    // new thread, the thread creation must be deferred to the main JS thread.\r\n    threadParams.cmd = \"spawnThread\";\r\n    postMessage(threadParams, transferList);\r\n    // When we defer thread creation this way, we have no way to detect thread\r\n    // creation synchronously today, so we have to assume success and return 0.\r\n    return 0;\r\n  }\r\n  // We are the main thread, so we have the pthread warmup pool in this\r\n  // thread and can fire off JS thread creation directly ourselves.\r\n  return spawnThread(threadParams);\r\n};\r\n\r\nvar ___resumeException = ptr => {\r\n  if (!exceptionLast) {\r\n    exceptionLast = new CppException(ptr);\r\n  }\r\n  throw exceptionLast;\r\n};\r\n\r\nvar __abort_js = () => abort(\"native code called abort()\");\r\n\r\nvar structRegistrations = {};\r\n\r\nvar runDestructors = destructors => {\r\n  while (destructors.length) {\r\n    var ptr = destructors.pop();\r\n    var del = destructors.pop();\r\n    del(ptr);\r\n  }\r\n};\r\n\r\n/** @suppress {globalThis} */ function readPointer(pointer) {\r\n  return this[\"fromWireType\"](GROWABLE_HEAP_U32()[((pointer) >> 2)]);\r\n}\r\n\r\nvar awaitingDependencies = {};\r\n\r\nvar registeredTypes = {};\r\n\r\nvar typeDependencies = {};\r\n\r\nvar InternalError = Module[\"InternalError\"] = class InternalError extends Error {\r\n  constructor(message) {\r\n    super(message);\r\n    this.name = \"InternalError\";\r\n  }\r\n};\r\n\r\nvar throwInternalError = message => {\r\n  throw new InternalError(message);\r\n};\r\n\r\nvar whenDependentTypesAreResolved = (myTypes, dependentTypes, getTypeConverters) => {\r\n  myTypes.forEach(type => typeDependencies[type] = dependentTypes);\r\n  function onComplete(typeConverters) {\r\n    var myTypeConverters = getTypeConverters(typeConverters);\r\n    if (myTypeConverters.length !== myTypes.length) {\r\n      throwInternalError(\"Mismatched type converter count\");\r\n    }\r\n    for (var i = 0; i < myTypes.length; ++i) {\r\n      registerType(myTypes[i], myTypeConverters[i]);\r\n    }\r\n  }\r\n  var typeConverters = new Array(dependentTypes.length);\r\n  var unregisteredTypes = [];\r\n  var registered = 0;\r\n  dependentTypes.forEach((dt, i) => {\r\n    if (registeredTypes.hasOwnProperty(dt)) {\r\n      typeConverters[i] = registeredTypes[dt];\r\n    } else {\r\n      unregisteredTypes.push(dt);\r\n      if (!awaitingDependencies.hasOwnProperty(dt)) {\r\n        awaitingDependencies[dt] = [];\r\n      }\r\n      awaitingDependencies[dt].push(() => {\r\n        typeConverters[i] = registeredTypes[dt];\r\n        ++registered;\r\n        if (registered === unregisteredTypes.length) {\r\n          onComplete(typeConverters);\r\n        }\r\n      });\r\n    }\r\n  });\r\n  if (0 === unregisteredTypes.length) {\r\n    onComplete(typeConverters);\r\n  }\r\n};\r\n\r\nvar __embind_finalize_value_object = structType => {\r\n  var reg = structRegistrations[structType];\r\n  delete structRegistrations[structType];\r\n  var rawConstructor = reg.rawConstructor;\r\n  var rawDestructor = reg.rawDestructor;\r\n  var fieldRecords = reg.fields;\r\n  var fieldTypes = fieldRecords.map(field => field.getterReturnType).concat(fieldRecords.map(field => field.setterArgumentType));\r\n  whenDependentTypesAreResolved([ structType ], fieldTypes, fieldTypes => {\r\n    var fields = {};\r\n    fieldRecords.forEach((field, i) => {\r\n      var fieldName = field.fieldName;\r\n      var getterReturnType = fieldTypes[i];\r\n      var optional = fieldTypes[i].optional;\r\n      var getter = field.getter;\r\n      var getterContext = field.getterContext;\r\n      var setterArgumentType = fieldTypes[i + fieldRecords.length];\r\n      var setter = field.setter;\r\n      var setterContext = field.setterContext;\r\n      fields[fieldName] = {\r\n        read: ptr => getterReturnType[\"fromWireType\"](getter(getterContext, ptr)),\r\n        write: (ptr, o) => {\r\n          var destructors = [];\r\n          setter(setterContext, ptr, setterArgumentType[\"toWireType\"](destructors, o));\r\n          runDestructors(destructors);\r\n        },\r\n        optional\r\n      };\r\n    });\r\n    return [ {\r\n      name: reg.name,\r\n      \"fromWireType\": ptr => {\r\n        var rv = {};\r\n        for (var i in fields) {\r\n          rv[i] = fields[i].read(ptr);\r\n        }\r\n        rawDestructor(ptr);\r\n        return rv;\r\n      },\r\n      \"toWireType\": (destructors, o) => {\r\n        // todo: Here we have an opportunity for -O3 level \"unsafe\" optimizations:\r\n        // assume all fields are present without checking.\r\n        for (var fieldName in fields) {\r\n          if (!(fieldName in o) && !fields[fieldName].optional) {\r\n            throw new TypeError(`Missing field: \"${fieldName}\"`);\r\n          }\r\n        }\r\n        var ptr = rawConstructor();\r\n        for (fieldName in fields) {\r\n          fields[fieldName].write(ptr, o[fieldName]);\r\n        }\r\n        if (destructors !== null) {\r\n          destructors.push(rawDestructor, ptr);\r\n        }\r\n        return ptr;\r\n      },\r\n      argPackAdvance: GenericWireTypeSize,\r\n      \"readValueFromPointer\": readPointer,\r\n      destructorFunction: rawDestructor\r\n    } ];\r\n  });\r\n};\r\n\r\nvar embindRepr = v => {\r\n  if (v === null) {\r\n    return \"null\";\r\n  }\r\n  var t = typeof v;\r\n  if (t === \"object\" || t === \"array\" || t === \"function\") {\r\n    return v.toString();\r\n  } else {\r\n    return \"\" + v;\r\n  }\r\n};\r\n\r\nvar embind_init_charCodes = () => {\r\n  var codes = new Array(256);\r\n  for (var i = 0; i < 256; ++i) {\r\n    codes[i] = String.fromCharCode(i);\r\n  }\r\n  embind_charCodes = codes;\r\n};\r\n\r\nvar embind_charCodes;\r\n\r\nvar readLatin1String = ptr => {\r\n  var ret = \"\";\r\n  var c = ptr;\r\n  while (GROWABLE_HEAP_U8()[c]) {\r\n    ret += embind_charCodes[GROWABLE_HEAP_U8()[c++]];\r\n  }\r\n  return ret;\r\n};\r\n\r\nvar BindingError = Module[\"BindingError\"] = class BindingError extends Error {\r\n  constructor(message) {\r\n    super(message);\r\n    this.name = \"BindingError\";\r\n  }\r\n};\r\n\r\nvar throwBindingError = message => {\r\n  throw new BindingError(message);\r\n};\r\n\r\n/** @param {Object=} options */ function sharedRegisterType(rawType, registeredInstance, options = {}) {\r\n  var name = registeredInstance.name;\r\n  if (!rawType) {\r\n    throwBindingError(`type \"${name}\" must have a positive integer typeid pointer`);\r\n  }\r\n  if (registeredTypes.hasOwnProperty(rawType)) {\r\n    if (options.ignoreDuplicateRegistrations) {\r\n      return;\r\n    } else {\r\n      throwBindingError(`Cannot register type '${name}' twice`);\r\n    }\r\n  }\r\n  registeredTypes[rawType] = registeredInstance;\r\n  delete typeDependencies[rawType];\r\n  if (awaitingDependencies.hasOwnProperty(rawType)) {\r\n    var callbacks = awaitingDependencies[rawType];\r\n    delete awaitingDependencies[rawType];\r\n    callbacks.forEach(cb => cb());\r\n  }\r\n}\r\n\r\n/** @param {Object=} options */ function registerType(rawType, registeredInstance, options = {}) {\r\n  if (registeredInstance.argPackAdvance === undefined) {\r\n    throw new TypeError(\"registerType registeredInstance requires argPackAdvance\");\r\n  }\r\n  return sharedRegisterType(rawType, registeredInstance, options);\r\n}\r\n\r\nvar integerReadValueFromPointer = (name, width, signed) => {\r\n  // integers are quite common, so generate very specialized functions\r\n  switch (width) {\r\n   case 1:\r\n    return signed ? pointer => GROWABLE_HEAP_I8()[pointer] : pointer => GROWABLE_HEAP_U8()[pointer];\r\n\r\n   case 2:\r\n    return signed ? pointer => GROWABLE_HEAP_I16()[((pointer) >> 1)] : pointer => GROWABLE_HEAP_U16()[((pointer) >> 1)];\r\n\r\n   case 4:\r\n    return signed ? pointer => GROWABLE_HEAP_I32()[((pointer) >> 2)] : pointer => GROWABLE_HEAP_U32()[((pointer) >> 2)];\r\n\r\n   case 8:\r\n    return signed ? pointer => HEAP64[((pointer) >> 3)] : pointer => HEAPU64[((pointer) >> 3)];\r\n\r\n   default:\r\n    throw new TypeError(`invalid integer width (${width}): ${name}`);\r\n  }\r\n};\r\n\r\n/** @suppress {globalThis} */ var __embind_register_bigint = (primitiveType, name, size, minRange, maxRange) => {\r\n  name = readLatin1String(name);\r\n  var isUnsignedType = (name.indexOf(\"u\") != -1);\r\n  // maxRange comes through as -1 for uint64_t (see issue 13902). Work around that temporarily\r\n  if (isUnsignedType) {\r\n    maxRange = (1n << 64n) - 1n;\r\n  }\r\n  registerType(primitiveType, {\r\n    name,\r\n    \"fromWireType\": value => value,\r\n    \"toWireType\": function(destructors, value) {\r\n      if (typeof value != \"bigint\" && typeof value != \"number\") {\r\n        throw new TypeError(`Cannot convert \"${embindRepr(value)}\" to ${this.name}`);\r\n      }\r\n      if (typeof value == \"number\") {\r\n        value = BigInt(value);\r\n      }\r\n      if (value < minRange || value > maxRange) {\r\n        throw new TypeError(`Passing a number \"${embindRepr(value)}\" from JS side to C/C++ side to an argument of type \"${name}\", which is outside the valid range [${minRange}, ${maxRange}]!`);\r\n      }\r\n      return value;\r\n    },\r\n    argPackAdvance: GenericWireTypeSize,\r\n    \"readValueFromPointer\": integerReadValueFromPointer(name, size, !isUnsignedType),\r\n    destructorFunction: null\r\n  });\r\n};\r\n\r\nvar GenericWireTypeSize = 8;\r\n\r\n/** @suppress {globalThis} */ var __embind_register_bool = (rawType, name, trueValue, falseValue) => {\r\n  name = readLatin1String(name);\r\n  registerType(rawType, {\r\n    name,\r\n    \"fromWireType\": function(wt) {\r\n      // ambiguous emscripten ABI: sometimes return values are\r\n      // true or false, and sometimes integers (0 or 1)\r\n      return !!wt;\r\n    },\r\n    \"toWireType\": function(destructors, o) {\r\n      return o ? trueValue : falseValue;\r\n    },\r\n    argPackAdvance: GenericWireTypeSize,\r\n    \"readValueFromPointer\": function(pointer) {\r\n      return this[\"fromWireType\"](GROWABLE_HEAP_U8()[pointer]);\r\n    },\r\n    destructorFunction: null\r\n  });\r\n};\r\n\r\nvar shallowCopyInternalPointer = o => ({\r\n  count: o.count,\r\n  deleteScheduled: o.deleteScheduled,\r\n  preservePointerOnDelete: o.preservePointerOnDelete,\r\n  ptr: o.ptr,\r\n  ptrType: o.ptrType,\r\n  smartPtr: o.smartPtr,\r\n  smartPtrType: o.smartPtrType\r\n});\r\n\r\nvar throwInstanceAlreadyDeleted = obj => {\r\n  function getInstanceTypeName(handle) {\r\n    return handle.$$.ptrType.registeredClass.name;\r\n  }\r\n  throwBindingError(getInstanceTypeName(obj) + \" instance already deleted\");\r\n};\r\n\r\nvar finalizationRegistry = false;\r\n\r\nvar detachFinalizer = handle => {};\r\n\r\nvar runDestructor = $$ => {\r\n  if ($$.smartPtr) {\r\n    $$.smartPtrType.rawDestructor($$.smartPtr);\r\n  } else {\r\n    $$.ptrType.registeredClass.rawDestructor($$.ptr);\r\n  }\r\n};\r\n\r\nvar releaseClassHandle = $$ => {\r\n  $$.count.value -= 1;\r\n  var toDelete = 0 === $$.count.value;\r\n  if (toDelete) {\r\n    runDestructor($$);\r\n  }\r\n};\r\n\r\nvar downcastPointer = (ptr, ptrClass, desiredClass) => {\r\n  if (ptrClass === desiredClass) {\r\n    return ptr;\r\n  }\r\n  if (undefined === desiredClass.baseClass) {\r\n    return null;\r\n  }\r\n  var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);\r\n  if (rv === null) {\r\n    return null;\r\n  }\r\n  return desiredClass.downcast(rv);\r\n};\r\n\r\nvar registeredPointers = {};\r\n\r\nvar registeredInstances = {};\r\n\r\nvar getBasestPointer = (class_, ptr) => {\r\n  if (ptr === undefined) {\r\n    throwBindingError(\"ptr should not be undefined\");\r\n  }\r\n  while (class_.baseClass) {\r\n    ptr = class_.upcast(ptr);\r\n    class_ = class_.baseClass;\r\n  }\r\n  return ptr;\r\n};\r\n\r\nvar getInheritedInstance = (class_, ptr) => {\r\n  ptr = getBasestPointer(class_, ptr);\r\n  return registeredInstances[ptr];\r\n};\r\n\r\nvar makeClassHandle = (prototype, record) => {\r\n  if (!record.ptrType || !record.ptr) {\r\n    throwInternalError(\"makeClassHandle requires ptr and ptrType\");\r\n  }\r\n  var hasSmartPtrType = !!record.smartPtrType;\r\n  var hasSmartPtr = !!record.smartPtr;\r\n  if (hasSmartPtrType !== hasSmartPtr) {\r\n    throwInternalError(\"Both smartPtrType and smartPtr must be specified\");\r\n  }\r\n  record.count = {\r\n    value: 1\r\n  };\r\n  return attachFinalizer(Object.create(prototype, {\r\n    $$: {\r\n      value: record,\r\n      writable: true\r\n    }\r\n  }));\r\n};\r\n\r\n/** @suppress {globalThis} */ function RegisteredPointer_fromWireType(ptr) {\r\n  // ptr is a raw pointer (or a raw smartpointer)\r\n  // rawPointer is a maybe-null raw pointer\r\n  var rawPointer = this.getPointee(ptr);\r\n  if (!rawPointer) {\r\n    this.destructor(ptr);\r\n    return null;\r\n  }\r\n  var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);\r\n  if (undefined !== registeredInstance) {\r\n    // JS object has been neutered, time to repopulate it\r\n    if (0 === registeredInstance.$$.count.value) {\r\n      registeredInstance.$$.ptr = rawPointer;\r\n      registeredInstance.$$.smartPtr = ptr;\r\n      return registeredInstance[\"clone\"]();\r\n    } else {\r\n      // else, just increment reference count on existing object\r\n      // it already has a reference to the smart pointer\r\n      var rv = registeredInstance[\"clone\"]();\r\n      this.destructor(ptr);\r\n      return rv;\r\n    }\r\n  }\r\n  function makeDefaultHandle() {\r\n    if (this.isSmartPointer) {\r\n      return makeClassHandle(this.registeredClass.instancePrototype, {\r\n        ptrType: this.pointeeType,\r\n        ptr: rawPointer,\r\n        smartPtrType: this,\r\n        smartPtr: ptr\r\n      });\r\n    } else {\r\n      return makeClassHandle(this.registeredClass.instancePrototype, {\r\n        ptrType: this,\r\n        ptr\r\n      });\r\n    }\r\n  }\r\n  var actualType = this.registeredClass.getActualType(rawPointer);\r\n  var registeredPointerRecord = registeredPointers[actualType];\r\n  if (!registeredPointerRecord) {\r\n    return makeDefaultHandle.call(this);\r\n  }\r\n  var toType;\r\n  if (this.isConst) {\r\n    toType = registeredPointerRecord.constPointerType;\r\n  } else {\r\n    toType = registeredPointerRecord.pointerType;\r\n  }\r\n  var dp = downcastPointer(rawPointer, this.registeredClass, toType.registeredClass);\r\n  if (dp === null) {\r\n    return makeDefaultHandle.call(this);\r\n  }\r\n  if (this.isSmartPointer) {\r\n    return makeClassHandle(toType.registeredClass.instancePrototype, {\r\n      ptrType: toType,\r\n      ptr: dp,\r\n      smartPtrType: this,\r\n      smartPtr: ptr\r\n    });\r\n  } else {\r\n    return makeClassHandle(toType.registeredClass.instancePrototype, {\r\n      ptrType: toType,\r\n      ptr: dp\r\n    });\r\n  }\r\n}\r\n\r\nvar attachFinalizer = handle => {\r\n  if (\"undefined\" === typeof FinalizationRegistry) {\r\n    attachFinalizer = handle => handle;\r\n    return handle;\r\n  }\r\n  // If the running environment has a FinalizationRegistry (see\r\n  // https://github.com/tc39/proposal-weakrefs), then attach finalizers\r\n  // for class handles.  We check for the presence of FinalizationRegistry\r\n  // at run-time, not build-time.\r\n  finalizationRegistry = new FinalizationRegistry(info => {\r\n    console.warn(info.leakWarning);\r\n    releaseClassHandle(info.$$);\r\n  });\r\n  attachFinalizer = handle => {\r\n    var $$ = handle.$$;\r\n    var hasSmartPtr = !!$$.smartPtr;\r\n    if (hasSmartPtr) {\r\n      // We should not call the destructor on raw pointers in case other code expects the pointee to live\r\n      var info = {\r\n        $$\r\n      };\r\n      // Create a warning as an Error instance in advance so that we can store\r\n      // the current stacktrace and point to it when / if a leak is detected.\r\n      // This is more useful than the empty stacktrace of `FinalizationRegistry`\r\n      // callback.\r\n      var cls = $$.ptrType.registeredClass;\r\n      var err = new Error(`Embind found a leaked C++ instance ${cls.name} <${ptrToString($$.ptr)}>.\\n` + \"We'll free it automatically in this case, but this functionality is not reliable across various environments.\\n\" + \"Make sure to invoke .delete() manually once you're done with the instance instead.\\n\" + \"Originally allocated\");\r\n      // `.stack` will add \"at ...\" after this sentence\r\n      if (\"captureStackTrace\" in Error) {\r\n        Error.captureStackTrace(err, RegisteredPointer_fromWireType);\r\n      }\r\n      info.leakWarning = err.stack.replace(/^Error: /, \"\");\r\n      finalizationRegistry.register(handle, info, handle);\r\n    }\r\n    return handle;\r\n  };\r\n  detachFinalizer = handle => finalizationRegistry.unregister(handle);\r\n  return attachFinalizer(handle);\r\n};\r\n\r\nvar deletionQueue = [];\r\n\r\nvar flushPendingDeletes = () => {\r\n  while (deletionQueue.length) {\r\n    var obj = deletionQueue.pop();\r\n    obj.$$.deleteScheduled = false;\r\n    obj[\"delete\"]();\r\n  }\r\n};\r\n\r\nvar delayFunction;\r\n\r\nvar init_ClassHandle = () => {\r\n  let proto = ClassHandle.prototype;\r\n  Object.assign(proto, {\r\n    \"isAliasOf\"(other) {\r\n      if (!(this instanceof ClassHandle)) {\r\n        return false;\r\n      }\r\n      if (!(other instanceof ClassHandle)) {\r\n        return false;\r\n      }\r\n      var leftClass = this.$$.ptrType.registeredClass;\r\n      var left = this.$$.ptr;\r\n      other.$$ = /** @type {Object} */ (other.$$);\r\n      var rightClass = other.$$.ptrType.registeredClass;\r\n      var right = other.$$.ptr;\r\n      while (leftClass.baseClass) {\r\n        left = leftClass.upcast(left);\r\n        leftClass = leftClass.baseClass;\r\n      }\r\n      while (rightClass.baseClass) {\r\n        right = rightClass.upcast(right);\r\n        rightClass = rightClass.baseClass;\r\n      }\r\n      return leftClass === rightClass && left === right;\r\n    },\r\n    \"clone\"() {\r\n      if (!this.$$.ptr) {\r\n        throwInstanceAlreadyDeleted(this);\r\n      }\r\n      if (this.$$.preservePointerOnDelete) {\r\n        this.$$.count.value += 1;\r\n        return this;\r\n      } else {\r\n        var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), {\r\n          $$: {\r\n            value: shallowCopyInternalPointer(this.$$)\r\n          }\r\n        }));\r\n        clone.$$.count.value += 1;\r\n        clone.$$.deleteScheduled = false;\r\n        return clone;\r\n      }\r\n    },\r\n    \"delete\"() {\r\n      if (!this.$$.ptr) {\r\n        throwInstanceAlreadyDeleted(this);\r\n      }\r\n      if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\r\n        throwBindingError(\"Object already scheduled for deletion\");\r\n      }\r\n      detachFinalizer(this);\r\n      releaseClassHandle(this.$$);\r\n      if (!this.$$.preservePointerOnDelete) {\r\n        this.$$.smartPtr = undefined;\r\n        this.$$.ptr = undefined;\r\n      }\r\n    },\r\n    \"isDeleted\"() {\r\n      return !this.$$.ptr;\r\n    },\r\n    \"deleteLater\"() {\r\n      if (!this.$$.ptr) {\r\n        throwInstanceAlreadyDeleted(this);\r\n      }\r\n      if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\r\n        throwBindingError(\"Object already scheduled for deletion\");\r\n      }\r\n      deletionQueue.push(this);\r\n      if (deletionQueue.length === 1 && delayFunction) {\r\n        delayFunction(flushPendingDeletes);\r\n      }\r\n      this.$$.deleteScheduled = true;\r\n      return this;\r\n    }\r\n  });\r\n  // Support `using ...` from https://github.com/tc39/proposal-explicit-resource-management.\r\n  const symbolDispose = Symbol.dispose;\r\n  if (symbolDispose) {\r\n    proto[symbolDispose] = proto[\"delete\"];\r\n  }\r\n};\r\n\r\n/** @constructor */ function ClassHandle() {}\r\n\r\nvar createNamedFunction = (name, func) => Object.defineProperty(func, \"name\", {\r\n  value: name\r\n});\r\n\r\nvar ensureOverloadTable = (proto, methodName, humanName) => {\r\n  if (undefined === proto[methodName].overloadTable) {\r\n    var prevFunc = proto[methodName];\r\n    // Inject an overload resolver function that routes to the appropriate overload based on the number of arguments.\r\n    proto[methodName] = function(...args) {\r\n      // TODO This check can be removed in -O3 level \"unsafe\" optimizations.\r\n      if (!proto[methodName].overloadTable.hasOwnProperty(args.length)) {\r\n        throwBindingError(`Function '${humanName}' called with an invalid number of arguments (${args.length}) - expects one of (${proto[methodName].overloadTable})!`);\r\n      }\r\n      return proto[methodName].overloadTable[args.length].apply(this, args);\r\n    };\r\n    // Move the previous function into the overload table.\r\n    proto[methodName].overloadTable = [];\r\n    proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;\r\n  }\r\n};\r\n\r\n/** @param {number=} numArguments */ var exposePublicSymbol = (name, value, numArguments) => {\r\n  if (Module.hasOwnProperty(name)) {\r\n    if (undefined === numArguments || (undefined !== Module[name].overloadTable && undefined !== Module[name].overloadTable[numArguments])) {\r\n      throwBindingError(`Cannot register public name '${name}' twice`);\r\n    }\r\n    // We are exposing a function with the same name as an existing function. Create an overload table and a function selector\r\n    // that routes between the two.\r\n    ensureOverloadTable(Module, name, name);\r\n    if (Module[name].overloadTable.hasOwnProperty(numArguments)) {\r\n      throwBindingError(`Cannot register multiple overloads of a function with the same number of arguments (${numArguments})!`);\r\n    }\r\n    // Add the new function into the overload table.\r\n    Module[name].overloadTable[numArguments] = value;\r\n  } else {\r\n    Module[name] = value;\r\n    Module[name].argCount = numArguments;\r\n  }\r\n};\r\n\r\nvar char_0 = 48;\r\n\r\nvar char_9 = 57;\r\n\r\nvar makeLegalFunctionName = name => {\r\n  assert(typeof name === \"string\");\r\n  name = name.replace(/[^a-zA-Z0-9_]/g, \"$\");\r\n  var f = name.charCodeAt(0);\r\n  if (f >= char_0 && f <= char_9) {\r\n    return `_${name}`;\r\n  }\r\n  return name;\r\n};\r\n\r\n/** @constructor */ function RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast) {\r\n  this.name = name;\r\n  this.constructor = constructor;\r\n  this.instancePrototype = instancePrototype;\r\n  this.rawDestructor = rawDestructor;\r\n  this.baseClass = baseClass;\r\n  this.getActualType = getActualType;\r\n  this.upcast = upcast;\r\n  this.downcast = downcast;\r\n  this.pureVirtualFunctions = [];\r\n}\r\n\r\nvar upcastPointer = (ptr, ptrClass, desiredClass) => {\r\n  while (ptrClass !== desiredClass) {\r\n    if (!ptrClass.upcast) {\r\n      throwBindingError(`Expected null or instance of ${desiredClass.name}, got an instance of ${ptrClass.name}`);\r\n    }\r\n    ptr = ptrClass.upcast(ptr);\r\n    ptrClass = ptrClass.baseClass;\r\n  }\r\n  return ptr;\r\n};\r\n\r\n/** @suppress {globalThis} */ function constNoSmartPtrRawPointerToWireType(destructors, handle) {\r\n  if (handle === null) {\r\n    if (this.isReference) {\r\n      throwBindingError(`null is not a valid ${this.name}`);\r\n    }\r\n    return 0;\r\n  }\r\n  if (!handle.$$) {\r\n    throwBindingError(`Cannot pass \"${embindRepr(handle)}\" as a ${this.name}`);\r\n  }\r\n  if (!handle.$$.ptr) {\r\n    throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);\r\n  }\r\n  var handleClass = handle.$$.ptrType.registeredClass;\r\n  var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\r\n  return ptr;\r\n}\r\n\r\n/** @suppress {globalThis} */ function genericPointerToWireType(destructors, handle) {\r\n  var ptr;\r\n  if (handle === null) {\r\n    if (this.isReference) {\r\n      throwBindingError(`null is not a valid ${this.name}`);\r\n    }\r\n    if (this.isSmartPointer) {\r\n      ptr = this.rawConstructor();\r\n      if (destructors !== null) {\r\n        destructors.push(this.rawDestructor, ptr);\r\n      }\r\n      return ptr;\r\n    } else {\r\n      return 0;\r\n    }\r\n  }\r\n  if (!handle || !handle.$$) {\r\n    throwBindingError(`Cannot pass \"${embindRepr(handle)}\" as a ${this.name}`);\r\n  }\r\n  if (!handle.$$.ptr) {\r\n    throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);\r\n  }\r\n  if (!this.isConst && handle.$$.ptrType.isConst) {\r\n    throwBindingError(`Cannot convert argument of type ${(handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name)} to parameter type ${this.name}`);\r\n  }\r\n  var handleClass = handle.$$.ptrType.registeredClass;\r\n  ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\r\n  if (this.isSmartPointer) {\r\n    // TODO: this is not strictly true\r\n    // We could support BY_EMVAL conversions from raw pointers to smart pointers\r\n    // because the smart pointer can hold a reference to the handle\r\n    if (undefined === handle.$$.smartPtr) {\r\n      throwBindingError(\"Passing raw pointer to smart pointer is illegal\");\r\n    }\r\n    switch (this.sharingPolicy) {\r\n     case 0:\r\n      // NONE\r\n      // no upcasting\r\n      if (handle.$$.smartPtrType === this) {\r\n        ptr = handle.$$.smartPtr;\r\n      } else {\r\n        throwBindingError(`Cannot convert argument of type ${(handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name)} to parameter type ${this.name}`);\r\n      }\r\n      break;\r\n\r\n     case 1:\r\n      // INTRUSIVE\r\n      ptr = handle.$$.smartPtr;\r\n      break;\r\n\r\n     case 2:\r\n      // BY_EMVAL\r\n      if (handle.$$.smartPtrType === this) {\r\n        ptr = handle.$$.smartPtr;\r\n      } else {\r\n        var clonedHandle = handle[\"clone\"]();\r\n        ptr = this.rawShare(ptr, Emval.toHandle(() => clonedHandle[\"delete\"]()));\r\n        if (destructors !== null) {\r\n          destructors.push(this.rawDestructor, ptr);\r\n        }\r\n      }\r\n      break;\r\n\r\n     default:\r\n      throwBindingError(\"Unsupporting sharing policy\");\r\n    }\r\n  }\r\n  return ptr;\r\n}\r\n\r\n/** @suppress {globalThis} */ function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {\r\n  if (handle === null) {\r\n    if (this.isReference) {\r\n      throwBindingError(`null is not a valid ${this.name}`);\r\n    }\r\n    return 0;\r\n  }\r\n  if (!handle.$$) {\r\n    throwBindingError(`Cannot pass \"${embindRepr(handle)}\" as a ${this.name}`);\r\n  }\r\n  if (!handle.$$.ptr) {\r\n    throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);\r\n  }\r\n  if (handle.$$.ptrType.isConst) {\r\n    throwBindingError(`Cannot convert argument of type ${handle.$$.ptrType.name} to parameter type ${this.name}`);\r\n  }\r\n  var handleClass = handle.$$.ptrType.registeredClass;\r\n  var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\r\n  return ptr;\r\n}\r\n\r\nvar init_RegisteredPointer = () => {\r\n  Object.assign(RegisteredPointer.prototype, {\r\n    getPointee(ptr) {\r\n      if (this.rawGetPointee) {\r\n        ptr = this.rawGetPointee(ptr);\r\n      }\r\n      return ptr;\r\n    },\r\n    destructor(ptr) {\r\n      this.rawDestructor?.(ptr);\r\n    },\r\n    argPackAdvance: GenericWireTypeSize,\r\n    \"readValueFromPointer\": readPointer,\r\n    \"fromWireType\": RegisteredPointer_fromWireType\r\n  });\r\n};\r\n\r\n/** @constructor\r\n      @param {*=} pointeeType,\r\n      @param {*=} sharingPolicy,\r\n      @param {*=} rawGetPointee,\r\n      @param {*=} rawConstructor,\r\n      @param {*=} rawShare,\r\n      @param {*=} rawDestructor,\r\n       */ function RegisteredPointer(name, registeredClass, isReference, isConst, // smart pointer properties\r\nisSmartPointer, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor) {\r\n  this.name = name;\r\n  this.registeredClass = registeredClass;\r\n  this.isReference = isReference;\r\n  this.isConst = isConst;\r\n  // smart pointer properties\r\n  this.isSmartPointer = isSmartPointer;\r\n  this.pointeeType = pointeeType;\r\n  this.sharingPolicy = sharingPolicy;\r\n  this.rawGetPointee = rawGetPointee;\r\n  this.rawConstructor = rawConstructor;\r\n  this.rawShare = rawShare;\r\n  this.rawDestructor = rawDestructor;\r\n  if (!isSmartPointer && registeredClass.baseClass === undefined) {\r\n    if (isConst) {\r\n      this[\"toWireType\"] = constNoSmartPtrRawPointerToWireType;\r\n      this.destructorFunction = null;\r\n    } else {\r\n      this[\"toWireType\"] = nonConstNoSmartPtrRawPointerToWireType;\r\n      this.destructorFunction = null;\r\n    }\r\n  } else {\r\n    this[\"toWireType\"] = genericPointerToWireType;\r\n  }\r\n}\r\n\r\n/** @param {number=} numArguments */ var replacePublicSymbol = (name, value, numArguments) => {\r\n  if (!Module.hasOwnProperty(name)) {\r\n    throwInternalError(\"Replacing nonexistent public symbol\");\r\n  }\r\n  // If there's an overload table for this symbol, replace the symbol in the overload table instead.\r\n  if (undefined !== Module[name].overloadTable && undefined !== numArguments) {\r\n    Module[name].overloadTable[numArguments] = value;\r\n  } else {\r\n    Module[name] = value;\r\n    Module[name].argCount = numArguments;\r\n  }\r\n};\r\n\r\nvar embind__requireFunction = (signature, rawFunction, isAsync = false) => {\r\n  assert(!isAsync, \"Async bindings are only supported with JSPI.\");\r\n  signature = readLatin1String(signature);\r\n  function makeDynCaller() {\r\n    var rtn = getWasmTableEntry(rawFunction);\r\n    return rtn;\r\n  }\r\n  var fp = makeDynCaller();\r\n  if (typeof fp != \"function\") {\r\n    throwBindingError(`unknown function pointer with signature ${signature}: ${rawFunction}`);\r\n  }\r\n  return fp;\r\n};\r\n\r\nclass UnboundTypeError extends Error {}\r\n\r\nvar getTypeName = type => {\r\n  var ptr = ___getTypeName(type);\r\n  var rv = readLatin1String(ptr);\r\n  _free(ptr);\r\n  return rv;\r\n};\r\n\r\nvar throwUnboundTypeError = (message, types) => {\r\n  var unboundTypes = [];\r\n  var seen = {};\r\n  function visit(type) {\r\n    if (seen[type]) {\r\n      return;\r\n    }\r\n    if (registeredTypes[type]) {\r\n      return;\r\n    }\r\n    if (typeDependencies[type]) {\r\n      typeDependencies[type].forEach(visit);\r\n      return;\r\n    }\r\n    unboundTypes.push(type);\r\n    seen[type] = true;\r\n  }\r\n  types.forEach(visit);\r\n  throw new UnboundTypeError(`${message}: ` + unboundTypes.map(getTypeName).join([ \", \" ]));\r\n};\r\n\r\nvar __embind_register_class = (rawType, rawPointerType, rawConstPointerType, baseClassRawType, getActualTypeSignature, getActualType, upcastSignature, upcast, downcastSignature, downcast, name, destructorSignature, rawDestructor) => {\r\n  name = readLatin1String(name);\r\n  getActualType = embind__requireFunction(getActualTypeSignature, getActualType);\r\n  upcast &&= embind__requireFunction(upcastSignature, upcast);\r\n  downcast &&= embind__requireFunction(downcastSignature, downcast);\r\n  rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);\r\n  var legalFunctionName = makeLegalFunctionName(name);\r\n  exposePublicSymbol(legalFunctionName, function() {\r\n    // this code cannot run if baseClassRawType is zero\r\n    throwUnboundTypeError(`Cannot construct ${name} due to unbound types`, [ baseClassRawType ]);\r\n  });\r\n  whenDependentTypesAreResolved([ rawType, rawPointerType, rawConstPointerType ], baseClassRawType ? [ baseClassRawType ] : [], base => {\r\n    base = base[0];\r\n    var baseClass;\r\n    var basePrototype;\r\n    if (baseClassRawType) {\r\n      baseClass = base.registeredClass;\r\n      basePrototype = baseClass.instancePrototype;\r\n    } else {\r\n      basePrototype = ClassHandle.prototype;\r\n    }\r\n    var constructor = createNamedFunction(name, function(...args) {\r\n      if (Object.getPrototypeOf(this) !== instancePrototype) {\r\n        throw new BindingError(`Use 'new' to construct ${name}`);\r\n      }\r\n      if (undefined === registeredClass.constructor_body) {\r\n        throw new BindingError(`${name} has no accessible constructor`);\r\n      }\r\n      var body = registeredClass.constructor_body[args.length];\r\n      if (undefined === body) {\r\n        throw new BindingError(`Tried to invoke ctor of ${name} with invalid number of parameters (${args.length}) - expected (${Object.keys(registeredClass.constructor_body).toString()}) parameters instead!`);\r\n      }\r\n      return body.apply(this, args);\r\n    });\r\n    var instancePrototype = Object.create(basePrototype, {\r\n      constructor: {\r\n        value: constructor\r\n      }\r\n    });\r\n    constructor.prototype = instancePrototype;\r\n    var registeredClass = new RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast);\r\n    if (registeredClass.baseClass) {\r\n      // Keep track of class hierarchy. Used to allow sub-classes to inherit class functions.\r\n      registeredClass.baseClass.__derivedClasses ??= [];\r\n      registeredClass.baseClass.__derivedClasses.push(registeredClass);\r\n    }\r\n    var referenceConverter = new RegisteredPointer(name, registeredClass, true, false, false);\r\n    var pointerConverter = new RegisteredPointer(name + \"*\", registeredClass, false, false, false);\r\n    var constPointerConverter = new RegisteredPointer(name + \" const*\", registeredClass, false, true, false);\r\n    registeredPointers[rawType] = {\r\n      pointerType: pointerConverter,\r\n      constPointerType: constPointerConverter\r\n    };\r\n    replacePublicSymbol(legalFunctionName, constructor);\r\n    return [ referenceConverter, pointerConverter, constPointerConverter ];\r\n  });\r\n};\r\n\r\nvar heap32VectorToArray = (count, firstElement) => {\r\n  var array = [];\r\n  for (var i = 0; i < count; i++) {\r\n    // TODO(https://github.com/emscripten-core/emscripten/issues/17310):\r\n    // Find a way to hoist the `>> 2` or `>> 3` out of this loop.\r\n    array.push(GROWABLE_HEAP_U32()[(((firstElement) + (i * 4)) >> 2)]);\r\n  }\r\n  return array;\r\n};\r\n\r\nfunction usesDestructorStack(argTypes) {\r\n  // Skip return value at index 0 - it's not deleted here.\r\n  for (var i = 1; i < argTypes.length; ++i) {\r\n    // The type does not define a destructor function - must use dynamic stack\r\n    if (argTypes[i] !== null && argTypes[i].destructorFunction === undefined) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nfunction checkArgCount(numArgs, minArgs, maxArgs, humanName, throwBindingError) {\r\n  if (numArgs < minArgs || numArgs > maxArgs) {\r\n    var argCountMessage = minArgs == maxArgs ? minArgs : `${minArgs} to ${maxArgs}`;\r\n    throwBindingError(`function ${humanName} called with ${numArgs} arguments, expected ${argCountMessage}`);\r\n  }\r\n}\r\n\r\nfunction createJsInvoker(argTypes, isClassMethodFunc, returns, isAsync) {\r\n  var needsDestructorStack = usesDestructorStack(argTypes);\r\n  var argCount = argTypes.length - 2;\r\n  var argsList = [];\r\n  var argsListWired = [ \"fn\" ];\r\n  if (isClassMethodFunc) {\r\n    argsListWired.push(\"thisWired\");\r\n  }\r\n  for (var i = 0; i < argCount; ++i) {\r\n    argsList.push(`arg${i}`);\r\n    argsListWired.push(`arg${i}Wired`);\r\n  }\r\n  argsList = argsList.join(\",\");\r\n  argsListWired = argsListWired.join(\",\");\r\n  var invokerFnBody = `return function (${argsList}) {\\n`;\r\n  invokerFnBody += \"checkArgCount(arguments.length, minArgs, maxArgs, humanName, throwBindingError);\\n\";\r\n  if (needsDestructorStack) {\r\n    invokerFnBody += \"var destructors = [];\\n\";\r\n  }\r\n  var dtorStack = needsDestructorStack ? \"destructors\" : \"null\";\r\n  var args1 = [ \"humanName\", \"throwBindingError\", \"invoker\", \"fn\", \"runDestructors\", \"retType\", \"classParam\" ];\r\n  if (isClassMethodFunc) {\r\n    invokerFnBody += `var thisWired = classParam['toWireType'](${dtorStack}, this);\\n`;\r\n  }\r\n  for (var i = 0; i < argCount; ++i) {\r\n    invokerFnBody += `var arg${i}Wired = argType${i}['toWireType'](${dtorStack}, arg${i});\\n`;\r\n    args1.push(`argType${i}`);\r\n  }\r\n  invokerFnBody += (returns || isAsync ? \"var rv = \" : \"\") + `invoker(${argsListWired});\\n`;\r\n  var returnVal = returns ? \"rv\" : \"\";\r\n  if (needsDestructorStack) {\r\n    invokerFnBody += \"runDestructors(destructors);\\n\";\r\n  } else {\r\n    for (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i) {\r\n      // Skip return value at index 0 - it's not deleted here. Also skip class type if not a method.\r\n      var paramName = (i === 1 ? \"thisWired\" : (\"arg\" + (i - 2) + \"Wired\"));\r\n      if (argTypes[i].destructorFunction !== null) {\r\n        invokerFnBody += `${paramName}_dtor(${paramName});\\n`;\r\n        args1.push(`${paramName}_dtor`);\r\n      }\r\n    }\r\n  }\r\n  if (returns) {\r\n    invokerFnBody += \"var ret = retType['fromWireType'](rv);\\n\" + \"return ret;\\n\";\r\n  } else {}\r\n  invokerFnBody += \"}\\n\";\r\n  args1.push(\"checkArgCount\", \"minArgs\", \"maxArgs\");\r\n  invokerFnBody = `if (arguments.length !== ${args1.length}){ throw new Error(humanName + \"Expected ${args1.length} closure arguments \" + arguments.length + \" given.\"); }\\n${invokerFnBody}`;\r\n  return [ args1, invokerFnBody ];\r\n}\r\n\r\nfunction getRequiredArgCount(argTypes) {\r\n  var requiredArgCount = argTypes.length - 2;\r\n  for (var i = argTypes.length - 1; i >= 2; --i) {\r\n    if (!argTypes[i].optional) {\r\n      break;\r\n    }\r\n    requiredArgCount--;\r\n  }\r\n  return requiredArgCount;\r\n}\r\n\r\nfunction craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc, /** boolean= */ isAsync) {\r\n  // humanName: a human-readable string name for the function to be generated.\r\n  // argTypes: An array that contains the embind type objects for all types in the function signature.\r\n  //    argTypes[0] is the type object for the function return value.\r\n  //    argTypes[1] is the type object for function this object/class type, or null if not crafting an invoker for a class method.\r\n  //    argTypes[2...] are the actual function parameters.\r\n  // classType: The embind type object for the class to be bound, or null if this is not a method of a class.\r\n  // cppInvokerFunc: JS Function object to the C++-side function that interops into C++ code.\r\n  // cppTargetFunc: Function pointer (an integer to FUNCTION_TABLE) to the target C++ function the cppInvokerFunc will end up calling.\r\n  // isAsync: Optional. If true, returns an async function. Async bindings are only supported with JSPI.\r\n  var argCount = argTypes.length;\r\n  if (argCount < 2) {\r\n    throwBindingError(\"argTypes array size mismatch! Must at least get return value and 'this' types!\");\r\n  }\r\n  assert(!isAsync, \"Async bindings are only supported with JSPI.\");\r\n  var isClassMethodFunc = (argTypes[1] !== null && classType !== null);\r\n  // Free functions with signature \"void function()\" do not need an invoker that marshalls between wire types.\r\n  // TODO: This omits argument count check - enable only at -O3 or similar.\r\n  //    if (ENABLE_UNSAFE_OPTS && argCount == 2 && argTypes[0].name == \"void\" && !isClassMethodFunc) {\r\n  //       return FUNCTION_TABLE[fn];\r\n  //    }\r\n  // Determine if we need to use a dynamic stack to store the destructors for the function parameters.\r\n  // TODO: Remove this completely once all function invokers are being dynamically generated.\r\n  var needsDestructorStack = usesDestructorStack(argTypes);\r\n  var returns = (argTypes[0].name !== \"void\");\r\n  var expectedArgCount = argCount - 2;\r\n  var minArgs = getRequiredArgCount(argTypes);\r\n  // Builld the arguments that will be passed into the closure around the invoker\r\n  // function.\r\n  var closureArgs = [ humanName, throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1] ];\r\n  for (var i = 0; i < argCount - 2; ++i) {\r\n    closureArgs.push(argTypes[i + 2]);\r\n  }\r\n  if (!needsDestructorStack) {\r\n    // Skip return value at index 0 - it's not deleted here. Also skip class type if not a method.\r\n    for (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i) {\r\n      if (argTypes[i].destructorFunction !== null) {\r\n        closureArgs.push(argTypes[i].destructorFunction);\r\n      }\r\n    }\r\n  }\r\n  closureArgs.push(checkArgCount, minArgs, expectedArgCount);\r\n  let [args, invokerFnBody] = createJsInvoker(argTypes, isClassMethodFunc, returns, isAsync);\r\n  var invokerFn = new Function(...args, invokerFnBody)(...closureArgs);\r\n  return createNamedFunction(humanName, invokerFn);\r\n}\r\n\r\nvar __embind_register_class_constructor = (rawClassType, argCount, rawArgTypesAddr, invokerSignature, invoker, rawConstructor) => {\r\n  assert(argCount > 0);\r\n  var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\r\n  invoker = embind__requireFunction(invokerSignature, invoker);\r\n  var args = [ rawConstructor ];\r\n  var destructors = [];\r\n  whenDependentTypesAreResolved([], [ rawClassType ], classType => {\r\n    classType = classType[0];\r\n    var humanName = `constructor ${classType.name}`;\r\n    if (undefined === classType.registeredClass.constructor_body) {\r\n      classType.registeredClass.constructor_body = [];\r\n    }\r\n    if (undefined !== classType.registeredClass.constructor_body[argCount - 1]) {\r\n      throw new BindingError(`Cannot register multiple constructors with identical number of parameters (${argCount - 1}) for class '${classType.name}'! Overload resolution is currently only performed using the parameter count, not actual type info!`);\r\n    }\r\n    classType.registeredClass.constructor_body[argCount - 1] = () => {\r\n      throwUnboundTypeError(`Cannot construct ${classType.name} due to unbound types`, rawArgTypes);\r\n    };\r\n    whenDependentTypesAreResolved([], rawArgTypes, argTypes => {\r\n      // Insert empty slot for context type (argTypes[1]).\r\n      argTypes.splice(1, 0, null);\r\n      classType.registeredClass.constructor_body[argCount - 1] = craftInvokerFunction(humanName, argTypes, null, invoker, rawConstructor);\r\n      return [];\r\n    });\r\n    return [];\r\n  });\r\n};\r\n\r\nvar getFunctionName = signature => {\r\n  signature = signature.trim();\r\n  const argsIndex = signature.indexOf(\"(\");\r\n  if (argsIndex === -1) return signature;\r\n  assert(signature.endsWith(\")\"), \"Parentheses for argument names should match.\");\r\n  return signature.slice(0, argsIndex);\r\n};\r\n\r\nvar __embind_register_class_function = (rawClassType, methodName, argCount, rawArgTypesAddr, // [ReturnType, ThisType, Args...]\r\ninvokerSignature, rawInvoker, context, isPureVirtual, isAsync, isNonnullReturn) => {\r\n  var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\r\n  methodName = readLatin1String(methodName);\r\n  methodName = getFunctionName(methodName);\r\n  rawInvoker = embind__requireFunction(invokerSignature, rawInvoker, isAsync);\r\n  whenDependentTypesAreResolved([], [ rawClassType ], classType => {\r\n    classType = classType[0];\r\n    var humanName = `${classType.name}.${methodName}`;\r\n    if (methodName.startsWith(\"@@\")) {\r\n      methodName = Symbol[methodName.substring(2)];\r\n    }\r\n    if (isPureVirtual) {\r\n      classType.registeredClass.pureVirtualFunctions.push(methodName);\r\n    }\r\n    function unboundTypesHandler() {\r\n      throwUnboundTypeError(`Cannot call ${humanName} due to unbound types`, rawArgTypes);\r\n    }\r\n    var proto = classType.registeredClass.instancePrototype;\r\n    var method = proto[methodName];\r\n    if (undefined === method || (undefined === method.overloadTable && method.className !== classType.name && method.argCount === argCount - 2)) {\r\n      // This is the first overload to be registered, OR we are replacing a\r\n      // function in the base class with a function in the derived class.\r\n      unboundTypesHandler.argCount = argCount - 2;\r\n      unboundTypesHandler.className = classType.name;\r\n      proto[methodName] = unboundTypesHandler;\r\n    } else {\r\n      // There was an existing function with the same name registered. Set up\r\n      // a function overload routing table.\r\n      ensureOverloadTable(proto, methodName, humanName);\r\n      proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;\r\n    }\r\n    whenDependentTypesAreResolved([], rawArgTypes, argTypes => {\r\n      var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context, isAsync);\r\n      // Replace the initial unbound-handler-stub function with the\r\n      // appropriate member function, now that all types are resolved. If\r\n      // multiple overloads are registered for this function, the function\r\n      // goes into an overload table.\r\n      if (undefined === proto[methodName].overloadTable) {\r\n        // Set argCount in case an overload is registered later\r\n        memberFunction.argCount = argCount - 2;\r\n        proto[methodName] = memberFunction;\r\n      } else {\r\n        proto[methodName].overloadTable[argCount - 2] = memberFunction;\r\n      }\r\n      return [];\r\n    });\r\n    return [];\r\n  });\r\n};\r\n\r\nvar validateThis = (this_, classType, humanName) => {\r\n  if (!(this_ instanceof Object)) {\r\n    throwBindingError(`${humanName} with invalid \"this\": ${this_}`);\r\n  }\r\n  if (!(this_ instanceof classType.registeredClass.constructor)) {\r\n    throwBindingError(`${humanName} incompatible with \"this\" of type ${this_.constructor.name}`);\r\n  }\r\n  if (!this_.$$.ptr) {\r\n    throwBindingError(`cannot call emscripten binding method ${humanName} on deleted object`);\r\n  }\r\n  // todo: kill this\r\n  return upcastPointer(this_.$$.ptr, this_.$$.ptrType.registeredClass, classType.registeredClass);\r\n};\r\n\r\nvar __embind_register_class_property = (classType, fieldName, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) => {\r\n  fieldName = readLatin1String(fieldName);\r\n  getter = embind__requireFunction(getterSignature, getter);\r\n  whenDependentTypesAreResolved([], [ classType ], classType => {\r\n    classType = classType[0];\r\n    var humanName = `${classType.name}.${fieldName}`;\r\n    var desc = {\r\n      get() {\r\n        throwUnboundTypeError(`Cannot access ${humanName} due to unbound types`, [ getterReturnType, setterArgumentType ]);\r\n      },\r\n      enumerable: true,\r\n      configurable: true\r\n    };\r\n    if (setter) {\r\n      desc.set = () => throwUnboundTypeError(`Cannot access ${humanName} due to unbound types`, [ getterReturnType, setterArgumentType ]);\r\n    } else {\r\n      desc.set = v => throwBindingError(humanName + \" is a read-only property\");\r\n    }\r\n    Object.defineProperty(classType.registeredClass.instancePrototype, fieldName, desc);\r\n    whenDependentTypesAreResolved([], (setter ? [ getterReturnType, setterArgumentType ] : [ getterReturnType ]), types => {\r\n      var getterReturnType = types[0];\r\n      var desc = {\r\n        get() {\r\n          var ptr = validateThis(this, classType, humanName + \" getter\");\r\n          return getterReturnType[\"fromWireType\"](getter(getterContext, ptr));\r\n        },\r\n        enumerable: true\r\n      };\r\n      if (setter) {\r\n        setter = embind__requireFunction(setterSignature, setter);\r\n        var setterArgumentType = types[1];\r\n        desc.set = function(v) {\r\n          var ptr = validateThis(this, classType, humanName + \" setter\");\r\n          var destructors = [];\r\n          setter(setterContext, ptr, setterArgumentType[\"toWireType\"](destructors, v));\r\n          runDestructors(destructors);\r\n        };\r\n      }\r\n      Object.defineProperty(classType.registeredClass.instancePrototype, fieldName, desc);\r\n      return [];\r\n    });\r\n    return [];\r\n  });\r\n};\r\n\r\nvar emval_freelist = [];\r\n\r\nvar emval_handles = [];\r\n\r\nvar __emval_decref = handle => {\r\n  if (handle > 9 && 0 === --emval_handles[handle + 1]) {\r\n    assert(emval_handles[handle] !== undefined, `Decref for unallocated handle.`);\r\n    emval_handles[handle] = undefined;\r\n    emval_freelist.push(handle);\r\n  }\r\n};\r\n\r\nvar count_emval_handles = () => emval_handles.length / 2 - 5 - emval_freelist.length;\r\n\r\nvar init_emval = () => {\r\n  // reserve 0 and some special values. These never get de-allocated.\r\n  emval_handles.push(0, 1, undefined, 1, null, 1, true, 1, false, 1);\r\n  assert(emval_handles.length === 5 * 2);\r\n  Module[\"count_emval_handles\"] = count_emval_handles;\r\n};\r\n\r\nvar Emval = {\r\n  toValue: handle => {\r\n    if (!handle) {\r\n      throwBindingError(`Cannot use deleted val. handle = ${handle}`);\r\n    }\r\n    // handle 2 is supposed to be `undefined`.\r\n    assert(handle === 2 || emval_handles[handle] !== undefined && handle % 2 === 0, `invalid handle: ${handle}`);\r\n    return emval_handles[handle];\r\n  },\r\n  toHandle: value => {\r\n    switch (value) {\r\n     case undefined:\r\n      return 2;\r\n\r\n     case null:\r\n      return 4;\r\n\r\n     case true:\r\n      return 6;\r\n\r\n     case false:\r\n      return 8;\r\n\r\n     default:\r\n      {\r\n        const handle = emval_freelist.pop() || emval_handles.length;\r\n        emval_handles[handle] = value;\r\n        emval_handles[handle + 1] = 1;\r\n        return handle;\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nvar EmValType = {\r\n  name: \"emscripten::val\",\r\n  \"fromWireType\": handle => {\r\n    var rv = Emval.toValue(handle);\r\n    __emval_decref(handle);\r\n    return rv;\r\n  },\r\n  \"toWireType\": (destructors, value) => Emval.toHandle(value),\r\n  argPackAdvance: GenericWireTypeSize,\r\n  \"readValueFromPointer\": readPointer,\r\n  destructorFunction: null\r\n};\r\n\r\nvar __embind_register_emval = rawType => registerType(rawType, EmValType);\r\n\r\nvar floatReadValueFromPointer = (name, width) => {\r\n  switch (width) {\r\n   case 4:\r\n    return function(pointer) {\r\n      return this[\"fromWireType\"](GROWABLE_HEAP_F32()[((pointer) >> 2)]);\r\n    };\r\n\r\n   case 8:\r\n    return function(pointer) {\r\n      return this[\"fromWireType\"](GROWABLE_HEAP_F64()[((pointer) >> 3)]);\r\n    };\r\n\r\n   default:\r\n    throw new TypeError(`invalid float width (${width}): ${name}`);\r\n  }\r\n};\r\n\r\nvar __embind_register_float = (rawType, name, size) => {\r\n  name = readLatin1String(name);\r\n  registerType(rawType, {\r\n    name,\r\n    \"fromWireType\": value => value,\r\n    \"toWireType\": (destructors, value) => {\r\n      if (typeof value != \"number\" && typeof value != \"boolean\") {\r\n        throw new TypeError(`Cannot convert ${embindRepr(value)} to ${this.name}`);\r\n      }\r\n      // The VM will perform JS to Wasm value conversion, according to the spec:\r\n      // https://www.w3.org/TR/wasm-js-api-1/#towebassemblyvalue\r\n      return value;\r\n    },\r\n    argPackAdvance: GenericWireTypeSize,\r\n    \"readValueFromPointer\": floatReadValueFromPointer(name, size),\r\n    destructorFunction: null\r\n  });\r\n};\r\n\r\nvar __embind_register_function = (name, argCount, rawArgTypesAddr, signature, rawInvoker, fn, isAsync, isNonnullReturn) => {\r\n  var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\r\n  name = readLatin1String(name);\r\n  name = getFunctionName(name);\r\n  rawInvoker = embind__requireFunction(signature, rawInvoker, isAsync);\r\n  exposePublicSymbol(name, function() {\r\n    throwUnboundTypeError(`Cannot call ${name} due to unbound types`, argTypes);\r\n  }, argCount - 1);\r\n  whenDependentTypesAreResolved([], argTypes, argTypes => {\r\n    var invokerArgsArray = [ argTypes[0], null ].concat(argTypes.slice(1));\r\n    replacePublicSymbol(name, craftInvokerFunction(name, invokerArgsArray, null, rawInvoker, fn, isAsync), argCount - 1);\r\n    return [];\r\n  });\r\n};\r\n\r\n/** @suppress {globalThis} */ var __embind_register_integer = (primitiveType, name, size, minRange, maxRange) => {\r\n  name = readLatin1String(name);\r\n  // LLVM doesn't have signed and unsigned 32-bit types, so u32 literals come\r\n  // out as 'i32 -1'. Always treat those as max u32.\r\n  if (maxRange === -1) {\r\n    maxRange = 4294967295;\r\n  }\r\n  var fromWireType = value => value;\r\n  if (minRange === 0) {\r\n    var bitshift = 32 - 8 * size;\r\n    fromWireType = value => (value << bitshift) >>> bitshift;\r\n  }\r\n  var isUnsignedType = (name.includes(\"unsigned\"));\r\n  var checkAssertions = (value, toTypeName) => {\r\n    if (typeof value != \"number\" && typeof value != \"boolean\") {\r\n      throw new TypeError(`Cannot convert \"${embindRepr(value)}\" to ${toTypeName}`);\r\n    }\r\n    if (value < minRange || value > maxRange) {\r\n      throw new TypeError(`Passing a number \"${embindRepr(value)}\" from JS side to C/C++ side to an argument of type \"${name}\", which is outside the valid range [${minRange}, ${maxRange}]!`);\r\n    }\r\n  };\r\n  var toWireType;\r\n  if (isUnsignedType) {\r\n    toWireType = function(destructors, value) {\r\n      checkAssertions(value, this.name);\r\n      return value >>> 0;\r\n    };\r\n  } else {\r\n    toWireType = function(destructors, value) {\r\n      checkAssertions(value, this.name);\r\n      // The VM will perform JS to Wasm value conversion, according to the spec:\r\n      // https://www.w3.org/TR/wasm-js-api-1/#towebassemblyvalue\r\n      return value;\r\n    };\r\n  }\r\n  registerType(primitiveType, {\r\n    name,\r\n    \"fromWireType\": fromWireType,\r\n    \"toWireType\": toWireType,\r\n    argPackAdvance: GenericWireTypeSize,\r\n    \"readValueFromPointer\": integerReadValueFromPointer(name, size, minRange !== 0),\r\n    destructorFunction: null\r\n  });\r\n};\r\n\r\nvar __embind_register_memory_view = (rawType, dataTypeIndex, name) => {\r\n  var typeMapping = [ Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array, BigInt64Array, BigUint64Array ];\r\n  var TA = typeMapping[dataTypeIndex];\r\n  function decodeMemoryView(handle) {\r\n    var size = GROWABLE_HEAP_U32()[((handle) >> 2)];\r\n    var data = GROWABLE_HEAP_U32()[(((handle) + (4)) >> 2)];\r\n    return new TA(GROWABLE_HEAP_I8().buffer, data, size);\r\n  }\r\n  name = readLatin1String(name);\r\n  registerType(rawType, {\r\n    name,\r\n    \"fromWireType\": decodeMemoryView,\r\n    argPackAdvance: GenericWireTypeSize,\r\n    \"readValueFromPointer\": decodeMemoryView\r\n  }, {\r\n    ignoreDuplicateRegistrations: true\r\n  });\r\n};\r\n\r\nvar EmValOptionalType = Object.assign({\r\n  optional: true\r\n}, EmValType);\r\n\r\nvar __embind_register_optional = (rawOptionalType, rawType) => {\r\n  registerType(rawOptionalType, EmValOptionalType);\r\n};\r\n\r\nvar stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {\r\n  assert(typeof str === \"string\", `stringToUTF8Array expects a string (got ${typeof str})`);\r\n  // Parameter maxBytesToWrite is not optional. Negative values, 0, null,\r\n  // undefined and false each don't write out any bytes.\r\n  if (!(maxBytesToWrite > 0)) return 0;\r\n  var startIdx = outIdx;\r\n  var endIdx = outIdx + maxBytesToWrite - 1;\r\n  // -1 for string null terminator.\r\n  for (var i = 0; i < str.length; ++i) {\r\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code\r\n    // unit, not a Unicode code point of the character! So decode\r\n    // UTF16->UTF32->UTF8.\r\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\r\n    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description\r\n    // and https://www.ietf.org/rfc/rfc2279.txt\r\n    // and https://tools.ietf.org/html/rfc3629\r\n    var u = str.charCodeAt(i);\r\n    // possibly a lead surrogate\r\n    if (u >= 55296 && u <= 57343) {\r\n      var u1 = str.charCodeAt(++i);\r\n      u = 65536 + ((u & 1023) << 10) | (u1 & 1023);\r\n    }\r\n    if (u <= 127) {\r\n      if (outIdx >= endIdx) break;\r\n      heap[outIdx++] = u;\r\n    } else if (u <= 2047) {\r\n      if (outIdx + 1 >= endIdx) break;\r\n      heap[outIdx++] = 192 | (u >> 6);\r\n      heap[outIdx++] = 128 | (u & 63);\r\n    } else if (u <= 65535) {\r\n      if (outIdx + 2 >= endIdx) break;\r\n      heap[outIdx++] = 224 | (u >> 12);\r\n      heap[outIdx++] = 128 | ((u >> 6) & 63);\r\n      heap[outIdx++] = 128 | (u & 63);\r\n    } else {\r\n      if (outIdx + 3 >= endIdx) break;\r\n      if (u > 1114111) warnOnce(\"Invalid Unicode code point \" + ptrToString(u) + \" encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF).\");\r\n      heap[outIdx++] = 240 | (u >> 18);\r\n      heap[outIdx++] = 128 | ((u >> 12) & 63);\r\n      heap[outIdx++] = 128 | ((u >> 6) & 63);\r\n      heap[outIdx++] = 128 | (u & 63);\r\n    }\r\n  }\r\n  // Null-terminate the pointer to the buffer.\r\n  heap[outIdx] = 0;\r\n  return outIdx - startIdx;\r\n};\r\n\r\nvar stringToUTF8 = (str, outPtr, maxBytesToWrite) => {\r\n  assert(typeof maxBytesToWrite == \"number\", \"stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!\");\r\n  return stringToUTF8Array(str, GROWABLE_HEAP_U8(), outPtr, maxBytesToWrite);\r\n};\r\n\r\nvar lengthBytesUTF8 = str => {\r\n  var len = 0;\r\n  for (var i = 0; i < str.length; ++i) {\r\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code\r\n    // unit, not a Unicode code point of the character! So decode\r\n    // UTF16->UTF32->UTF8.\r\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\r\n    var c = str.charCodeAt(i);\r\n    // possibly a lead surrogate\r\n    if (c <= 127) {\r\n      len++;\r\n    } else if (c <= 2047) {\r\n      len += 2;\r\n    } else if (c >= 55296 && c <= 57343) {\r\n      len += 4;\r\n      ++i;\r\n    } else {\r\n      len += 3;\r\n    }\r\n  }\r\n  return len;\r\n};\r\n\r\nvar __embind_register_std_string = (rawType, name) => {\r\n  name = readLatin1String(name);\r\n  var stdStringIsUTF8 = true;\r\n  registerType(rawType, {\r\n    name,\r\n    // For some method names we use string keys here since they are part of\r\n    // the public/external API and/or used by the runtime-generated code.\r\n    \"fromWireType\"(value) {\r\n      var length = GROWABLE_HEAP_U32()[((value) >> 2)];\r\n      var payload = value + 4;\r\n      var str;\r\n      if (stdStringIsUTF8) {\r\n        var decodeStartPtr = payload;\r\n        // Looping here to support possible embedded '0' bytes\r\n        for (var i = 0; i <= length; ++i) {\r\n          var currentBytePtr = payload + i;\r\n          if (i == length || GROWABLE_HEAP_U8()[currentBytePtr] == 0) {\r\n            var maxRead = currentBytePtr - decodeStartPtr;\r\n            var stringSegment = UTF8ToString(decodeStartPtr, maxRead);\r\n            if (str === undefined) {\r\n              str = stringSegment;\r\n            } else {\r\n              str += String.fromCharCode(0);\r\n              str += stringSegment;\r\n            }\r\n            decodeStartPtr = currentBytePtr + 1;\r\n          }\r\n        }\r\n      } else {\r\n        var a = new Array(length);\r\n        for (var i = 0; i < length; ++i) {\r\n          a[i] = String.fromCharCode(GROWABLE_HEAP_U8()[payload + i]);\r\n        }\r\n        str = a.join(\"\");\r\n      }\r\n      _free(value);\r\n      return str;\r\n    },\r\n    \"toWireType\"(destructors, value) {\r\n      if (value instanceof ArrayBuffer) {\r\n        value = new Uint8Array(value);\r\n      }\r\n      var length;\r\n      var valueIsOfTypeString = (typeof value == \"string\");\r\n      // We accept `string` or array views with single byte elements\r\n      if (!(valueIsOfTypeString || (ArrayBuffer.isView(value) && value.BYTES_PER_ELEMENT == 1))) {\r\n        throwBindingError(\"Cannot pass non-string to std::string\");\r\n      }\r\n      if (stdStringIsUTF8 && valueIsOfTypeString) {\r\n        length = lengthBytesUTF8(value);\r\n      } else {\r\n        length = value.length;\r\n      }\r\n      // assumes POINTER_SIZE alignment\r\n      var base = _malloc(4 + length + 1);\r\n      var ptr = base + 4;\r\n      GROWABLE_HEAP_U32()[((base) >> 2)] = length;\r\n      if (valueIsOfTypeString) {\r\n        if (stdStringIsUTF8) {\r\n          stringToUTF8(value, ptr, length + 1);\r\n        } else {\r\n          for (var i = 0; i < length; ++i) {\r\n            var charCode = value.charCodeAt(i);\r\n            if (charCode > 255) {\r\n              _free(base);\r\n              throwBindingError(\"String has UTF-16 code units that do not fit in 8 bits\");\r\n            }\r\n            GROWABLE_HEAP_U8()[ptr + i] = charCode;\r\n          }\r\n        }\r\n      } else {\r\n        GROWABLE_HEAP_U8().set(value, ptr);\r\n      }\r\n      if (destructors !== null) {\r\n        destructors.push(_free, base);\r\n      }\r\n      return base;\r\n    },\r\n    argPackAdvance: GenericWireTypeSize,\r\n    \"readValueFromPointer\": readPointer,\r\n    destructorFunction(ptr) {\r\n      _free(ptr);\r\n    }\r\n  });\r\n};\r\n\r\nvar UTF16Decoder = typeof TextDecoder != \"undefined\" ? new TextDecoder(\"utf-16le\") : undefined;\r\n\r\nvar UTF16ToString = (ptr, maxBytesToRead) => {\r\n  assert(ptr % 2 == 0, \"Pointer passed to UTF16ToString must be aligned to two bytes!\");\r\n  var endPtr = ptr;\r\n  // TextDecoder needs to know the byte length in advance, it doesn't stop on\r\n  // null terminator by itself.\r\n  // Also, use the length info to avoid running tiny strings through\r\n  // TextDecoder, since .subarray() allocates garbage.\r\n  var idx = endPtr >> 1;\r\n  var maxIdx = idx + maxBytesToRead / 2;\r\n  // If maxBytesToRead is not passed explicitly, it will be undefined, and this\r\n  // will always evaluate to true. This saves on code size.\r\n  while (!(idx >= maxIdx) && GROWABLE_HEAP_U16()[idx]) ++idx;\r\n  endPtr = idx << 1;\r\n  if (endPtr - ptr > 32 && UTF16Decoder) return UTF16Decoder.decode(GROWABLE_HEAP_U8().slice(ptr, endPtr));\r\n  // Fallback: decode without UTF16Decoder\r\n  var str = \"\";\r\n  // If maxBytesToRead is not passed explicitly, it will be undefined, and the\r\n  // for-loop's condition will always evaluate to true. The loop is then\r\n  // terminated on the first null char.\r\n  for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {\r\n    var codeUnit = GROWABLE_HEAP_I16()[(((ptr) + (i * 2)) >> 1)];\r\n    if (codeUnit == 0) break;\r\n    // fromCharCode constructs a character from a UTF-16 code unit, so we can\r\n    // pass the UTF16 string right through.\r\n    str += String.fromCharCode(codeUnit);\r\n  }\r\n  return str;\r\n};\r\n\r\nvar stringToUTF16 = (str, outPtr, maxBytesToWrite) => {\r\n  assert(outPtr % 2 == 0, \"Pointer passed to stringToUTF16 must be aligned to two bytes!\");\r\n  assert(typeof maxBytesToWrite == \"number\", \"stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!\");\r\n  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\r\n  maxBytesToWrite ??= 2147483647;\r\n  if (maxBytesToWrite < 2) return 0;\r\n  maxBytesToWrite -= 2;\r\n  // Null terminator.\r\n  var startPtr = outPtr;\r\n  var numCharsToWrite = (maxBytesToWrite < str.length * 2) ? (maxBytesToWrite / 2) : str.length;\r\n  for (var i = 0; i < numCharsToWrite; ++i) {\r\n    // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.\r\n    var codeUnit = str.charCodeAt(i);\r\n    // possibly a lead surrogate\r\n    GROWABLE_HEAP_I16()[((outPtr) >> 1)] = codeUnit;\r\n    outPtr += 2;\r\n  }\r\n  // Null-terminate the pointer to the HEAP.\r\n  GROWABLE_HEAP_I16()[((outPtr) >> 1)] = 0;\r\n  return outPtr - startPtr;\r\n};\r\n\r\nvar lengthBytesUTF16 = str => str.length * 2;\r\n\r\nvar UTF32ToString = (ptr, maxBytesToRead) => {\r\n  assert(ptr % 4 == 0, \"Pointer passed to UTF32ToString must be aligned to four bytes!\");\r\n  var i = 0;\r\n  var str = \"\";\r\n  // If maxBytesToRead is not passed explicitly, it will be undefined, and this\r\n  // will always evaluate to true. This saves on code size.\r\n  while (!(i >= maxBytesToRead / 4)) {\r\n    var utf32 = GROWABLE_HEAP_I32()[(((ptr) + (i * 4)) >> 2)];\r\n    if (utf32 == 0) break;\r\n    ++i;\r\n    // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.\r\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\r\n    if (utf32 >= 65536) {\r\n      var ch = utf32 - 65536;\r\n      str += String.fromCharCode(55296 | (ch >> 10), 56320 | (ch & 1023));\r\n    } else {\r\n      str += String.fromCharCode(utf32);\r\n    }\r\n  }\r\n  return str;\r\n};\r\n\r\nvar stringToUTF32 = (str, outPtr, maxBytesToWrite) => {\r\n  assert(outPtr % 4 == 0, \"Pointer passed to stringToUTF32 must be aligned to four bytes!\");\r\n  assert(typeof maxBytesToWrite == \"number\", \"stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!\");\r\n  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\r\n  maxBytesToWrite ??= 2147483647;\r\n  if (maxBytesToWrite < 4) return 0;\r\n  var startPtr = outPtr;\r\n  var endPtr = startPtr + maxBytesToWrite - 4;\r\n  for (var i = 0; i < str.length; ++i) {\r\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\r\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\r\n    var codeUnit = str.charCodeAt(i);\r\n    // possibly a lead surrogate\r\n    if (codeUnit >= 55296 && codeUnit <= 57343) {\r\n      var trailSurrogate = str.charCodeAt(++i);\r\n      codeUnit = 65536 + ((codeUnit & 1023) << 10) | (trailSurrogate & 1023);\r\n    }\r\n    GROWABLE_HEAP_I32()[((outPtr) >> 2)] = codeUnit;\r\n    outPtr += 4;\r\n    if (outPtr + 4 > endPtr) break;\r\n  }\r\n  // Null-terminate the pointer to the HEAP.\r\n  GROWABLE_HEAP_I32()[((outPtr) >> 2)] = 0;\r\n  return outPtr - startPtr;\r\n};\r\n\r\nvar lengthBytesUTF32 = str => {\r\n  var len = 0;\r\n  for (var i = 0; i < str.length; ++i) {\r\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\r\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\r\n    var codeUnit = str.charCodeAt(i);\r\n    if (codeUnit >= 55296 && codeUnit <= 57343) ++i;\r\n    // possibly a lead surrogate, so skip over the tail surrogate.\r\n    len += 4;\r\n  }\r\n  return len;\r\n};\r\n\r\nvar __embind_register_std_wstring = (rawType, charSize, name) => {\r\n  name = readLatin1String(name);\r\n  var decodeString, encodeString, readCharAt, lengthBytesUTF;\r\n  if (charSize === 2) {\r\n    decodeString = UTF16ToString;\r\n    encodeString = stringToUTF16;\r\n    lengthBytesUTF = lengthBytesUTF16;\r\n    readCharAt = pointer => GROWABLE_HEAP_U16()[((pointer) >> 1)];\r\n  } else if (charSize === 4) {\r\n    decodeString = UTF32ToString;\r\n    encodeString = stringToUTF32;\r\n    lengthBytesUTF = lengthBytesUTF32;\r\n    readCharAt = pointer => GROWABLE_HEAP_U32()[((pointer) >> 2)];\r\n  }\r\n  registerType(rawType, {\r\n    name,\r\n    \"fromWireType\": value => {\r\n      // Code mostly taken from _embind_register_std_string fromWireType\r\n      var length = GROWABLE_HEAP_U32()[((value) >> 2)];\r\n      var str;\r\n      var decodeStartPtr = value + 4;\r\n      // Looping here to support possible embedded '0' bytes\r\n      for (var i = 0; i <= length; ++i) {\r\n        var currentBytePtr = value + 4 + i * charSize;\r\n        if (i == length || readCharAt(currentBytePtr) == 0) {\r\n          var maxReadBytes = currentBytePtr - decodeStartPtr;\r\n          var stringSegment = decodeString(decodeStartPtr, maxReadBytes);\r\n          if (str === undefined) {\r\n            str = stringSegment;\r\n          } else {\r\n            str += String.fromCharCode(0);\r\n            str += stringSegment;\r\n          }\r\n          decodeStartPtr = currentBytePtr + charSize;\r\n        }\r\n      }\r\n      _free(value);\r\n      return str;\r\n    },\r\n    \"toWireType\": (destructors, value) => {\r\n      if (!(typeof value == \"string\")) {\r\n        throwBindingError(`Cannot pass non-string to C++ string type ${name}`);\r\n      }\r\n      // assumes POINTER_SIZE alignment\r\n      var length = lengthBytesUTF(value);\r\n      var ptr = _malloc(4 + length + charSize);\r\n      GROWABLE_HEAP_U32()[((ptr) >> 2)] = length / charSize;\r\n      encodeString(value, ptr + 4, length + charSize);\r\n      if (destructors !== null) {\r\n        destructors.push(_free, ptr);\r\n      }\r\n      return ptr;\r\n    },\r\n    argPackAdvance: GenericWireTypeSize,\r\n    \"readValueFromPointer\": readPointer,\r\n    destructorFunction(ptr) {\r\n      _free(ptr);\r\n    }\r\n  });\r\n};\r\n\r\nvar __embind_register_value_object = (rawType, name, constructorSignature, rawConstructor, destructorSignature, rawDestructor) => {\r\n  structRegistrations[rawType] = {\r\n    name: readLatin1String(name),\r\n    rawConstructor: embind__requireFunction(constructorSignature, rawConstructor),\r\n    rawDestructor: embind__requireFunction(destructorSignature, rawDestructor),\r\n    fields: []\r\n  };\r\n};\r\n\r\nvar __embind_register_value_object_field = (structType, fieldName, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) => {\r\n  structRegistrations[structType].fields.push({\r\n    fieldName: readLatin1String(fieldName),\r\n    getterReturnType,\r\n    getter: embind__requireFunction(getterSignature, getter),\r\n    getterContext,\r\n    setterArgumentType,\r\n    setter: embind__requireFunction(setterSignature, setter),\r\n    setterContext\r\n  });\r\n};\r\n\r\nvar __embind_register_void = (rawType, name) => {\r\n  name = readLatin1String(name);\r\n  registerType(rawType, {\r\n    isVoid: true,\r\n    // void return values can be optimized out sometimes\r\n    name,\r\n    argPackAdvance: 0,\r\n    \"fromWireType\": () => undefined,\r\n    // TODO: assert if anything else is given?\r\n    \"toWireType\": (destructors, o) => undefined\r\n  });\r\n};\r\n\r\nvar __emscripten_init_main_thread_js = tb => {\r\n  // Pass the thread address to the native code where they stored in wasm\r\n  // globals which act as a form of TLS. Global constructors trying\r\n  // to access this value will read the wrong value, but that is UB anyway.\r\n  __emscripten_thread_init(tb, /*is_main=*/ !ENVIRONMENT_IS_WORKER, /*is_runtime=*/ 1, /*can_block=*/ !ENVIRONMENT_IS_WEB, /*default_stacksize=*/ 2097152, /*start_profiling=*/ false);\r\n  PThread.threadInitTLS();\r\n};\r\n\r\nvar handleException = e => {\r\n  // Certain exception types we do not treat as errors since they are used for\r\n  // internal control flow.\r\n  // 1. ExitStatus, which is thrown by exit()\r\n  // 2. \"unwind\", which is thrown by emscripten_unwind_to_js_event_loop() and others\r\n  //    that wish to return to JS event loop.\r\n  if (e instanceof ExitStatus || e == \"unwind\") {\r\n    return EXITSTATUS;\r\n  }\r\n  checkStackCookie();\r\n  if (e instanceof WebAssembly.RuntimeError) {\r\n    if (_emscripten_stack_get_current() <= 0) {\r\n      err(\"Stack overflow detected.  You can try increasing -sSTACK_SIZE (currently set to 2097152)\");\r\n    }\r\n  }\r\n  quit_(1, e);\r\n};\r\n\r\nvar maybeExit = () => {\r\n  if (!keepRuntimeAlive()) {\r\n    try {\r\n      if (ENVIRONMENT_IS_PTHREAD) __emscripten_thread_exit(EXITSTATUS); else _exit(EXITSTATUS);\r\n    } catch (e) {\r\n      handleException(e);\r\n    }\r\n  }\r\n};\r\n\r\nvar callUserCallback = func => {\r\n  if (ABORT) {\r\n    err(\"user callback triggered after runtime exited or application aborted.  Ignoring.\");\r\n    return;\r\n  }\r\n  try {\r\n    func();\r\n    maybeExit();\r\n  } catch (e) {\r\n    handleException(e);\r\n  }\r\n};\r\n\r\nvar __emscripten_thread_mailbox_await = pthread_ptr => {\r\n  if (typeof Atomics.waitAsync === \"function\") {\r\n    // Wait on the pthread's initial self-pointer field because it is easy and\r\n    // safe to access from sending threads that need to notify the waiting\r\n    // thread.\r\n    // TODO: How to make this work with wasm64?\r\n    var wait = Atomics.waitAsync(GROWABLE_HEAP_I32(), ((pthread_ptr) >> 2), pthread_ptr);\r\n    assert(wait.async);\r\n    wait.value.then(checkMailbox);\r\n    var waitingAsync = pthread_ptr + 128;\r\n    Atomics.store(GROWABLE_HEAP_I32(), ((waitingAsync) >> 2), 1);\r\n  }\r\n};\r\n\r\nvar checkMailbox = () => {\r\n  // Only check the mailbox if we have a live pthread runtime. We implement\r\n  // pthread_self to return 0 if there is no live runtime.\r\n  var pthread_ptr = _pthread_self();\r\n  if (pthread_ptr) {\r\n    // If we are using Atomics.waitAsync as our notification mechanism, wait\r\n    // for a notification before processing the mailbox to avoid missing any\r\n    // work that could otherwise arrive after we've finished processing the\r\n    // mailbox and before we're ready for the next notification.\r\n    __emscripten_thread_mailbox_await(pthread_ptr);\r\n    callUserCallback(__emscripten_check_mailbox);\r\n  }\r\n};\r\n\r\nvar __emscripten_notify_mailbox_postmessage = (targetThread, currThreadId) => {\r\n  if (targetThread == currThreadId) {\r\n    setTimeout(checkMailbox);\r\n  } else if (ENVIRONMENT_IS_PTHREAD) {\r\n    postMessage({\r\n      targetThread,\r\n      cmd: \"checkMailbox\"\r\n    });\r\n  } else {\r\n    var worker = PThread.pthreads[targetThread];\r\n    if (!worker) {\r\n      err(`Cannot send message to thread with ID ${targetThread}, unknown thread ID!`);\r\n      return;\r\n    }\r\n    worker.postMessage({\r\n      cmd: \"checkMailbox\"\r\n    });\r\n  }\r\n};\r\n\r\nvar proxiedJSCallArgs = [];\r\n\r\nvar __emscripten_receive_on_main_thread_js = (funcIndex, emAsmAddr, callingThread, numCallArgs, args) => {\r\n  // Sometimes we need to backproxy events to the calling thread (e.g.\r\n  // HTML5 DOM events handlers such as\r\n  // emscripten_set_mousemove_callback()), so keep track in a globally\r\n  // accessible variable about the thread that initiated the proxying.\r\n  numCallArgs /= 2;\r\n  proxiedJSCallArgs.length = numCallArgs;\r\n  var b = ((args) >> 3);\r\n  for (var i = 0; i < numCallArgs; i++) {\r\n    if (HEAP64[b + 2 * i]) {\r\n      // It's a BigInt.\r\n      proxiedJSCallArgs[i] = HEAP64[b + 2 * i + 1];\r\n    } else {\r\n      // It's a Number.\r\n      proxiedJSCallArgs[i] = GROWABLE_HEAP_F64()[b + 2 * i + 1];\r\n    }\r\n  }\r\n  // Proxied JS library funcs use funcIndex and EM_ASM functions use emAsmAddr\r\n  assert(!emAsmAddr);\r\n  var func = proxiedFunctionTable[funcIndex];\r\n  assert(!(funcIndex && emAsmAddr));\r\n  assert(func.length == numCallArgs, \"Call args mismatch in _emscripten_receive_on_main_thread_js\");\r\n  PThread.currentProxiedOperationCallerThread = callingThread;\r\n  var rtn = func(...proxiedJSCallArgs);\r\n  PThread.currentProxiedOperationCallerThread = 0;\r\n  // Proxied functions can return any type except bigint.  All other types\r\n  // cooerce to f64/double (the return type of this function in C) but not\r\n  // bigint.\r\n  assert(typeof rtn != \"bigint\");\r\n  return rtn;\r\n};\r\n\r\nvar __emscripten_thread_cleanup = thread => {\r\n  // Called when a thread needs to be cleaned up so it can be reused.\r\n  // A thread is considered reusable when it either returns from its\r\n  // entry point, calls pthread_exit, or acts upon a cancellation.\r\n  // Detached threads are responsible for calling this themselves,\r\n  // otherwise pthread_join is responsible for calling this.\r\n  if (!ENVIRONMENT_IS_PTHREAD) cleanupThread(thread); else postMessage({\r\n    cmd: \"cleanupThread\",\r\n    thread\r\n  });\r\n};\r\n\r\nvar __emscripten_thread_set_strongref = thread => {\r\n  // Called when a thread needs to be strongly referenced.\r\n  // Currently only used for:\r\n  // - keeping the \"main\" thread alive in PROXY_TO_PTHREAD mode;\r\n  // - crashed threads that needs to propagate the uncaught exception\r\n  //   back to the main thread.\r\n  if (ENVIRONMENT_IS_NODE) {\r\n    PThread.pthreads[thread].ref();\r\n  }\r\n};\r\n\r\nvar emval_symbols = {};\r\n\r\nvar getStringOrSymbol = address => {\r\n  var symbol = emval_symbols[address];\r\n  if (symbol === undefined) {\r\n    return readLatin1String(address);\r\n  }\r\n  return symbol;\r\n};\r\n\r\nvar emval_methodCallers = [];\r\n\r\nvar __emval_call_method = (caller, objHandle, methodName, destructorsRef, args) => {\r\n  caller = emval_methodCallers[caller];\r\n  objHandle = Emval.toValue(objHandle);\r\n  methodName = getStringOrSymbol(methodName);\r\n  return caller(objHandle, objHandle[methodName], destructorsRef, args);\r\n};\r\n\r\nvar emval_get_global = () => {\r\n  if (typeof globalThis == \"object\") {\r\n    return globalThis;\r\n  }\r\n  return (function() {\r\n    return Function;\r\n  })()(\"return this\")();\r\n};\r\n\r\nvar __emval_get_global = name => {\r\n  if (name === 0) {\r\n    return Emval.toHandle(emval_get_global());\r\n  } else {\r\n    name = getStringOrSymbol(name);\r\n    return Emval.toHandle(emval_get_global()[name]);\r\n  }\r\n};\r\n\r\nvar emval_addMethodCaller = caller => {\r\n  var id = emval_methodCallers.length;\r\n  emval_methodCallers.push(caller);\r\n  return id;\r\n};\r\n\r\nvar requireRegisteredType = (rawType, humanName) => {\r\n  var impl = registeredTypes[rawType];\r\n  if (undefined === impl) {\r\n    throwBindingError(`${humanName} has unknown type ${getTypeName(rawType)}`);\r\n  }\r\n  return impl;\r\n};\r\n\r\nvar emval_lookupTypes = (argCount, argTypes) => {\r\n  var a = new Array(argCount);\r\n  for (var i = 0; i < argCount; ++i) {\r\n    a[i] = requireRegisteredType(GROWABLE_HEAP_U32()[(((argTypes) + (i * 4)) >> 2)], `parameter ${i}`);\r\n  }\r\n  return a;\r\n};\r\n\r\nvar emval_returnValue = (returnType, destructorsRef, handle) => {\r\n  var destructors = [];\r\n  var result = returnType[\"toWireType\"](destructors, handle);\r\n  if (destructors.length) {\r\n    // void, primitives and any other types w/o destructors don't need to allocate a handle\r\n    GROWABLE_HEAP_U32()[((destructorsRef) >> 2)] = Emval.toHandle(destructors);\r\n  }\r\n  return result;\r\n};\r\n\r\nvar __emval_get_method_caller = (argCount, argTypes, kind) => {\r\n  var types = emval_lookupTypes(argCount, argTypes);\r\n  var retType = types.shift();\r\n  argCount--;\r\n  // remove the shifted off return type\r\n  var functionBody = `return function (obj, func, destructorsRef, args) {\\n`;\r\n  var offset = 0;\r\n  var argsList = [];\r\n  // 'obj?, arg0, arg1, arg2, ... , argN'\r\n  if (kind === /* FUNCTION */ 0) {\r\n    argsList.push(\"obj\");\r\n  }\r\n  var params = [ \"retType\" ];\r\n  var args = [ retType ];\r\n  for (var i = 0; i < argCount; ++i) {\r\n    argsList.push(`arg${i}`);\r\n    params.push(`argType${i}`);\r\n    args.push(types[i]);\r\n    functionBody += `  var arg${i} = argType${i}.readValueFromPointer(args${offset ? \"+\" + offset : \"\"});\\n`;\r\n    offset += types[i].argPackAdvance;\r\n  }\r\n  var invoker = kind === /* CONSTRUCTOR */ 1 ? \"new func\" : \"func.call\";\r\n  functionBody += `  var rv = ${invoker}(${argsList.join(\", \")});\\n`;\r\n  if (!retType.isVoid) {\r\n    params.push(\"emval_returnValue\");\r\n    args.push(emval_returnValue);\r\n    functionBody += \"  return emval_returnValue(retType, destructorsRef, rv);\\n\";\r\n  }\r\n  functionBody += \"};\\n\";\r\n  var invokerFunction = new Function(...params, functionBody)(...args);\r\n  var functionName = `methodCaller<(${types.map(t => t.name).join(\", \")}) => ${retType.name}>`;\r\n  return emval_addMethodCaller(createNamedFunction(functionName, invokerFunction));\r\n};\r\n\r\nvar __emval_run_destructors = handle => {\r\n  var destructors = Emval.toValue(handle);\r\n  runDestructors(destructors);\r\n  __emval_decref(handle);\r\n};\r\n\r\nvar __emval_take_value = (type, arg) => {\r\n  type = requireRegisteredType(type, \"_emval_take_value\");\r\n  var v = type[\"readValueFromPointer\"](arg);\r\n  return Emval.toHandle(v);\r\n};\r\n\r\nvar _emscripten_get_now = () => performance.timeOrigin + performance.now();\r\n\r\nvar _emscripten_date_now = () => Date.now();\r\n\r\nvar nowIsMonotonic = 1;\r\n\r\nvar checkWasiClock = clock_id => clock_id >= 0 && clock_id <= 3;\r\n\r\nvar INT53_MAX = 9007199254740992;\r\n\r\nvar INT53_MIN = -9007199254740992;\r\n\r\nvar bigintToI53Checked = num => (num < INT53_MIN || num > INT53_MAX) ? NaN : Number(num);\r\n\r\nfunction _clock_time_get(clk_id, ignored_precision, ptime) {\r\n  ignored_precision = bigintToI53Checked(ignored_precision);\r\n  if (!checkWasiClock(clk_id)) {\r\n    return 28;\r\n  }\r\n  var now;\r\n  // all wasi clocks but realtime are monotonic\r\n  if (clk_id === 0) {\r\n    now = _emscripten_date_now();\r\n  } else if (nowIsMonotonic) {\r\n    now = _emscripten_get_now();\r\n  } else {\r\n    return 52;\r\n  }\r\n  // \"now\" is in ms, and wasi times are in ns.\r\n  var nsec = Math.round(now * 1e3 * 1e3);\r\n  HEAP64[((ptime) >> 3)] = BigInt(nsec);\r\n  return 0;\r\n}\r\n\r\nvar _emscripten_check_blocking_allowed = () => {\r\n  if (ENVIRONMENT_IS_NODE) return;\r\n  if (ENVIRONMENT_IS_WORKER) return;\r\n  // Blocking in a worker/pthread is fine.\r\n  warnOnce(\"Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread\");\r\n};\r\n\r\nvar _emscripten_exit_with_live_runtime = () => {\r\n  runtimeKeepalivePush();\r\n  throw \"unwind\";\r\n};\r\n\r\nvar getHeapMax = () => // Stay one Wasm page short of 4GB: while e.g. Chrome is able to allocate\r\n// full 4GB Wasm memories, the size will wrap back to 0 bytes in Wasm side\r\n// for any code that deals with heap sizes, which would require special\r\n// casing all heap size related code to treat 0 specially.\r\n2147483648;\r\n\r\nvar _emscripten_get_heap_max = () => getHeapMax();\r\n\r\nvar _emscripten_num_logical_cores = () => ENVIRONMENT_IS_NODE ? require(\"os\").cpus().length : navigator[\"hardwareConcurrency\"];\r\n\r\nvar alignMemory = (size, alignment) => {\r\n  assert(alignment, \"alignment argument is required\");\r\n  return Math.ceil(size / alignment) * alignment;\r\n};\r\n\r\nvar growMemory = size => {\r\n  var b = wasmMemory.buffer;\r\n  var pages = ((size - b.byteLength + 65535) / 65536) | 0;\r\n  try {\r\n    // round size grow request up to wasm page size (fixed 64KB per spec)\r\n    wasmMemory.grow(pages);\r\n    // .grow() takes a delta compared to the previous size\r\n    updateMemoryViews();\r\n    return 1;\r\n  } catch (e) {\r\n    err(`growMemory: Attempted to grow heap from ${b.byteLength} bytes to ${size} bytes, but got error: ${e}`);\r\n  }\r\n};\r\n\r\nvar _emscripten_resize_heap = requestedSize => {\r\n  var oldSize = GROWABLE_HEAP_U8().length;\r\n  // With CAN_ADDRESS_2GB or MEMORY64, pointers are already unsigned.\r\n  requestedSize >>>= 0;\r\n  // With multithreaded builds, races can happen (another thread might increase the size\r\n  // in between), so return a failure, and let the caller retry.\r\n  if (requestedSize <= oldSize) {\r\n    return false;\r\n  }\r\n  // Memory resize rules:\r\n  // 1.  Always increase heap size to at least the requested size, rounded up\r\n  //     to next page multiple.\r\n  // 2a. If MEMORY_GROWTH_LINEAR_STEP == -1, excessively resize the heap\r\n  //     geometrically: increase the heap size according to\r\n  //     MEMORY_GROWTH_GEOMETRIC_STEP factor (default +20%), At most\r\n  //     overreserve by MEMORY_GROWTH_GEOMETRIC_CAP bytes (default 96MB).\r\n  // 2b. If MEMORY_GROWTH_LINEAR_STEP != -1, excessively resize the heap\r\n  //     linearly: increase the heap size by at least\r\n  //     MEMORY_GROWTH_LINEAR_STEP bytes.\r\n  // 3.  Max size for the heap is capped at 2048MB-WASM_PAGE_SIZE, or by\r\n  //     MAXIMUM_MEMORY, or by ASAN limit, depending on which is smallest\r\n  // 4.  If we were unable to allocate as much memory, it may be due to\r\n  //     over-eager decision to excessively reserve due to (3) above.\r\n  //     Hence if an allocation fails, cut down on the amount of excess\r\n  //     growth, in an attempt to succeed to perform a smaller allocation.\r\n  // A limit is set for how much we can grow. We should not exceed that\r\n  // (the wasm binary specifies it, so if we tried, we'd fail anyhow).\r\n  var maxHeapSize = getHeapMax();\r\n  if (requestedSize > maxHeapSize) {\r\n    err(`Cannot enlarge memory, requested ${requestedSize} bytes, but the limit is ${maxHeapSize} bytes!`);\r\n    return false;\r\n  }\r\n  // Loop through potential heap size increases. If we attempt a too eager\r\n  // reservation that fails, cut down on the attempted size and reserve a\r\n  // smaller bump instead. (max 3 times, chosen somewhat arbitrarily)\r\n  for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {\r\n    var overGrownHeapSize = oldSize * (1 + .2 / cutDown);\r\n    // ensure geometric growth\r\n    // but limit overreserving (default to capping at +96MB overgrowth at most)\r\n    overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);\r\n    var newSize = Math.min(maxHeapSize, alignMemory(Math.max(requestedSize, overGrownHeapSize), 65536));\r\n    var replacement = growMemory(newSize);\r\n    if (replacement) {\r\n      return true;\r\n    }\r\n  }\r\n  err(`Failed to grow the heap from ${oldSize} bytes to ${newSize} bytes, not enough memory!`);\r\n  return false;\r\n};\r\n\r\nvar _emscripten_runtime_keepalive_check = keepRuntimeAlive;\r\n\r\nvar PATH = {\r\n  isAbs: path => path.charAt(0) === \"/\",\r\n  splitPath: filename => {\r\n    var splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\r\n    return splitPathRe.exec(filename).slice(1);\r\n  },\r\n  normalizeArray: (parts, allowAboveRoot) => {\r\n    // if the path tries to go above the root, `up` ends up > 0\r\n    var up = 0;\r\n    for (var i = parts.length - 1; i >= 0; i--) {\r\n      var last = parts[i];\r\n      if (last === \".\") {\r\n        parts.splice(i, 1);\r\n      } else if (last === \"..\") {\r\n        parts.splice(i, 1);\r\n        up++;\r\n      } else if (up) {\r\n        parts.splice(i, 1);\r\n        up--;\r\n      }\r\n    }\r\n    // if the path is allowed to go above the root, restore leading ..s\r\n    if (allowAboveRoot) {\r\n      for (;up; up--) {\r\n        parts.unshift(\"..\");\r\n      }\r\n    }\r\n    return parts;\r\n  },\r\n  normalize: path => {\r\n    var isAbsolute = PATH.isAbs(path), trailingSlash = path.slice(-1) === \"/\";\r\n    // Normalize the path\r\n    path = PATH.normalizeArray(path.split(\"/\").filter(p => !!p), !isAbsolute).join(\"/\");\r\n    if (!path && !isAbsolute) {\r\n      path = \".\";\r\n    }\r\n    if (path && trailingSlash) {\r\n      path += \"/\";\r\n    }\r\n    return (isAbsolute ? \"/\" : \"\") + path;\r\n  },\r\n  dirname: path => {\r\n    var result = PATH.splitPath(path), root = result[0], dir = result[1];\r\n    if (!root && !dir) {\r\n      // No dirname whatsoever\r\n      return \".\";\r\n    }\r\n    if (dir) {\r\n      // It has a dirname, strip trailing slash\r\n      dir = dir.slice(0, -1);\r\n    }\r\n    return root + dir;\r\n  },\r\n  basename: path => path && path.match(/([^\\/]+|\\/)\\/*$/)[1],\r\n  join: (...paths) => PATH.normalize(paths.join(\"/\")),\r\n  join2: (l, r) => PATH.normalize(l + \"/\" + r)\r\n};\r\n\r\nvar initRandomFill = () => {\r\n  // This block is not needed on v19+ since crypto.getRandomValues is builtin\r\n  if (ENVIRONMENT_IS_NODE) {\r\n    var nodeCrypto = require(\"crypto\");\r\n    return view => nodeCrypto.randomFillSync(view);\r\n  }\r\n  // like with most Web APIs, we can't use Web Crypto API directly on shared memory,\r\n  // so we need to create an intermediate buffer and copy it to the destination\r\n  return view => view.set(crypto.getRandomValues(new Uint8Array(view.byteLength)));\r\n};\r\n\r\nvar randomFill = view => {\r\n  // Lazily init on the first invocation.\r\n  (randomFill = initRandomFill())(view);\r\n};\r\n\r\nvar PATH_FS = {\r\n  resolve: (...args) => {\r\n    var resolvedPath = \"\", resolvedAbsolute = false;\r\n    for (var i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {\r\n      var path = (i >= 0) ? args[i] : FS.cwd();\r\n      // Skip empty and invalid entries\r\n      if (typeof path != \"string\") {\r\n        throw new TypeError(\"Arguments to path.resolve must be strings\");\r\n      } else if (!path) {\r\n        return \"\";\r\n      }\r\n      resolvedPath = path + \"/\" + resolvedPath;\r\n      resolvedAbsolute = PATH.isAbs(path);\r\n    }\r\n    // At this point the path should be resolved to a full absolute path, but\r\n    // handle relative paths to be safe (might happen when process.cwd() fails)\r\n    resolvedPath = PATH.normalizeArray(resolvedPath.split(\"/\").filter(p => !!p), !resolvedAbsolute).join(\"/\");\r\n    return ((resolvedAbsolute ? \"/\" : \"\") + resolvedPath) || \".\";\r\n  },\r\n  relative: (from, to) => {\r\n    from = PATH_FS.resolve(from).slice(1);\r\n    to = PATH_FS.resolve(to).slice(1);\r\n    function trim(arr) {\r\n      var start = 0;\r\n      for (;start < arr.length; start++) {\r\n        if (arr[start] !== \"\") break;\r\n      }\r\n      var end = arr.length - 1;\r\n      for (;end >= 0; end--) {\r\n        if (arr[end] !== \"\") break;\r\n      }\r\n      if (start > end) return [];\r\n      return arr.slice(start, end - start + 1);\r\n    }\r\n    var fromParts = trim(from.split(\"/\"));\r\n    var toParts = trim(to.split(\"/\"));\r\n    var length = Math.min(fromParts.length, toParts.length);\r\n    var samePartsLength = length;\r\n    for (var i = 0; i < length; i++) {\r\n      if (fromParts[i] !== toParts[i]) {\r\n        samePartsLength = i;\r\n        break;\r\n      }\r\n    }\r\n    var outputParts = [];\r\n    for (var i = samePartsLength; i < fromParts.length; i++) {\r\n      outputParts.push(\"..\");\r\n    }\r\n    outputParts = outputParts.concat(toParts.slice(samePartsLength));\r\n    return outputParts.join(\"/\");\r\n  }\r\n};\r\n\r\nvar FS_stdin_getChar_buffer = [];\r\n\r\n/** @type {function(string, boolean=, number=)} */ var intArrayFromString = (stringy, dontAddNull, length) => {\r\n  var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;\r\n  var u8array = new Array(len);\r\n  var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\r\n  if (dontAddNull) u8array.length = numBytesWritten;\r\n  return u8array;\r\n};\r\n\r\nvar FS_stdin_getChar = () => {\r\n  if (!FS_stdin_getChar_buffer.length) {\r\n    var result = null;\r\n    if (ENVIRONMENT_IS_NODE) {\r\n      // we will read data by chunks of BUFSIZE\r\n      var BUFSIZE = 256;\r\n      var buf = Buffer.alloc(BUFSIZE);\r\n      var bytesRead = 0;\r\n      // For some reason we must suppress a closure warning here, even though\r\n      // fd definitely exists on process.stdin, and is even the proper way to\r\n      // get the fd of stdin,\r\n      // https://github.com/nodejs/help/issues/2136#issuecomment-523649904\r\n      // This started to happen after moving this logic out of library_tty.js,\r\n      // so it is related to the surrounding code in some unclear manner.\r\n      /** @suppress {missingProperties} */ var fd = process.stdin.fd;\r\n      try {\r\n        bytesRead = fs.readSync(fd, buf, 0, BUFSIZE);\r\n      } catch (e) {\r\n        // Cross-platform differences: on Windows, reading EOF throws an\r\n        // exception, but on other OSes, reading EOF returns 0. Uniformize\r\n        // behavior by treating the EOF exception to return 0.\r\n        if (e.toString().includes(\"EOF\")) bytesRead = 0; else throw e;\r\n      }\r\n      if (bytesRead > 0) {\r\n        result = buf.slice(0, bytesRead).toString(\"utf-8\");\r\n      }\r\n    } else if (typeof window != \"undefined\" && typeof window.prompt == \"function\") {\r\n      // Browser.\r\n      result = window.prompt(\"Input: \");\r\n      // returns null on cancel\r\n      if (result !== null) {\r\n        result += \"\\n\";\r\n      }\r\n    } else {}\r\n    if (!result) {\r\n      return null;\r\n    }\r\n    FS_stdin_getChar_buffer = intArrayFromString(result, true);\r\n  }\r\n  return FS_stdin_getChar_buffer.shift();\r\n};\r\n\r\nvar TTY = {\r\n  ttys: [],\r\n  init() {},\r\n  shutdown() {},\r\n  register(dev, ops) {\r\n    TTY.ttys[dev] = {\r\n      input: [],\r\n      output: [],\r\n      ops\r\n    };\r\n    FS.registerDevice(dev, TTY.stream_ops);\r\n  },\r\n  stream_ops: {\r\n    open(stream) {\r\n      var tty = TTY.ttys[stream.node.rdev];\r\n      if (!tty) {\r\n        throw new FS.ErrnoError(43);\r\n      }\r\n      stream.tty = tty;\r\n      stream.seekable = false;\r\n    },\r\n    close(stream) {\r\n      // flush any pending line data\r\n      stream.tty.ops.fsync(stream.tty);\r\n    },\r\n    fsync(stream) {\r\n      stream.tty.ops.fsync(stream.tty);\r\n    },\r\n    read(stream, buffer, offset, length, pos) {\r\n      if (!stream.tty || !stream.tty.ops.get_char) {\r\n        throw new FS.ErrnoError(60);\r\n      }\r\n      var bytesRead = 0;\r\n      for (var i = 0; i < length; i++) {\r\n        var result;\r\n        try {\r\n          result = stream.tty.ops.get_char(stream.tty);\r\n        } catch (e) {\r\n          throw new FS.ErrnoError(29);\r\n        }\r\n        if (result === undefined && bytesRead === 0) {\r\n          throw new FS.ErrnoError(6);\r\n        }\r\n        if (result === null || result === undefined) break;\r\n        bytesRead++;\r\n        buffer[offset + i] = result;\r\n      }\r\n      if (bytesRead) {\r\n        stream.node.atime = Date.now();\r\n      }\r\n      return bytesRead;\r\n    },\r\n    write(stream, buffer, offset, length, pos) {\r\n      if (!stream.tty || !stream.tty.ops.put_char) {\r\n        throw new FS.ErrnoError(60);\r\n      }\r\n      try {\r\n        for (var i = 0; i < length; i++) {\r\n          stream.tty.ops.put_char(stream.tty, buffer[offset + i]);\r\n        }\r\n      } catch (e) {\r\n        throw new FS.ErrnoError(29);\r\n      }\r\n      if (length) {\r\n        stream.node.mtime = stream.node.ctime = Date.now();\r\n      }\r\n      return i;\r\n    }\r\n  },\r\n  default_tty_ops: {\r\n    get_char(tty) {\r\n      return FS_stdin_getChar();\r\n    },\r\n    put_char(tty, val) {\r\n      if (val === null || val === 10) {\r\n        out(UTF8ArrayToString(tty.output));\r\n        tty.output = [];\r\n      } else {\r\n        if (val != 0) tty.output.push(val);\r\n      }\r\n    },\r\n    fsync(tty) {\r\n      if (tty.output?.length > 0) {\r\n        out(UTF8ArrayToString(tty.output));\r\n        tty.output = [];\r\n      }\r\n    },\r\n    ioctl_tcgets(tty) {\r\n      // typical setting\r\n      return {\r\n        c_iflag: 25856,\r\n        c_oflag: 5,\r\n        c_cflag: 191,\r\n        c_lflag: 35387,\r\n        c_cc: [ 3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]\r\n      };\r\n    },\r\n    ioctl_tcsets(tty, optional_actions, data) {\r\n      // currently just ignore\r\n      return 0;\r\n    },\r\n    ioctl_tiocgwinsz(tty) {\r\n      return [ 24, 80 ];\r\n    }\r\n  },\r\n  default_tty1_ops: {\r\n    put_char(tty, val) {\r\n      if (val === null || val === 10) {\r\n        err(UTF8ArrayToString(tty.output));\r\n        tty.output = [];\r\n      } else {\r\n        if (val != 0) tty.output.push(val);\r\n      }\r\n    },\r\n    fsync(tty) {\r\n      if (tty.output?.length > 0) {\r\n        err(UTF8ArrayToString(tty.output));\r\n        tty.output = [];\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nvar mmapAlloc = size => {\r\n  abort(\"internal error: mmapAlloc called but `emscripten_builtin_memalign` native symbol not exported\");\r\n};\r\n\r\nvar MEMFS = {\r\n  ops_table: null,\r\n  mount(mount) {\r\n    return MEMFS.createNode(null, \"/\", 16895, 0);\r\n  },\r\n  createNode(parent, name, mode, dev) {\r\n    if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {\r\n      // no supported\r\n      throw new FS.ErrnoError(63);\r\n    }\r\n    MEMFS.ops_table ||= {\r\n      dir: {\r\n        node: {\r\n          getattr: MEMFS.node_ops.getattr,\r\n          setattr: MEMFS.node_ops.setattr,\r\n          lookup: MEMFS.node_ops.lookup,\r\n          mknod: MEMFS.node_ops.mknod,\r\n          rename: MEMFS.node_ops.rename,\r\n          unlink: MEMFS.node_ops.unlink,\r\n          rmdir: MEMFS.node_ops.rmdir,\r\n          readdir: MEMFS.node_ops.readdir,\r\n          symlink: MEMFS.node_ops.symlink\r\n        },\r\n        stream: {\r\n          llseek: MEMFS.stream_ops.llseek\r\n        }\r\n      },\r\n      file: {\r\n        node: {\r\n          getattr: MEMFS.node_ops.getattr,\r\n          setattr: MEMFS.node_ops.setattr\r\n        },\r\n        stream: {\r\n          llseek: MEMFS.stream_ops.llseek,\r\n          read: MEMFS.stream_ops.read,\r\n          write: MEMFS.stream_ops.write,\r\n          mmap: MEMFS.stream_ops.mmap,\r\n          msync: MEMFS.stream_ops.msync\r\n        }\r\n      },\r\n      link: {\r\n        node: {\r\n          getattr: MEMFS.node_ops.getattr,\r\n          setattr: MEMFS.node_ops.setattr,\r\n          readlink: MEMFS.node_ops.readlink\r\n        },\r\n        stream: {}\r\n      },\r\n      chrdev: {\r\n        node: {\r\n          getattr: MEMFS.node_ops.getattr,\r\n          setattr: MEMFS.node_ops.setattr\r\n        },\r\n        stream: FS.chrdev_stream_ops\r\n      }\r\n    };\r\n    var node = FS.createNode(parent, name, mode, dev);\r\n    if (FS.isDir(node.mode)) {\r\n      node.node_ops = MEMFS.ops_table.dir.node;\r\n      node.stream_ops = MEMFS.ops_table.dir.stream;\r\n      node.contents = {};\r\n    } else if (FS.isFile(node.mode)) {\r\n      node.node_ops = MEMFS.ops_table.file.node;\r\n      node.stream_ops = MEMFS.ops_table.file.stream;\r\n      node.usedBytes = 0;\r\n      // The actual number of bytes used in the typed array, as opposed to contents.length which gives the whole capacity.\r\n      // When the byte data of the file is populated, this will point to either a typed array, or a normal JS array. Typed arrays are preferred\r\n      // for performance, and used by default. However, typed arrays are not resizable like normal JS arrays are, so there is a small disk size\r\n      // penalty involved for appending file writes that continuously grow a file similar to std::vector capacity vs used -scheme.\r\n      node.contents = null;\r\n    } else if (FS.isLink(node.mode)) {\r\n      node.node_ops = MEMFS.ops_table.link.node;\r\n      node.stream_ops = MEMFS.ops_table.link.stream;\r\n    } else if (FS.isChrdev(node.mode)) {\r\n      node.node_ops = MEMFS.ops_table.chrdev.node;\r\n      node.stream_ops = MEMFS.ops_table.chrdev.stream;\r\n    }\r\n    node.atime = node.mtime = node.ctime = Date.now();\r\n    // add the new node to the parent\r\n    if (parent) {\r\n      parent.contents[name] = node;\r\n      parent.atime = parent.mtime = parent.ctime = node.atime;\r\n    }\r\n    return node;\r\n  },\r\n  getFileDataAsTypedArray(node) {\r\n    if (!node.contents) return new Uint8Array(0);\r\n    if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes);\r\n    // Make sure to not return excess unused bytes.\r\n    return new Uint8Array(node.contents);\r\n  },\r\n  expandFileStorage(node, newCapacity) {\r\n    var prevCapacity = node.contents ? node.contents.length : 0;\r\n    if (prevCapacity >= newCapacity) return;\r\n    // No need to expand, the storage was already large enough.\r\n    // Don't expand strictly to the given requested limit if it's only a very small increase, but instead geometrically grow capacity.\r\n    // For small filesizes (<1MB), perform size*2 geometric increase, but for large sizes, do a much more conservative size*1.125 increase to\r\n    // avoid overshooting the allocation cap by a very large margin.\r\n    var CAPACITY_DOUBLING_MAX = 1024 * 1024;\r\n    newCapacity = Math.max(newCapacity, (prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125)) >>> 0);\r\n    if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256);\r\n    // At minimum allocate 256b for each file when expanding.\r\n    var oldContents = node.contents;\r\n    node.contents = new Uint8Array(newCapacity);\r\n    // Allocate new storage.\r\n    if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0);\r\n  },\r\n  resizeFileStorage(node, newSize) {\r\n    if (node.usedBytes == newSize) return;\r\n    if (newSize == 0) {\r\n      node.contents = null;\r\n      // Fully decommit when requesting a resize to zero.\r\n      node.usedBytes = 0;\r\n    } else {\r\n      var oldContents = node.contents;\r\n      node.contents = new Uint8Array(newSize);\r\n      // Allocate new storage.\r\n      if (oldContents) {\r\n        node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));\r\n      }\r\n      node.usedBytes = newSize;\r\n    }\r\n  },\r\n  node_ops: {\r\n    getattr(node) {\r\n      var attr = {};\r\n      // device numbers reuse inode numbers.\r\n      attr.dev = FS.isChrdev(node.mode) ? node.id : 1;\r\n      attr.ino = node.id;\r\n      attr.mode = node.mode;\r\n      attr.nlink = 1;\r\n      attr.uid = 0;\r\n      attr.gid = 0;\r\n      attr.rdev = node.rdev;\r\n      if (FS.isDir(node.mode)) {\r\n        attr.size = 4096;\r\n      } else if (FS.isFile(node.mode)) {\r\n        attr.size = node.usedBytes;\r\n      } else if (FS.isLink(node.mode)) {\r\n        attr.size = node.link.length;\r\n      } else {\r\n        attr.size = 0;\r\n      }\r\n      attr.atime = new Date(node.atime);\r\n      attr.mtime = new Date(node.mtime);\r\n      attr.ctime = new Date(node.ctime);\r\n      // NOTE: In our implementation, st_blocks = Math.ceil(st_size/st_blksize),\r\n      //       but this is not required by the standard.\r\n      attr.blksize = 4096;\r\n      attr.blocks = Math.ceil(attr.size / attr.blksize);\r\n      return attr;\r\n    },\r\n    setattr(node, attr) {\r\n      for (const key of [ \"mode\", \"atime\", \"mtime\", \"ctime\" ]) {\r\n        if (attr[key] != null) {\r\n          node[key] = attr[key];\r\n        }\r\n      }\r\n      if (attr.size !== undefined) {\r\n        MEMFS.resizeFileStorage(node, attr.size);\r\n      }\r\n    },\r\n    lookup(parent, name) {\r\n      throw new FS.ErrnoError(44);\r\n    },\r\n    mknod(parent, name, mode, dev) {\r\n      return MEMFS.createNode(parent, name, mode, dev);\r\n    },\r\n    rename(old_node, new_dir, new_name) {\r\n      var new_node;\r\n      try {\r\n        new_node = FS.lookupNode(new_dir, new_name);\r\n      } catch (e) {}\r\n      if (new_node) {\r\n        if (FS.isDir(old_node.mode)) {\r\n          // if we're overwriting a directory at new_name, make sure it's empty.\r\n          for (var i in new_node.contents) {\r\n            throw new FS.ErrnoError(55);\r\n          }\r\n        }\r\n        FS.hashRemoveNode(new_node);\r\n      }\r\n      // do the internal rewiring\r\n      delete old_node.parent.contents[old_node.name];\r\n      new_dir.contents[new_name] = old_node;\r\n      old_node.name = new_name;\r\n      new_dir.ctime = new_dir.mtime = old_node.parent.ctime = old_node.parent.mtime = Date.now();\r\n    },\r\n    unlink(parent, name) {\r\n      delete parent.contents[name];\r\n      parent.ctime = parent.mtime = Date.now();\r\n    },\r\n    rmdir(parent, name) {\r\n      var node = FS.lookupNode(parent, name);\r\n      for (var i in node.contents) {\r\n        throw new FS.ErrnoError(55);\r\n      }\r\n      delete parent.contents[name];\r\n      parent.ctime = parent.mtime = Date.now();\r\n    },\r\n    readdir(node) {\r\n      return [ \".\", \"..\", ...Object.keys(node.contents) ];\r\n    },\r\n    symlink(parent, newname, oldpath) {\r\n      var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);\r\n      node.link = oldpath;\r\n      return node;\r\n    },\r\n    readlink(node) {\r\n      if (!FS.isLink(node.mode)) {\r\n        throw new FS.ErrnoError(28);\r\n      }\r\n      return node.link;\r\n    }\r\n  },\r\n  stream_ops: {\r\n    read(stream, buffer, offset, length, position) {\r\n      var contents = stream.node.contents;\r\n      if (position >= stream.node.usedBytes) return 0;\r\n      var size = Math.min(stream.node.usedBytes - position, length);\r\n      assert(size >= 0);\r\n      if (size > 8 && contents.subarray) {\r\n        // non-trivial, and typed array\r\n        buffer.set(contents.subarray(position, position + size), offset);\r\n      } else {\r\n        for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];\r\n      }\r\n      return size;\r\n    },\r\n    write(stream, buffer, offset, length, position, canOwn) {\r\n      // The data buffer should be a typed array view\r\n      assert(!(buffer instanceof ArrayBuffer));\r\n      // If the buffer is located in main memory (HEAP), and if\r\n      // memory can grow, we can't hold on to references of the\r\n      // memory buffer, as they may get invalidated. That means we\r\n      // need to do copy its contents.\r\n      if (buffer.buffer === GROWABLE_HEAP_I8().buffer) {\r\n        canOwn = false;\r\n      }\r\n      if (!length) return 0;\r\n      var node = stream.node;\r\n      node.mtime = node.ctime = Date.now();\r\n      if (buffer.subarray && (!node.contents || node.contents.subarray)) {\r\n        // This write is from a typed array to a typed array?\r\n        if (canOwn) {\r\n          assert(position === 0, \"canOwn must imply no weird position inside the file\");\r\n          node.contents = buffer.subarray(offset, offset + length);\r\n          node.usedBytes = length;\r\n          return length;\r\n        } else if (node.usedBytes === 0 && position === 0) {\r\n          // If this is a simple first write to an empty file, do a fast set since we don't need to care about old data.\r\n          node.contents = buffer.slice(offset, offset + length);\r\n          node.usedBytes = length;\r\n          return length;\r\n        } else if (position + length <= node.usedBytes) {\r\n          // Writing to an already allocated and used subrange of the file?\r\n          node.contents.set(buffer.subarray(offset, offset + length), position);\r\n          return length;\r\n        }\r\n      }\r\n      // Appending to an existing file and we need to reallocate, or source data did not come as a typed array.\r\n      MEMFS.expandFileStorage(node, position + length);\r\n      if (node.contents.subarray && buffer.subarray) {\r\n        // Use typed array write which is available.\r\n        node.contents.set(buffer.subarray(offset, offset + length), position);\r\n      } else {\r\n        for (var i = 0; i < length; i++) {\r\n          node.contents[position + i] = buffer[offset + i];\r\n        }\r\n      }\r\n      node.usedBytes = Math.max(node.usedBytes, position + length);\r\n      return length;\r\n    },\r\n    llseek(stream, offset, whence) {\r\n      var position = offset;\r\n      if (whence === 1) {\r\n        position += stream.position;\r\n      } else if (whence === 2) {\r\n        if (FS.isFile(stream.node.mode)) {\r\n          position += stream.node.usedBytes;\r\n        }\r\n      }\r\n      if (position < 0) {\r\n        throw new FS.ErrnoError(28);\r\n      }\r\n      return position;\r\n    },\r\n    mmap(stream, length, position, prot, flags) {\r\n      if (!FS.isFile(stream.node.mode)) {\r\n        throw new FS.ErrnoError(43);\r\n      }\r\n      var ptr;\r\n      var allocated;\r\n      var contents = stream.node.contents;\r\n      // Only make a new copy when MAP_PRIVATE is specified.\r\n      if (!(flags & 2) && contents && contents.buffer === GROWABLE_HEAP_I8().buffer) {\r\n        // We can't emulate MAP_SHARED when the file is not backed by the\r\n        // buffer we're mapping to (e.g. the HEAP buffer).\r\n        allocated = false;\r\n        ptr = contents.byteOffset;\r\n      } else {\r\n        allocated = true;\r\n        ptr = mmapAlloc(length);\r\n        if (!ptr) {\r\n          throw new FS.ErrnoError(48);\r\n        }\r\n        if (contents) {\r\n          // Try to avoid unnecessary slices.\r\n          if (position > 0 || position + length < contents.length) {\r\n            if (contents.subarray) {\r\n              contents = contents.subarray(position, position + length);\r\n            } else {\r\n              contents = Array.prototype.slice.call(contents, position, position + length);\r\n            }\r\n          }\r\n          GROWABLE_HEAP_I8().set(contents, ptr);\r\n        }\r\n      }\r\n      return {\r\n        ptr,\r\n        allocated\r\n      };\r\n    },\r\n    msync(stream, buffer, offset, length, mmapFlags) {\r\n      MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);\r\n      // should we check if bytesWritten and length are the same?\r\n      return 0;\r\n    }\r\n  }\r\n};\r\n\r\nvar asyncLoad = async url => {\r\n  var arrayBuffer = await readAsync(url);\r\n  assert(arrayBuffer, `Loading data file \"${url}\" failed (no arrayBuffer).`);\r\n  return new Uint8Array(arrayBuffer);\r\n};\r\n\r\nvar FS_createDataFile = (...args) => FS.createDataFile(...args);\r\n\r\nvar preloadPlugins = [];\r\n\r\nvar FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror) => {\r\n  // Ensure plugins are ready.\r\n  if (typeof Browser != \"undefined\") Browser.init();\r\n  var handled = false;\r\n  preloadPlugins.forEach(plugin => {\r\n    if (handled) return;\r\n    if (plugin[\"canHandle\"](fullname)) {\r\n      plugin[\"handle\"](byteArray, fullname, finish, onerror);\r\n      handled = true;\r\n    }\r\n  });\r\n  return handled;\r\n};\r\n\r\nvar FS_createPreloadedFile = (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {\r\n  // TODO we should allow people to just pass in a complete filename instead\r\n  // of parent and name being that we just join them anyways\r\n  var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;\r\n  var dep = getUniqueRunDependency(`cp ${fullname}`);\r\n  // might have several active requests for the same fullname\r\n  function processData(byteArray) {\r\n    function finish(byteArray) {\r\n      preFinish?.();\r\n      if (!dontCreateFile) {\r\n        FS_createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);\r\n      }\r\n      onload?.();\r\n      removeRunDependency(dep);\r\n    }\r\n    if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {\r\n      onerror?.();\r\n      removeRunDependency(dep);\r\n    })) {\r\n      return;\r\n    }\r\n    finish(byteArray);\r\n  }\r\n  addRunDependency(dep);\r\n  if (typeof url == \"string\") {\r\n    asyncLoad(url).then(processData, onerror);\r\n  } else {\r\n    processData(url);\r\n  }\r\n};\r\n\r\nvar FS_modeStringToFlags = str => {\r\n  var flagModes = {\r\n    \"r\": 0,\r\n    \"r+\": 2,\r\n    \"w\": 512 | 64 | 1,\r\n    \"w+\": 512 | 64 | 2,\r\n    \"a\": 1024 | 64 | 1,\r\n    \"a+\": 1024 | 64 | 2\r\n  };\r\n  var flags = flagModes[str];\r\n  if (typeof flags == \"undefined\") {\r\n    throw new Error(`Unknown file open mode: ${str}`);\r\n  }\r\n  return flags;\r\n};\r\n\r\nvar FS_getMode = (canRead, canWrite) => {\r\n  var mode = 0;\r\n  if (canRead) mode |= 292 | 73;\r\n  if (canWrite) mode |= 146;\r\n  return mode;\r\n};\r\n\r\nvar strError = errno => UTF8ToString(_strerror(errno));\r\n\r\nvar ERRNO_CODES = {\r\n  \"EPERM\": 63,\r\n  \"ENOENT\": 44,\r\n  \"ESRCH\": 71,\r\n  \"EINTR\": 27,\r\n  \"EIO\": 29,\r\n  \"ENXIO\": 60,\r\n  \"E2BIG\": 1,\r\n  \"ENOEXEC\": 45,\r\n  \"EBADF\": 8,\r\n  \"ECHILD\": 12,\r\n  \"EAGAIN\": 6,\r\n  \"EWOULDBLOCK\": 6,\r\n  \"ENOMEM\": 48,\r\n  \"EACCES\": 2,\r\n  \"EFAULT\": 21,\r\n  \"ENOTBLK\": 105,\r\n  \"EBUSY\": 10,\r\n  \"EEXIST\": 20,\r\n  \"EXDEV\": 75,\r\n  \"ENODEV\": 43,\r\n  \"ENOTDIR\": 54,\r\n  \"EISDIR\": 31,\r\n  \"EINVAL\": 28,\r\n  \"ENFILE\": 41,\r\n  \"EMFILE\": 33,\r\n  \"ENOTTY\": 59,\r\n  \"ETXTBSY\": 74,\r\n  \"EFBIG\": 22,\r\n  \"ENOSPC\": 51,\r\n  \"ESPIPE\": 70,\r\n  \"EROFS\": 69,\r\n  \"EMLINK\": 34,\r\n  \"EPIPE\": 64,\r\n  \"EDOM\": 18,\r\n  \"ERANGE\": 68,\r\n  \"ENOMSG\": 49,\r\n  \"EIDRM\": 24,\r\n  \"ECHRNG\": 106,\r\n  \"EL2NSYNC\": 156,\r\n  \"EL3HLT\": 107,\r\n  \"EL3RST\": 108,\r\n  \"ELNRNG\": 109,\r\n  \"EUNATCH\": 110,\r\n  \"ENOCSI\": 111,\r\n  \"EL2HLT\": 112,\r\n  \"EDEADLK\": 16,\r\n  \"ENOLCK\": 46,\r\n  \"EBADE\": 113,\r\n  \"EBADR\": 114,\r\n  \"EXFULL\": 115,\r\n  \"ENOANO\": 104,\r\n  \"EBADRQC\": 103,\r\n  \"EBADSLT\": 102,\r\n  \"EDEADLOCK\": 16,\r\n  \"EBFONT\": 101,\r\n  \"ENOSTR\": 100,\r\n  \"ENODATA\": 116,\r\n  \"ETIME\": 117,\r\n  \"ENOSR\": 118,\r\n  \"ENONET\": 119,\r\n  \"ENOPKG\": 120,\r\n  \"EREMOTE\": 121,\r\n  \"ENOLINK\": 47,\r\n  \"EADV\": 122,\r\n  \"ESRMNT\": 123,\r\n  \"ECOMM\": 124,\r\n  \"EPROTO\": 65,\r\n  \"EMULTIHOP\": 36,\r\n  \"EDOTDOT\": 125,\r\n  \"EBADMSG\": 9,\r\n  \"ENOTUNIQ\": 126,\r\n  \"EBADFD\": 127,\r\n  \"EREMCHG\": 128,\r\n  \"ELIBACC\": 129,\r\n  \"ELIBBAD\": 130,\r\n  \"ELIBSCN\": 131,\r\n  \"ELIBMAX\": 132,\r\n  \"ELIBEXEC\": 133,\r\n  \"ENOSYS\": 52,\r\n  \"ENOTEMPTY\": 55,\r\n  \"ENAMETOOLONG\": 37,\r\n  \"ELOOP\": 32,\r\n  \"EOPNOTSUPP\": 138,\r\n  \"EPFNOSUPPORT\": 139,\r\n  \"ECONNRESET\": 15,\r\n  \"ENOBUFS\": 42,\r\n  \"EAFNOSUPPORT\": 5,\r\n  \"EPROTOTYPE\": 67,\r\n  \"ENOTSOCK\": 57,\r\n  \"ENOPROTOOPT\": 50,\r\n  \"ESHUTDOWN\": 140,\r\n  \"ECONNREFUSED\": 14,\r\n  \"EADDRINUSE\": 3,\r\n  \"ECONNABORTED\": 13,\r\n  \"ENETUNREACH\": 40,\r\n  \"ENETDOWN\": 38,\r\n  \"ETIMEDOUT\": 73,\r\n  \"EHOSTDOWN\": 142,\r\n  \"EHOSTUNREACH\": 23,\r\n  \"EINPROGRESS\": 26,\r\n  \"EALREADY\": 7,\r\n  \"EDESTADDRREQ\": 17,\r\n  \"EMSGSIZE\": 35,\r\n  \"EPROTONOSUPPORT\": 66,\r\n  \"ESOCKTNOSUPPORT\": 137,\r\n  \"EADDRNOTAVAIL\": 4,\r\n  \"ENETRESET\": 39,\r\n  \"EISCONN\": 30,\r\n  \"ENOTCONN\": 53,\r\n  \"ETOOMANYREFS\": 141,\r\n  \"EUSERS\": 136,\r\n  \"EDQUOT\": 19,\r\n  \"ESTALE\": 72,\r\n  \"ENOTSUP\": 138,\r\n  \"ENOMEDIUM\": 148,\r\n  \"EILSEQ\": 25,\r\n  \"EOVERFLOW\": 61,\r\n  \"ECANCELED\": 11,\r\n  \"ENOTRECOVERABLE\": 56,\r\n  \"EOWNERDEAD\": 62,\r\n  \"ESTRPIPE\": 135\r\n};\r\n\r\nvar FS = {\r\n  root: null,\r\n  mounts: [],\r\n  devices: {},\r\n  streams: [],\r\n  nextInode: 1,\r\n  nameTable: null,\r\n  currentPath: \"/\",\r\n  initialized: false,\r\n  ignorePermissions: true,\r\n  filesystems: null,\r\n  syncFSRequests: 0,\r\n  ErrnoError: class extends Error {\r\n    name=\"ErrnoError\";\r\n    // We set the `name` property to be able to identify `FS.ErrnoError`\r\n    // - the `name` is a standard ECMA-262 property of error objects. Kind of good to have it anyway.\r\n    // - when using PROXYFS, an error can come from an underlying FS\r\n    // as different FS objects have their own FS.ErrnoError each,\r\n    // the test `err instanceof FS.ErrnoError` won't detect an error coming from another filesystem, causing bugs.\r\n    // we'll use the reliable test `err.name == \"ErrnoError\"` instead\r\n    constructor(errno) {\r\n      super(runtimeInitialized ? strError(errno) : \"\");\r\n      this.errno = errno;\r\n      for (var key in ERRNO_CODES) {\r\n        if (ERRNO_CODES[key] === errno) {\r\n          this.code = key;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  },\r\n  FSStream: class {\r\n    shared={};\r\n    get object() {\r\n      return this.node;\r\n    }\r\n    set object(val) {\r\n      this.node = val;\r\n    }\r\n    get isRead() {\r\n      return (this.flags & 2097155) !== 1;\r\n    }\r\n    get isWrite() {\r\n      return (this.flags & 2097155) !== 0;\r\n    }\r\n    get isAppend() {\r\n      return (this.flags & 1024);\r\n    }\r\n    get flags() {\r\n      return this.shared.flags;\r\n    }\r\n    set flags(val) {\r\n      this.shared.flags = val;\r\n    }\r\n    get position() {\r\n      return this.shared.position;\r\n    }\r\n    set position(val) {\r\n      this.shared.position = val;\r\n    }\r\n  },\r\n  FSNode: class {\r\n    node_ops={};\r\n    stream_ops={};\r\n    readMode=292 | 73;\r\n    writeMode=146;\r\n    mounted=null;\r\n    constructor(parent, name, mode, rdev) {\r\n      if (!parent) {\r\n        parent = this;\r\n      }\r\n      this.parent = parent;\r\n      this.mount = parent.mount;\r\n      this.id = FS.nextInode++;\r\n      this.name = name;\r\n      this.mode = mode;\r\n      this.rdev = rdev;\r\n      this.atime = this.mtime = this.ctime = Date.now();\r\n    }\r\n    get read() {\r\n      return (this.mode & this.readMode) === this.readMode;\r\n    }\r\n    set read(val) {\r\n      val ? this.mode |= this.readMode : this.mode &= ~this.readMode;\r\n    }\r\n    get write() {\r\n      return (this.mode & this.writeMode) === this.writeMode;\r\n    }\r\n    set write(val) {\r\n      val ? this.mode |= this.writeMode : this.mode &= ~this.writeMode;\r\n    }\r\n    get isFolder() {\r\n      return FS.isDir(this.mode);\r\n    }\r\n    get isDevice() {\r\n      return FS.isChrdev(this.mode);\r\n    }\r\n  },\r\n  lookupPath(path, opts = {}) {\r\n    if (!path) {\r\n      throw new FS.ErrnoError(44);\r\n    }\r\n    opts.follow_mount ??= true;\r\n    if (!PATH.isAbs(path)) {\r\n      path = FS.cwd() + \"/\" + path;\r\n    }\r\n    // limit max consecutive symlinks to 40 (SYMLOOP_MAX).\r\n    linkloop: for (var nlinks = 0; nlinks < 40; nlinks++) {\r\n      // split the absolute path\r\n      var parts = path.split(\"/\").filter(p => !!p);\r\n      // start at the root\r\n      var current = FS.root;\r\n      var current_path = \"/\";\r\n      for (var i = 0; i < parts.length; i++) {\r\n        var islast = (i === parts.length - 1);\r\n        if (islast && opts.parent) {\r\n          // stop resolving\r\n          break;\r\n        }\r\n        if (parts[i] === \".\") {\r\n          continue;\r\n        }\r\n        if (parts[i] === \"..\") {\r\n          current_path = PATH.dirname(current_path);\r\n          if (FS.isRoot(current)) {\r\n            path = current_path + \"/\" + parts.slice(i + 1).join(\"/\");\r\n            continue linkloop;\r\n          } else {\r\n            current = current.parent;\r\n          }\r\n          continue;\r\n        }\r\n        current_path = PATH.join2(current_path, parts[i]);\r\n        try {\r\n          current = FS.lookupNode(current, parts[i]);\r\n        } catch (e) {\r\n          // if noent_okay is true, suppress a ENOENT in the last component\r\n          // and return an object with an undefined node. This is needed for\r\n          // resolving symlinks in the path when creating a file.\r\n          if ((e?.errno === 44) && islast && opts.noent_okay) {\r\n            return {\r\n              path: current_path\r\n            };\r\n          }\r\n          throw e;\r\n        }\r\n        // jump to the mount's root node if this is a mountpoint\r\n        if (FS.isMountpoint(current) && (!islast || opts.follow_mount)) {\r\n          current = current.mounted.root;\r\n        }\r\n        // by default, lookupPath will not follow a symlink if it is the final path component.\r\n        // setting opts.follow = true will override this behavior.\r\n        if (FS.isLink(current.mode) && (!islast || opts.follow)) {\r\n          if (!current.node_ops.readlink) {\r\n            throw new FS.ErrnoError(52);\r\n          }\r\n          var link = current.node_ops.readlink(current);\r\n          if (!PATH.isAbs(link)) {\r\n            link = PATH.dirname(current_path) + \"/\" + link;\r\n          }\r\n          path = link + \"/\" + parts.slice(i + 1).join(\"/\");\r\n          continue linkloop;\r\n        }\r\n      }\r\n      return {\r\n        path: current_path,\r\n        node: current\r\n      };\r\n    }\r\n    throw new FS.ErrnoError(32);\r\n  },\r\n  getPath(node) {\r\n    var path;\r\n    while (true) {\r\n      if (FS.isRoot(node)) {\r\n        var mount = node.mount.mountpoint;\r\n        if (!path) return mount;\r\n        return mount[mount.length - 1] !== \"/\" ? `${mount}/${path}` : mount + path;\r\n      }\r\n      path = path ? `${node.name}/${path}` : node.name;\r\n      node = node.parent;\r\n    }\r\n  },\r\n  hashName(parentid, name) {\r\n    var hash = 0;\r\n    for (var i = 0; i < name.length; i++) {\r\n      hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;\r\n    }\r\n    return ((parentid + hash) >>> 0) % FS.nameTable.length;\r\n  },\r\n  hashAddNode(node) {\r\n    var hash = FS.hashName(node.parent.id, node.name);\r\n    node.name_next = FS.nameTable[hash];\r\n    FS.nameTable[hash] = node;\r\n  },\r\n  hashRemoveNode(node) {\r\n    var hash = FS.hashName(node.parent.id, node.name);\r\n    if (FS.nameTable[hash] === node) {\r\n      FS.nameTable[hash] = node.name_next;\r\n    } else {\r\n      var current = FS.nameTable[hash];\r\n      while (current) {\r\n        if (current.name_next === node) {\r\n          current.name_next = node.name_next;\r\n          break;\r\n        }\r\n        current = current.name_next;\r\n      }\r\n    }\r\n  },\r\n  lookupNode(parent, name) {\r\n    var errCode = FS.mayLookup(parent);\r\n    if (errCode) {\r\n      throw new FS.ErrnoError(errCode);\r\n    }\r\n    var hash = FS.hashName(parent.id, name);\r\n    for (var node = FS.nameTable[hash]; node; node = node.name_next) {\r\n      var nodeName = node.name;\r\n      if (node.parent.id === parent.id && nodeName === name) {\r\n        return node;\r\n      }\r\n    }\r\n    // if we failed to find it in the cache, call into the VFS\r\n    return FS.lookup(parent, name);\r\n  },\r\n  createNode(parent, name, mode, rdev) {\r\n    assert(typeof parent == \"object\");\r\n    var node = new FS.FSNode(parent, name, mode, rdev);\r\n    FS.hashAddNode(node);\r\n    return node;\r\n  },\r\n  destroyNode(node) {\r\n    FS.hashRemoveNode(node);\r\n  },\r\n  isRoot(node) {\r\n    return node === node.parent;\r\n  },\r\n  isMountpoint(node) {\r\n    return !!node.mounted;\r\n  },\r\n  isFile(mode) {\r\n    return (mode & 61440) === 32768;\r\n  },\r\n  isDir(mode) {\r\n    return (mode & 61440) === 16384;\r\n  },\r\n  isLink(mode) {\r\n    return (mode & 61440) === 40960;\r\n  },\r\n  isChrdev(mode) {\r\n    return (mode & 61440) === 8192;\r\n  },\r\n  isBlkdev(mode) {\r\n    return (mode & 61440) === 24576;\r\n  },\r\n  isFIFO(mode) {\r\n    return (mode & 61440) === 4096;\r\n  },\r\n  isSocket(mode) {\r\n    return (mode & 49152) === 49152;\r\n  },\r\n  flagsToPermissionString(flag) {\r\n    var perms = [ \"r\", \"w\", \"rw\" ][flag & 3];\r\n    if ((flag & 512)) {\r\n      perms += \"w\";\r\n    }\r\n    return perms;\r\n  },\r\n  nodePermissions(node, perms) {\r\n    if (FS.ignorePermissions) {\r\n      return 0;\r\n    }\r\n    // return 0 if any user, group or owner bits are set.\r\n    if (perms.includes(\"r\") && !(node.mode & 292)) {\r\n      return 2;\r\n    } else if (perms.includes(\"w\") && !(node.mode & 146)) {\r\n      return 2;\r\n    } else if (perms.includes(\"x\") && !(node.mode & 73)) {\r\n      return 2;\r\n    }\r\n    return 0;\r\n  },\r\n  mayLookup(dir) {\r\n    if (!FS.isDir(dir.mode)) return 54;\r\n    var errCode = FS.nodePermissions(dir, \"x\");\r\n    if (errCode) return errCode;\r\n    if (!dir.node_ops.lookup) return 2;\r\n    return 0;\r\n  },\r\n  mayCreate(dir, name) {\r\n    if (!FS.isDir(dir.mode)) {\r\n      return 54;\r\n    }\r\n    try {\r\n      var node = FS.lookupNode(dir, name);\r\n      return 20;\r\n    } catch (e) {}\r\n    return FS.nodePermissions(dir, \"wx\");\r\n  },\r\n  mayDelete(dir, name, isdir) {\r\n    var node;\r\n    try {\r\n      node = FS.lookupNode(dir, name);\r\n    } catch (e) {\r\n      return e.errno;\r\n    }\r\n    var errCode = FS.nodePermissions(dir, \"wx\");\r\n    if (errCode) {\r\n      return errCode;\r\n    }\r\n    if (isdir) {\r\n      if (!FS.isDir(node.mode)) {\r\n        return 54;\r\n      }\r\n      if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {\r\n        return 10;\r\n      }\r\n    } else {\r\n      if (FS.isDir(node.mode)) {\r\n        return 31;\r\n      }\r\n    }\r\n    return 0;\r\n  },\r\n  mayOpen(node, flags) {\r\n    if (!node) {\r\n      return 44;\r\n    }\r\n    if (FS.isLink(node.mode)) {\r\n      return 32;\r\n    } else if (FS.isDir(node.mode)) {\r\n      if (FS.flagsToPermissionString(flags) !== \"r\" || (flags & (512 | 64))) {\r\n        // TODO: check for O_SEARCH? (== search for dir only)\r\n        return 31;\r\n      }\r\n    }\r\n    return FS.nodePermissions(node, FS.flagsToPermissionString(flags));\r\n  },\r\n  checkOpExists(op, err) {\r\n    if (!op) {\r\n      throw new FS.ErrnoError(err);\r\n    }\r\n    return op;\r\n  },\r\n  MAX_OPEN_FDS: 4096,\r\n  nextfd() {\r\n    for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {\r\n      if (!FS.streams[fd]) {\r\n        return fd;\r\n      }\r\n    }\r\n    throw new FS.ErrnoError(33);\r\n  },\r\n  getStreamChecked(fd) {\r\n    var stream = FS.getStream(fd);\r\n    if (!stream) {\r\n      throw new FS.ErrnoError(8);\r\n    }\r\n    return stream;\r\n  },\r\n  getStream: fd => FS.streams[fd],\r\n  createStream(stream, fd = -1) {\r\n    assert(fd >= -1);\r\n    // clone it, so we can return an instance of FSStream\r\n    stream = Object.assign(new FS.FSStream, stream);\r\n    if (fd == -1) {\r\n      fd = FS.nextfd();\r\n    }\r\n    stream.fd = fd;\r\n    FS.streams[fd] = stream;\r\n    return stream;\r\n  },\r\n  closeStream(fd) {\r\n    FS.streams[fd] = null;\r\n  },\r\n  dupStream(origStream, fd = -1) {\r\n    var stream = FS.createStream(origStream, fd);\r\n    stream.stream_ops?.dup?.(stream);\r\n    return stream;\r\n  },\r\n  doSetAttr(stream, node, attr) {\r\n    var setattr = stream?.stream_ops.setattr;\r\n    var arg = setattr ? stream : node;\r\n    setattr ??= node.node_ops.setattr;\r\n    FS.checkOpExists(setattr, 63);\r\n    setattr(arg, attr);\r\n  },\r\n  chrdev_stream_ops: {\r\n    open(stream) {\r\n      var device = FS.getDevice(stream.node.rdev);\r\n      // override node's stream ops with the device's\r\n      stream.stream_ops = device.stream_ops;\r\n      // forward the open call\r\n      stream.stream_ops.open?.(stream);\r\n    },\r\n    llseek() {\r\n      throw new FS.ErrnoError(70);\r\n    }\r\n  },\r\n  major: dev => ((dev) >> 8),\r\n  minor: dev => ((dev) & 255),\r\n  makedev: (ma, mi) => ((ma) << 8 | (mi)),\r\n  registerDevice(dev, ops) {\r\n    FS.devices[dev] = {\r\n      stream_ops: ops\r\n    };\r\n  },\r\n  getDevice: dev => FS.devices[dev],\r\n  getMounts(mount) {\r\n    var mounts = [];\r\n    var check = [ mount ];\r\n    while (check.length) {\r\n      var m = check.pop();\r\n      mounts.push(m);\r\n      check.push(...m.mounts);\r\n    }\r\n    return mounts;\r\n  },\r\n  syncfs(populate, callback) {\r\n    if (typeof populate == \"function\") {\r\n      callback = populate;\r\n      populate = false;\r\n    }\r\n    FS.syncFSRequests++;\r\n    if (FS.syncFSRequests > 1) {\r\n      err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`);\r\n    }\r\n    var mounts = FS.getMounts(FS.root.mount);\r\n    var completed = 0;\r\n    function doCallback(errCode) {\r\n      assert(FS.syncFSRequests > 0);\r\n      FS.syncFSRequests--;\r\n      return callback(errCode);\r\n    }\r\n    function done(errCode) {\r\n      if (errCode) {\r\n        if (!done.errored) {\r\n          done.errored = true;\r\n          return doCallback(errCode);\r\n        }\r\n        return;\r\n      }\r\n      if (++completed >= mounts.length) {\r\n        doCallback(null);\r\n      }\r\n    }\r\n    // sync all mounts\r\n    mounts.forEach(mount => {\r\n      if (!mount.type.syncfs) {\r\n        return done(null);\r\n      }\r\n      mount.type.syncfs(mount, populate, done);\r\n    });\r\n  },\r\n  mount(type, opts, mountpoint) {\r\n    if (typeof type == \"string\") {\r\n      // The filesystem was not included, and instead we have an error\r\n      // message stored in the variable.\r\n      throw type;\r\n    }\r\n    var root = mountpoint === \"/\";\r\n    var pseudo = !mountpoint;\r\n    var node;\r\n    if (root && FS.root) {\r\n      throw new FS.ErrnoError(10);\r\n    } else if (!root && !pseudo) {\r\n      var lookup = FS.lookupPath(mountpoint, {\r\n        follow_mount: false\r\n      });\r\n      mountpoint = lookup.path;\r\n      // use the absolute path\r\n      node = lookup.node;\r\n      if (FS.isMountpoint(node)) {\r\n        throw new FS.ErrnoError(10);\r\n      }\r\n      if (!FS.isDir(node.mode)) {\r\n        throw new FS.ErrnoError(54);\r\n      }\r\n    }\r\n    var mount = {\r\n      type,\r\n      opts,\r\n      mountpoint,\r\n      mounts: []\r\n    };\r\n    // create a root node for the fs\r\n    var mountRoot = type.mount(mount);\r\n    mountRoot.mount = mount;\r\n    mount.root = mountRoot;\r\n    if (root) {\r\n      FS.root = mountRoot;\r\n    } else if (node) {\r\n      // set as a mountpoint\r\n      node.mounted = mount;\r\n      // add the new mount to the current mount's children\r\n      if (node.mount) {\r\n        node.mount.mounts.push(mount);\r\n      }\r\n    }\r\n    return mountRoot;\r\n  },\r\n  unmount(mountpoint) {\r\n    var lookup = FS.lookupPath(mountpoint, {\r\n      follow_mount: false\r\n    });\r\n    if (!FS.isMountpoint(lookup.node)) {\r\n      throw new FS.ErrnoError(28);\r\n    }\r\n    // destroy the nodes for this mount, and all its child mounts\r\n    var node = lookup.node;\r\n    var mount = node.mounted;\r\n    var mounts = FS.getMounts(mount);\r\n    Object.keys(FS.nameTable).forEach(hash => {\r\n      var current = FS.nameTable[hash];\r\n      while (current) {\r\n        var next = current.name_next;\r\n        if (mounts.includes(current.mount)) {\r\n          FS.destroyNode(current);\r\n        }\r\n        current = next;\r\n      }\r\n    });\r\n    // no longer a mountpoint\r\n    node.mounted = null;\r\n    // remove this mount from the child mounts\r\n    var idx = node.mount.mounts.indexOf(mount);\r\n    assert(idx !== -1);\r\n    node.mount.mounts.splice(idx, 1);\r\n  },\r\n  lookup(parent, name) {\r\n    return parent.node_ops.lookup(parent, name);\r\n  },\r\n  mknod(path, mode, dev) {\r\n    var lookup = FS.lookupPath(path, {\r\n      parent: true\r\n    });\r\n    var parent = lookup.node;\r\n    var name = PATH.basename(path);\r\n    if (!name) {\r\n      throw new FS.ErrnoError(28);\r\n    }\r\n    if (name === \".\" || name === \"..\") {\r\n      throw new FS.ErrnoError(20);\r\n    }\r\n    var errCode = FS.mayCreate(parent, name);\r\n    if (errCode) {\r\n      throw new FS.ErrnoError(errCode);\r\n    }\r\n    if (!parent.node_ops.mknod) {\r\n      throw new FS.ErrnoError(63);\r\n    }\r\n    return parent.node_ops.mknod(parent, name, mode, dev);\r\n  },\r\n  statfs(path) {\r\n    return FS.statfsNode(FS.lookupPath(path, {\r\n      follow: true\r\n    }).node);\r\n  },\r\n  statfsStream(stream) {\r\n    // We keep a separate statfsStream function because noderawfs overrides\r\n    // it. In noderawfs, stream.node is sometimes null. Instead, we need to\r\n    // look at stream.path.\r\n    return FS.statfsNode(stream.node);\r\n  },\r\n  statfsNode(node) {\r\n    // NOTE: None of the defaults here are true. We're just returning safe and\r\n    //       sane values. Currently nodefs and rawfs replace these defaults,\r\n    //       other file systems leave them alone.\r\n    var rtn = {\r\n      bsize: 4096,\r\n      frsize: 4096,\r\n      blocks: 1e6,\r\n      bfree: 5e5,\r\n      bavail: 5e5,\r\n      files: FS.nextInode,\r\n      ffree: FS.nextInode - 1,\r\n      fsid: 42,\r\n      flags: 2,\r\n      namelen: 255\r\n    };\r\n    if (node.node_ops.statfs) {\r\n      Object.assign(rtn, node.node_ops.statfs(node.mount.opts.root));\r\n    }\r\n    return rtn;\r\n  },\r\n  create(path, mode = 438) {\r\n    mode &= 4095;\r\n    mode |= 32768;\r\n    return FS.mknod(path, mode, 0);\r\n  },\r\n  mkdir(path, mode = 511) {\r\n    mode &= 511 | 512;\r\n    mode |= 16384;\r\n    return FS.mknod(path, mode, 0);\r\n  },\r\n  mkdirTree(path, mode) {\r\n    var dirs = path.split(\"/\");\r\n    var d = \"\";\r\n    for (var dir of dirs) {\r\n      if (!dir) continue;\r\n      if (d || PATH.isAbs(path)) d += \"/\";\r\n      d += dir;\r\n      try {\r\n        FS.mkdir(d, mode);\r\n      } catch (e) {\r\n        if (e.errno != 20) throw e;\r\n      }\r\n    }\r\n  },\r\n  mkdev(path, mode, dev) {\r\n    if (typeof dev == \"undefined\") {\r\n      dev = mode;\r\n      mode = 438;\r\n    }\r\n    mode |= 8192;\r\n    return FS.mknod(path, mode, dev);\r\n  },\r\n  symlink(oldpath, newpath) {\r\n    if (!PATH_FS.resolve(oldpath)) {\r\n      throw new FS.ErrnoError(44);\r\n    }\r\n    var lookup = FS.lookupPath(newpath, {\r\n      parent: true\r\n    });\r\n    var parent = lookup.node;\r\n    if (!parent) {\r\n      throw new FS.ErrnoError(44);\r\n    }\r\n    var newname = PATH.basename(newpath);\r\n    var errCode = FS.mayCreate(parent, newname);\r\n    if (errCode) {\r\n      throw new FS.ErrnoError(errCode);\r\n    }\r\n    if (!parent.node_ops.symlink) {\r\n      throw new FS.ErrnoError(63);\r\n    }\r\n    return parent.node_ops.symlink(parent, newname, oldpath);\r\n  },\r\n  rename(old_path, new_path) {\r\n    var old_dirname = PATH.dirname(old_path);\r\n    var new_dirname = PATH.dirname(new_path);\r\n    var old_name = PATH.basename(old_path);\r\n    var new_name = PATH.basename(new_path);\r\n    // parents must exist\r\n    var lookup, old_dir, new_dir;\r\n    // let the errors from non existent directories percolate up\r\n    lookup = FS.lookupPath(old_path, {\r\n      parent: true\r\n    });\r\n    old_dir = lookup.node;\r\n    lookup = FS.lookupPath(new_path, {\r\n      parent: true\r\n    });\r\n    new_dir = lookup.node;\r\n    if (!old_dir || !new_dir) throw new FS.ErrnoError(44);\r\n    // need to be part of the same mount\r\n    if (old_dir.mount !== new_dir.mount) {\r\n      throw new FS.ErrnoError(75);\r\n    }\r\n    // source must exist\r\n    var old_node = FS.lookupNode(old_dir, old_name);\r\n    // old path should not be an ancestor of the new path\r\n    var relative = PATH_FS.relative(old_path, new_dirname);\r\n    if (relative.charAt(0) !== \".\") {\r\n      throw new FS.ErrnoError(28);\r\n    }\r\n    // new path should not be an ancestor of the old path\r\n    relative = PATH_FS.relative(new_path, old_dirname);\r\n    if (relative.charAt(0) !== \".\") {\r\n      throw new FS.ErrnoError(55);\r\n    }\r\n    // see if the new path already exists\r\n    var new_node;\r\n    try {\r\n      new_node = FS.lookupNode(new_dir, new_name);\r\n    } catch (e) {}\r\n    // early out if nothing needs to change\r\n    if (old_node === new_node) {\r\n      return;\r\n    }\r\n    // we'll need to delete the old entry\r\n    var isdir = FS.isDir(old_node.mode);\r\n    var errCode = FS.mayDelete(old_dir, old_name, isdir);\r\n    if (errCode) {\r\n      throw new FS.ErrnoError(errCode);\r\n    }\r\n    // need delete permissions if we'll be overwriting.\r\n    // need create permissions if new doesn't already exist.\r\n    errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);\r\n    if (errCode) {\r\n      throw new FS.ErrnoError(errCode);\r\n    }\r\n    if (!old_dir.node_ops.rename) {\r\n      throw new FS.ErrnoError(63);\r\n    }\r\n    if (FS.isMountpoint(old_node) || (new_node && FS.isMountpoint(new_node))) {\r\n      throw new FS.ErrnoError(10);\r\n    }\r\n    // if we are going to change the parent, check write permissions\r\n    if (new_dir !== old_dir) {\r\n      errCode = FS.nodePermissions(old_dir, \"w\");\r\n      if (errCode) {\r\n        throw new FS.ErrnoError(errCode);\r\n      }\r\n    }\r\n    // remove the node from the lookup hash\r\n    FS.hashRemoveNode(old_node);\r\n    // do the underlying fs rename\r\n    try {\r\n      old_dir.node_ops.rename(old_node, new_dir, new_name);\r\n      // update old node (we do this here to avoid each backend\r\n      // needing to)\r\n      old_node.parent = new_dir;\r\n    } catch (e) {\r\n      throw e;\r\n    } finally {\r\n      // add the node back to the hash (in case node_ops.rename\r\n      // changed its name)\r\n      FS.hashAddNode(old_node);\r\n    }\r\n  },\r\n  rmdir(path) {\r\n    var lookup = FS.lookupPath(path, {\r\n      parent: true\r\n    });\r\n    var parent = lookup.node;\r\n    var name = PATH.basename(path);\r\n    var node = FS.lookupNode(parent, name);\r\n    var errCode = FS.mayDelete(parent, name, true);\r\n    if (errCode) {\r\n      throw new FS.ErrnoError(errCode);\r\n    }\r\n    if (!parent.node_ops.rmdir) {\r\n      throw new FS.ErrnoError(63);\r\n    }\r\n    if (FS.isMountpoint(node)) {\r\n      throw new FS.ErrnoError(10);\r\n    }\r\n    parent.node_ops.rmdir(parent, name);\r\n    FS.destroyNode(node);\r\n  },\r\n  readdir(path) {\r\n    var lookup = FS.lookupPath(path, {\r\n      follow: true\r\n    });\r\n    var node = lookup.node;\r\n    var readdir = FS.checkOpExists(node.node_ops.readdir, 54);\r\n    return readdir(node);\r\n  },\r\n  unlink(path) {\r\n    var lookup = FS.lookupPath(path, {\r\n      parent: true\r\n    });\r\n    var parent = lookup.node;\r\n    if (!parent) {\r\n      throw new FS.ErrnoError(44);\r\n    }\r\n    var name = PATH.basename(path);\r\n    var node = FS.lookupNode(parent, name);\r\n    var errCode = FS.mayDelete(parent, name, false);\r\n    if (errCode) {\r\n      // According to POSIX, we should map EISDIR to EPERM, but\r\n      // we instead do what Linux does (and we must, as we use\r\n      // the musl linux libc).\r\n      throw new FS.ErrnoError(errCode);\r\n    }\r\n    if (!parent.node_ops.unlink) {\r\n      throw new FS.ErrnoError(63);\r\n    }\r\n    if (FS.isMountpoint(node)) {\r\n      throw new FS.ErrnoError(10);\r\n    }\r\n    parent.node_ops.unlink(parent, name);\r\n    FS.destroyNode(node);\r\n  },\r\n  readlink(path) {\r\n    var lookup = FS.lookupPath(path);\r\n    var link = lookup.node;\r\n    if (!link) {\r\n      throw new FS.ErrnoError(44);\r\n    }\r\n    if (!link.node_ops.readlink) {\r\n      throw new FS.ErrnoError(28);\r\n    }\r\n    return link.node_ops.readlink(link);\r\n  },\r\n  stat(path, dontFollow) {\r\n    var lookup = FS.lookupPath(path, {\r\n      follow: !dontFollow\r\n    });\r\n    var node = lookup.node;\r\n    var getattr = FS.checkOpExists(node.node_ops.getattr, 63);\r\n    return getattr(node);\r\n  },\r\n  fstat(fd) {\r\n    var stream = FS.getStreamChecked(fd);\r\n    var node = stream.node;\r\n    var getattr = stream.stream_ops.getattr;\r\n    var arg = getattr ? stream : node;\r\n    getattr ??= node.node_ops.getattr;\r\n    FS.checkOpExists(getattr, 63);\r\n    return getattr(arg);\r\n  },\r\n  lstat(path) {\r\n    return FS.stat(path, true);\r\n  },\r\n  doChmod(stream, node, mode, dontFollow) {\r\n    FS.doSetAttr(stream, node, {\r\n      mode: (mode & 4095) | (node.mode & ~4095),\r\n      ctime: Date.now(),\r\n      dontFollow\r\n    });\r\n  },\r\n  chmod(path, mode, dontFollow) {\r\n    var node;\r\n    if (typeof path == \"string\") {\r\n      var lookup = FS.lookupPath(path, {\r\n        follow: !dontFollow\r\n      });\r\n      node = lookup.node;\r\n    } else {\r\n      node = path;\r\n    }\r\n    FS.doChmod(null, node, mode, dontFollow);\r\n  },\r\n  lchmod(path, mode) {\r\n    FS.chmod(path, mode, true);\r\n  },\r\n  fchmod(fd, mode) {\r\n    var stream = FS.getStreamChecked(fd);\r\n    FS.doChmod(stream, stream.node, mode, false);\r\n  },\r\n  doChown(stream, node, dontFollow) {\r\n    FS.doSetAttr(stream, node, {\r\n      timestamp: Date.now(),\r\n      dontFollow\r\n    });\r\n  },\r\n  chown(path, uid, gid, dontFollow) {\r\n    var node;\r\n    if (typeof path == \"string\") {\r\n      var lookup = FS.lookupPath(path, {\r\n        follow: !dontFollow\r\n      });\r\n      node = lookup.node;\r\n    } else {\r\n      node = path;\r\n    }\r\n    FS.doChown(null, node, dontFollow);\r\n  },\r\n  lchown(path, uid, gid) {\r\n    FS.chown(path, uid, gid, true);\r\n  },\r\n  fchown(fd, uid, gid) {\r\n    var stream = FS.getStreamChecked(fd);\r\n    FS.doChown(stream, stream.node, false);\r\n  },\r\n  doTruncate(stream, node, len) {\r\n    if (FS.isDir(node.mode)) {\r\n      throw new FS.ErrnoError(31);\r\n    }\r\n    if (!FS.isFile(node.mode)) {\r\n      throw new FS.ErrnoError(28);\r\n    }\r\n    var errCode = FS.nodePermissions(node, \"w\");\r\n    if (errCode) {\r\n      throw new FS.ErrnoError(errCode);\r\n    }\r\n    FS.doSetAttr(stream, node, {\r\n      size: len,\r\n      timestamp: Date.now()\r\n    });\r\n  },\r\n  truncate(path, len) {\r\n    if (len < 0) {\r\n      throw new FS.ErrnoError(28);\r\n    }\r\n    var node;\r\n    if (typeof path == \"string\") {\r\n      var lookup = FS.lookupPath(path, {\r\n        follow: true\r\n      });\r\n      node = lookup.node;\r\n    } else {\r\n      node = path;\r\n    }\r\n    FS.doTruncate(null, node, len);\r\n  },\r\n  ftruncate(fd, len) {\r\n    var stream = FS.getStreamChecked(fd);\r\n    if (len < 0 || (stream.flags & 2097155) === 0) {\r\n      throw new FS.ErrnoError(28);\r\n    }\r\n    FS.doTruncate(stream, stream.node, len);\r\n  },\r\n  utime(path, atime, mtime) {\r\n    var lookup = FS.lookupPath(path, {\r\n      follow: true\r\n    });\r\n    var node = lookup.node;\r\n    var setattr = FS.checkOpExists(node.node_ops.setattr, 63);\r\n    setattr(node, {\r\n      atime,\r\n      mtime\r\n    });\r\n  },\r\n  open(path, flags, mode = 438) {\r\n    if (path === \"\") {\r\n      throw new FS.ErrnoError(44);\r\n    }\r\n    flags = typeof flags == \"string\" ? FS_modeStringToFlags(flags) : flags;\r\n    if ((flags & 64)) {\r\n      mode = (mode & 4095) | 32768;\r\n    } else {\r\n      mode = 0;\r\n    }\r\n    var node;\r\n    var isDirPath;\r\n    if (typeof path == \"object\") {\r\n      node = path;\r\n    } else {\r\n      isDirPath = path.endsWith(\"/\");\r\n      // noent_okay makes it so that if the final component of the path\r\n      // doesn't exist, lookupPath returns `node: undefined`. `path` will be\r\n      // updated to point to the target of all symlinks.\r\n      var lookup = FS.lookupPath(path, {\r\n        follow: !(flags & 131072),\r\n        noent_okay: true\r\n      });\r\n      node = lookup.node;\r\n      path = lookup.path;\r\n    }\r\n    // perhaps we need to create the node\r\n    var created = false;\r\n    if ((flags & 64)) {\r\n      if (node) {\r\n        // if O_CREAT and O_EXCL are set, error out if the node already exists\r\n        if ((flags & 128)) {\r\n          throw new FS.ErrnoError(20);\r\n        }\r\n      } else if (isDirPath) {\r\n        throw new FS.ErrnoError(31);\r\n      } else {\r\n        // node doesn't exist, try to create it\r\n        // Ignore the permission bits here to ensure we can `open` this new\r\n        // file below. We use chmod below the apply the permissions once the\r\n        // file is open.\r\n        node = FS.mknod(path, mode | 511, 0);\r\n        created = true;\r\n      }\r\n    }\r\n    if (!node) {\r\n      throw new FS.ErrnoError(44);\r\n    }\r\n    // can't truncate a device\r\n    if (FS.isChrdev(node.mode)) {\r\n      flags &= ~512;\r\n    }\r\n    // if asked only for a directory, then this must be one\r\n    if ((flags & 65536) && !FS.isDir(node.mode)) {\r\n      throw new FS.ErrnoError(54);\r\n    }\r\n    // check permissions, if this is not a file we just created now (it is ok to\r\n    // create and write to a file with read-only permissions; it is read-only\r\n    // for later use)\r\n    if (!created) {\r\n      var errCode = FS.mayOpen(node, flags);\r\n      if (errCode) {\r\n        throw new FS.ErrnoError(errCode);\r\n      }\r\n    }\r\n    // do truncation if necessary\r\n    if ((flags & 512) && !created) {\r\n      FS.truncate(node, 0);\r\n    }\r\n    // we've already handled these, don't pass down to the underlying vfs\r\n    flags &= ~(128 | 512 | 131072);\r\n    // register the stream with the filesystem\r\n    var stream = FS.createStream({\r\n      node,\r\n      path: FS.getPath(node),\r\n      // we want the absolute path to the node\r\n      flags,\r\n      seekable: true,\r\n      position: 0,\r\n      stream_ops: node.stream_ops,\r\n      // used by the file family libc calls (fopen, fwrite, ferror, etc.)\r\n      ungotten: [],\r\n      error: false\r\n    });\r\n    // call the new stream's open function\r\n    if (stream.stream_ops.open) {\r\n      stream.stream_ops.open(stream);\r\n    }\r\n    if (created) {\r\n      FS.chmod(node, mode & 511);\r\n    }\r\n    return stream;\r\n  },\r\n  close(stream) {\r\n    if (FS.isClosed(stream)) {\r\n      throw new FS.ErrnoError(8);\r\n    }\r\n    if (stream.getdents) stream.getdents = null;\r\n    // free readdir state\r\n    try {\r\n      if (stream.stream_ops.close) {\r\n        stream.stream_ops.close(stream);\r\n      }\r\n    } catch (e) {\r\n      throw e;\r\n    } finally {\r\n      FS.closeStream(stream.fd);\r\n    }\r\n    stream.fd = null;\r\n  },\r\n  isClosed(stream) {\r\n    return stream.fd === null;\r\n  },\r\n  llseek(stream, offset, whence) {\r\n    if (FS.isClosed(stream)) {\r\n      throw new FS.ErrnoError(8);\r\n    }\r\n    if (!stream.seekable || !stream.stream_ops.llseek) {\r\n      throw new FS.ErrnoError(70);\r\n    }\r\n    if (whence != 0 && whence != 1 && whence != 2) {\r\n      throw new FS.ErrnoError(28);\r\n    }\r\n    stream.position = stream.stream_ops.llseek(stream, offset, whence);\r\n    stream.ungotten = [];\r\n    return stream.position;\r\n  },\r\n  read(stream, buffer, offset, length, position) {\r\n    assert(offset >= 0);\r\n    if (length < 0 || position < 0) {\r\n      throw new FS.ErrnoError(28);\r\n    }\r\n    if (FS.isClosed(stream)) {\r\n      throw new FS.ErrnoError(8);\r\n    }\r\n    if ((stream.flags & 2097155) === 1) {\r\n      throw new FS.ErrnoError(8);\r\n    }\r\n    if (FS.isDir(stream.node.mode)) {\r\n      throw new FS.ErrnoError(31);\r\n    }\r\n    if (!stream.stream_ops.read) {\r\n      throw new FS.ErrnoError(28);\r\n    }\r\n    var seeking = typeof position != \"undefined\";\r\n    if (!seeking) {\r\n      position = stream.position;\r\n    } else if (!stream.seekable) {\r\n      throw new FS.ErrnoError(70);\r\n    }\r\n    var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);\r\n    if (!seeking) stream.position += bytesRead;\r\n    return bytesRead;\r\n  },\r\n  write(stream, buffer, offset, length, position, canOwn) {\r\n    assert(offset >= 0);\r\n    if (length < 0 || position < 0) {\r\n      throw new FS.ErrnoError(28);\r\n    }\r\n    if (FS.isClosed(stream)) {\r\n      throw new FS.ErrnoError(8);\r\n    }\r\n    if ((stream.flags & 2097155) === 0) {\r\n      throw new FS.ErrnoError(8);\r\n    }\r\n    if (FS.isDir(stream.node.mode)) {\r\n      throw new FS.ErrnoError(31);\r\n    }\r\n    if (!stream.stream_ops.write) {\r\n      throw new FS.ErrnoError(28);\r\n    }\r\n    if (stream.seekable && stream.flags & 1024) {\r\n      // seek to the end before writing in append mode\r\n      FS.llseek(stream, 0, 2);\r\n    }\r\n    var seeking = typeof position != \"undefined\";\r\n    if (!seeking) {\r\n      position = stream.position;\r\n    } else if (!stream.seekable) {\r\n      throw new FS.ErrnoError(70);\r\n    }\r\n    var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);\r\n    if (!seeking) stream.position += bytesWritten;\r\n    return bytesWritten;\r\n  },\r\n  mmap(stream, length, position, prot, flags) {\r\n    // User requests writing to file (prot & PROT_WRITE != 0).\r\n    // Checking if we have permissions to write to the file unless\r\n    // MAP_PRIVATE flag is set. According to POSIX spec it is possible\r\n    // to write to file opened in read-only mode with MAP_PRIVATE flag,\r\n    // as all modifications will be visible only in the memory of\r\n    // the current process.\r\n    if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {\r\n      throw new FS.ErrnoError(2);\r\n    }\r\n    if ((stream.flags & 2097155) === 1) {\r\n      throw new FS.ErrnoError(2);\r\n    }\r\n    if (!stream.stream_ops.mmap) {\r\n      throw new FS.ErrnoError(43);\r\n    }\r\n    if (!length) {\r\n      throw new FS.ErrnoError(28);\r\n    }\r\n    return stream.stream_ops.mmap(stream, length, position, prot, flags);\r\n  },\r\n  msync(stream, buffer, offset, length, mmapFlags) {\r\n    assert(offset >= 0);\r\n    if (!stream.stream_ops.msync) {\r\n      return 0;\r\n    }\r\n    return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);\r\n  },\r\n  ioctl(stream, cmd, arg) {\r\n    if (!stream.stream_ops.ioctl) {\r\n      throw new FS.ErrnoError(59);\r\n    }\r\n    return stream.stream_ops.ioctl(stream, cmd, arg);\r\n  },\r\n  readFile(path, opts = {}) {\r\n    opts.flags = opts.flags || 0;\r\n    opts.encoding = opts.encoding || \"binary\";\r\n    if (opts.encoding !== \"utf8\" && opts.encoding !== \"binary\") {\r\n      throw new Error(`Invalid encoding type \"${opts.encoding}\"`);\r\n    }\r\n    var ret;\r\n    var stream = FS.open(path, opts.flags);\r\n    var stat = FS.stat(path);\r\n    var length = stat.size;\r\n    var buf = new Uint8Array(length);\r\n    FS.read(stream, buf, 0, length, 0);\r\n    if (opts.encoding === \"utf8\") {\r\n      ret = UTF8ArrayToString(buf);\r\n    } else if (opts.encoding === \"binary\") {\r\n      ret = buf;\r\n    }\r\n    FS.close(stream);\r\n    return ret;\r\n  },\r\n  writeFile(path, data, opts = {}) {\r\n    opts.flags = opts.flags || 577;\r\n    var stream = FS.open(path, opts.flags, opts.mode);\r\n    if (typeof data == \"string\") {\r\n      var buf = new Uint8Array(lengthBytesUTF8(data) + 1);\r\n      var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);\r\n      FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);\r\n    } else if (ArrayBuffer.isView(data)) {\r\n      FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);\r\n    } else {\r\n      throw new Error(\"Unsupported data type\");\r\n    }\r\n    FS.close(stream);\r\n  },\r\n  cwd: () => FS.currentPath,\r\n  chdir(path) {\r\n    var lookup = FS.lookupPath(path, {\r\n      follow: true\r\n    });\r\n    if (lookup.node === null) {\r\n      throw new FS.ErrnoError(44);\r\n    }\r\n    if (!FS.isDir(lookup.node.mode)) {\r\n      throw new FS.ErrnoError(54);\r\n    }\r\n    var errCode = FS.nodePermissions(lookup.node, \"x\");\r\n    if (errCode) {\r\n      throw new FS.ErrnoError(errCode);\r\n    }\r\n    FS.currentPath = lookup.path;\r\n  },\r\n  createDefaultDirectories() {\r\n    FS.mkdir(\"/tmp\");\r\n    FS.mkdir(\"/home\");\r\n    FS.mkdir(\"/home/web_user\");\r\n  },\r\n  createDefaultDevices() {\r\n    // create /dev\r\n    FS.mkdir(\"/dev\");\r\n    // setup /dev/null\r\n    FS.registerDevice(FS.makedev(1, 3), {\r\n      read: () => 0,\r\n      write: (stream, buffer, offset, length, pos) => length,\r\n      llseek: () => 0\r\n    });\r\n    FS.mkdev(\"/dev/null\", FS.makedev(1, 3));\r\n    // setup /dev/tty and /dev/tty1\r\n    // stderr needs to print output using err() rather than out()\r\n    // so we register a second tty just for it.\r\n    TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);\r\n    TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);\r\n    FS.mkdev(\"/dev/tty\", FS.makedev(5, 0));\r\n    FS.mkdev(\"/dev/tty1\", FS.makedev(6, 0));\r\n    // setup /dev/[u]random\r\n    // use a buffer to avoid overhead of individual crypto calls per byte\r\n    var randomBuffer = new Uint8Array(1024), randomLeft = 0;\r\n    var randomByte = () => {\r\n      if (randomLeft === 0) {\r\n        randomFill(randomBuffer);\r\n        randomLeft = randomBuffer.byteLength;\r\n      }\r\n      return randomBuffer[--randomLeft];\r\n    };\r\n    FS.createDevice(\"/dev\", \"random\", randomByte);\r\n    FS.createDevice(\"/dev\", \"urandom\", randomByte);\r\n    // we're not going to emulate the actual shm device,\r\n    // just create the tmp dirs that reside in it commonly\r\n    FS.mkdir(\"/dev/shm\");\r\n    FS.mkdir(\"/dev/shm/tmp\");\r\n  },\r\n  createSpecialDirectories() {\r\n    // create /proc/self/fd which allows /proc/self/fd/6 => readlink gives the\r\n    // name of the stream for fd 6 (see test_unistd_ttyname)\r\n    FS.mkdir(\"/proc\");\r\n    var proc_self = FS.mkdir(\"/proc/self\");\r\n    FS.mkdir(\"/proc/self/fd\");\r\n    FS.mount({\r\n      mount() {\r\n        var node = FS.createNode(proc_self, \"fd\", 16895, 73);\r\n        node.stream_ops = {\r\n          llseek: MEMFS.stream_ops.llseek\r\n        };\r\n        node.node_ops = {\r\n          lookup(parent, name) {\r\n            var fd = +name;\r\n            var stream = FS.getStreamChecked(fd);\r\n            var ret = {\r\n              parent: null,\r\n              mount: {\r\n                mountpoint: \"fake\"\r\n              },\r\n              node_ops: {\r\n                readlink: () => stream.path\r\n              },\r\n              id: fd + 1\r\n            };\r\n            ret.parent = ret;\r\n            // make it look like a simple root node\r\n            return ret;\r\n          },\r\n          readdir() {\r\n            return Array.from(FS.streams.entries()).filter(([k, v]) => v).map(([k, v]) => k.toString());\r\n          }\r\n        };\r\n        return node;\r\n      }\r\n    }, {}, \"/proc/self/fd\");\r\n  },\r\n  createStandardStreams(input, output, error) {\r\n    // TODO deprecate the old functionality of a single\r\n    // input / output callback and that utilizes FS.createDevice\r\n    // and instead require a unique set of stream ops\r\n    // by default, we symlink the standard streams to the\r\n    // default tty devices. however, if the standard streams\r\n    // have been overwritten we create a unique device for\r\n    // them instead.\r\n    if (input) {\r\n      FS.createDevice(\"/dev\", \"stdin\", input);\r\n    } else {\r\n      FS.symlink(\"/dev/tty\", \"/dev/stdin\");\r\n    }\r\n    if (output) {\r\n      FS.createDevice(\"/dev\", \"stdout\", null, output);\r\n    } else {\r\n      FS.symlink(\"/dev/tty\", \"/dev/stdout\");\r\n    }\r\n    if (error) {\r\n      FS.createDevice(\"/dev\", \"stderr\", null, error);\r\n    } else {\r\n      FS.symlink(\"/dev/tty1\", \"/dev/stderr\");\r\n    }\r\n    // open default streams for the stdin, stdout and stderr devices\r\n    var stdin = FS.open(\"/dev/stdin\", 0);\r\n    var stdout = FS.open(\"/dev/stdout\", 1);\r\n    var stderr = FS.open(\"/dev/stderr\", 1);\r\n    assert(stdin.fd === 0, `invalid handle for stdin (${stdin.fd})`);\r\n    assert(stdout.fd === 1, `invalid handle for stdout (${stdout.fd})`);\r\n    assert(stderr.fd === 2, `invalid handle for stderr (${stderr.fd})`);\r\n  },\r\n  staticInit() {\r\n    FS.nameTable = new Array(4096);\r\n    FS.mount(MEMFS, {}, \"/\");\r\n    FS.createDefaultDirectories();\r\n    FS.createDefaultDevices();\r\n    FS.createSpecialDirectories();\r\n    FS.filesystems = {\r\n      \"MEMFS\": MEMFS\r\n    };\r\n  },\r\n  init(input, output, error) {\r\n    assert(!FS.initialized, \"FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)\");\r\n    FS.initialized = true;\r\n    // Allow Module.stdin etc. to provide defaults, if none explicitly passed to us here\r\n    FS.createStandardStreams(input, output, error);\r\n  },\r\n  quit() {\r\n    FS.initialized = false;\r\n    // force-flush all streams, so we get musl std streams printed out\r\n    _fflush(0);\r\n    // close all of our streams\r\n    for (var stream of FS.streams) {\r\n      if (stream) {\r\n        FS.close(stream);\r\n      }\r\n    }\r\n  },\r\n  findObject(path, dontResolveLastLink) {\r\n    var ret = FS.analyzePath(path, dontResolveLastLink);\r\n    if (!ret.exists) {\r\n      return null;\r\n    }\r\n    return ret.object;\r\n  },\r\n  analyzePath(path, dontResolveLastLink) {\r\n    // operate from within the context of the symlink's target\r\n    try {\r\n      var lookup = FS.lookupPath(path, {\r\n        follow: !dontResolveLastLink\r\n      });\r\n      path = lookup.path;\r\n    } catch (e) {}\r\n    var ret = {\r\n      isRoot: false,\r\n      exists: false,\r\n      error: 0,\r\n      name: null,\r\n      path: null,\r\n      object: null,\r\n      parentExists: false,\r\n      parentPath: null,\r\n      parentObject: null\r\n    };\r\n    try {\r\n      var lookup = FS.lookupPath(path, {\r\n        parent: true\r\n      });\r\n      ret.parentExists = true;\r\n      ret.parentPath = lookup.path;\r\n      ret.parentObject = lookup.node;\r\n      ret.name = PATH.basename(path);\r\n      lookup = FS.lookupPath(path, {\r\n        follow: !dontResolveLastLink\r\n      });\r\n      ret.exists = true;\r\n      ret.path = lookup.path;\r\n      ret.object = lookup.node;\r\n      ret.name = lookup.node.name;\r\n      ret.isRoot = lookup.path === \"/\";\r\n    } catch (e) {\r\n      ret.error = e.errno;\r\n    }\r\n    return ret;\r\n  },\r\n  createPath(parent, path, canRead, canWrite) {\r\n    parent = typeof parent == \"string\" ? parent : FS.getPath(parent);\r\n    var parts = path.split(\"/\").reverse();\r\n    while (parts.length) {\r\n      var part = parts.pop();\r\n      if (!part) continue;\r\n      var current = PATH.join2(parent, part);\r\n      try {\r\n        FS.mkdir(current);\r\n      } catch (e) {\r\n        if (e.errno != 20) throw e;\r\n      }\r\n      parent = current;\r\n    }\r\n    return current;\r\n  },\r\n  createFile(parent, name, properties, canRead, canWrite) {\r\n    var path = PATH.join2(typeof parent == \"string\" ? parent : FS.getPath(parent), name);\r\n    var mode = FS_getMode(canRead, canWrite);\r\n    return FS.create(path, mode);\r\n  },\r\n  createDataFile(parent, name, data, canRead, canWrite, canOwn) {\r\n    var path = name;\r\n    if (parent) {\r\n      parent = typeof parent == \"string\" ? parent : FS.getPath(parent);\r\n      path = name ? PATH.join2(parent, name) : parent;\r\n    }\r\n    var mode = FS_getMode(canRead, canWrite);\r\n    var node = FS.create(path, mode);\r\n    if (data) {\r\n      if (typeof data == \"string\") {\r\n        var arr = new Array(data.length);\r\n        for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);\r\n        data = arr;\r\n      }\r\n      // make sure we can write to the file\r\n      FS.chmod(node, mode | 146);\r\n      var stream = FS.open(node, 577);\r\n      FS.write(stream, data, 0, data.length, 0, canOwn);\r\n      FS.close(stream);\r\n      FS.chmod(node, mode);\r\n    }\r\n  },\r\n  createDevice(parent, name, input, output) {\r\n    var path = PATH.join2(typeof parent == \"string\" ? parent : FS.getPath(parent), name);\r\n    var mode = FS_getMode(!!input, !!output);\r\n    FS.createDevice.major ??= 64;\r\n    var dev = FS.makedev(FS.createDevice.major++, 0);\r\n    // Create a fake device that a set of stream ops to emulate\r\n    // the old behavior.\r\n    FS.registerDevice(dev, {\r\n      open(stream) {\r\n        stream.seekable = false;\r\n      },\r\n      close(stream) {\r\n        // flush any pending line data\r\n        if (output?.buffer?.length) {\r\n          output(10);\r\n        }\r\n      },\r\n      read(stream, buffer, offset, length, pos) {\r\n        var bytesRead = 0;\r\n        for (var i = 0; i < length; i++) {\r\n          var result;\r\n          try {\r\n            result = input();\r\n          } catch (e) {\r\n            throw new FS.ErrnoError(29);\r\n          }\r\n          if (result === undefined && bytesRead === 0) {\r\n            throw new FS.ErrnoError(6);\r\n          }\r\n          if (result === null || result === undefined) break;\r\n          bytesRead++;\r\n          buffer[offset + i] = result;\r\n        }\r\n        if (bytesRead) {\r\n          stream.node.atime = Date.now();\r\n        }\r\n        return bytesRead;\r\n      },\r\n      write(stream, buffer, offset, length, pos) {\r\n        for (var i = 0; i < length; i++) {\r\n          try {\r\n            output(buffer[offset + i]);\r\n          } catch (e) {\r\n            throw new FS.ErrnoError(29);\r\n          }\r\n        }\r\n        if (length) {\r\n          stream.node.mtime = stream.node.ctime = Date.now();\r\n        }\r\n        return i;\r\n      }\r\n    });\r\n    return FS.mkdev(path, mode, dev);\r\n  },\r\n  forceLoadFile(obj) {\r\n    if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;\r\n    if (typeof XMLHttpRequest != \"undefined\") {\r\n      throw new Error(\"Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.\");\r\n    } else {\r\n      // Command-line.\r\n      try {\r\n        obj.contents = readBinary(obj.url);\r\n        obj.usedBytes = obj.contents.length;\r\n      } catch (e) {\r\n        throw new FS.ErrnoError(29);\r\n      }\r\n    }\r\n  },\r\n  createLazyFile(parent, name, url, canRead, canWrite) {\r\n    // Lazy chunked Uint8Array (implements get and length from Uint8Array).\r\n    // Actual getting is abstracted away for eventual reuse.\r\n    class LazyUint8Array {\r\n      lengthKnown=false;\r\n      chunks=[];\r\n      // Loaded chunks. Index is the chunk number\r\n      get(idx) {\r\n        if (idx > this.length - 1 || idx < 0) {\r\n          return undefined;\r\n        }\r\n        var chunkOffset = idx % this.chunkSize;\r\n        var chunkNum = (idx / this.chunkSize) | 0;\r\n        return this.getter(chunkNum)[chunkOffset];\r\n      }\r\n      setDataGetter(getter) {\r\n        this.getter = getter;\r\n      }\r\n      cacheLength() {\r\n        // Find length\r\n        var xhr = new XMLHttpRequest;\r\n        xhr.open(\"HEAD\", url, false);\r\n        xhr.send(null);\r\n        if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\r\n        var datalength = Number(xhr.getResponseHeader(\"Content-length\"));\r\n        var header;\r\n        var hasByteServing = (header = xhr.getResponseHeader(\"Accept-Ranges\")) && header === \"bytes\";\r\n        var usesGzip = (header = xhr.getResponseHeader(\"Content-Encoding\")) && header === \"gzip\";\r\n        var chunkSize = 1024 * 1024;\r\n        // Chunk size in bytes\r\n        if (!hasByteServing) chunkSize = datalength;\r\n        // Function to get a range from the remote URL.\r\n        var doXHR = (from, to) => {\r\n          if (from > to) throw new Error(\"invalid range (\" + from + \", \" + to + \") or no bytes requested!\");\r\n          if (to > datalength - 1) throw new Error(\"only \" + datalength + \" bytes available! programmer error!\");\r\n          // TODO: Use mozResponseArrayBuffer, responseStream, etc. if available.\r\n          var xhr = new XMLHttpRequest;\r\n          xhr.open(\"GET\", url, false);\r\n          if (datalength !== chunkSize) xhr.setRequestHeader(\"Range\", \"bytes=\" + from + \"-\" + to);\r\n          // Some hints to the browser that we want binary data.\r\n          xhr.responseType = \"arraybuffer\";\r\n          if (xhr.overrideMimeType) {\r\n            xhr.overrideMimeType(\"text/plain; charset=x-user-defined\");\r\n          }\r\n          xhr.send(null);\r\n          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\r\n          if (xhr.response !== undefined) {\r\n            return new Uint8Array(/** @type{Array<number>} */ (xhr.response || []));\r\n          }\r\n          return intArrayFromString(xhr.responseText || \"\", true);\r\n        };\r\n        var lazyArray = this;\r\n        lazyArray.setDataGetter(chunkNum => {\r\n          var start = chunkNum * chunkSize;\r\n          var end = (chunkNum + 1) * chunkSize - 1;\r\n          // including this byte\r\n          end = Math.min(end, datalength - 1);\r\n          // if datalength-1 is selected, this is the last block\r\n          if (typeof lazyArray.chunks[chunkNum] == \"undefined\") {\r\n            lazyArray.chunks[chunkNum] = doXHR(start, end);\r\n          }\r\n          if (typeof lazyArray.chunks[chunkNum] == \"undefined\") throw new Error(\"doXHR failed!\");\r\n          return lazyArray.chunks[chunkNum];\r\n        });\r\n        if (usesGzip || !datalength) {\r\n          // if the server uses gzip or doesn't supply the length, we have to download the whole file to get the (uncompressed) length\r\n          chunkSize = datalength = 1;\r\n          // this will force getter(0)/doXHR do download the whole file\r\n          datalength = this.getter(0).length;\r\n          chunkSize = datalength;\r\n          out(\"LazyFiles on gzip forces download of the whole file when length is accessed\");\r\n        }\r\n        this._length = datalength;\r\n        this._chunkSize = chunkSize;\r\n        this.lengthKnown = true;\r\n      }\r\n      get length() {\r\n        if (!this.lengthKnown) {\r\n          this.cacheLength();\r\n        }\r\n        return this._length;\r\n      }\r\n      get chunkSize() {\r\n        if (!this.lengthKnown) {\r\n          this.cacheLength();\r\n        }\r\n        return this._chunkSize;\r\n      }\r\n    }\r\n    if (typeof XMLHttpRequest != \"undefined\") {\r\n      if (!ENVIRONMENT_IS_WORKER) throw \"Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc\";\r\n      var lazyArray = new LazyUint8Array;\r\n      var properties = {\r\n        isDevice: false,\r\n        contents: lazyArray\r\n      };\r\n    } else {\r\n      var properties = {\r\n        isDevice: false,\r\n        url\r\n      };\r\n    }\r\n    var node = FS.createFile(parent, name, properties, canRead, canWrite);\r\n    // This is a total hack, but I want to get this lazy file code out of the\r\n    // core of MEMFS. If we want to keep this lazy file concept I feel it should\r\n    // be its own thin LAZYFS proxying calls to MEMFS.\r\n    if (properties.contents) {\r\n      node.contents = properties.contents;\r\n    } else if (properties.url) {\r\n      node.contents = null;\r\n      node.url = properties.url;\r\n    }\r\n    // Add a function that defers querying the file size until it is asked the first time.\r\n    Object.defineProperties(node, {\r\n      usedBytes: {\r\n        get: function() {\r\n          return this.contents.length;\r\n        }\r\n      }\r\n    });\r\n    // override each stream op with one that tries to force load the lazy file first\r\n    var stream_ops = {};\r\n    var keys = Object.keys(node.stream_ops);\r\n    keys.forEach(key => {\r\n      var fn = node.stream_ops[key];\r\n      stream_ops[key] = (...args) => {\r\n        FS.forceLoadFile(node);\r\n        return fn(...args);\r\n      };\r\n    });\r\n    function writeChunks(stream, buffer, offset, length, position) {\r\n      var contents = stream.node.contents;\r\n      if (position >= contents.length) return 0;\r\n      var size = Math.min(contents.length - position, length);\r\n      assert(size >= 0);\r\n      if (contents.slice) {\r\n        // normal array\r\n        for (var i = 0; i < size; i++) {\r\n          buffer[offset + i] = contents[position + i];\r\n        }\r\n      } else {\r\n        for (var i = 0; i < size; i++) {\r\n          // LazyUint8Array from sync binary XHR\r\n          buffer[offset + i] = contents.get(position + i);\r\n        }\r\n      }\r\n      return size;\r\n    }\r\n    // use a custom read function\r\n    stream_ops.read = (stream, buffer, offset, length, position) => {\r\n      FS.forceLoadFile(node);\r\n      return writeChunks(stream, buffer, offset, length, position);\r\n    };\r\n    // use a custom mmap function\r\n    stream_ops.mmap = (stream, length, position, prot, flags) => {\r\n      FS.forceLoadFile(node);\r\n      var ptr = mmapAlloc(length);\r\n      if (!ptr) {\r\n        throw new FS.ErrnoError(48);\r\n      }\r\n      writeChunks(stream, GROWABLE_HEAP_I8(), ptr, length, position);\r\n      return {\r\n        ptr,\r\n        allocated: true\r\n      };\r\n    };\r\n    node.stream_ops = stream_ops;\r\n    return node;\r\n  },\r\n  absolutePath() {\r\n    abort(\"FS.absolutePath has been removed; use PATH_FS.resolve instead\");\r\n  },\r\n  createFolder() {\r\n    abort(\"FS.createFolder has been removed; use FS.mkdir instead\");\r\n  },\r\n  createLink() {\r\n    abort(\"FS.createLink has been removed; use FS.symlink instead\");\r\n  },\r\n  joinPath() {\r\n    abort(\"FS.joinPath has been removed; use PATH.join instead\");\r\n  },\r\n  mmapAlloc() {\r\n    abort(\"FS.mmapAlloc has been replaced by the top level function mmapAlloc\");\r\n  },\r\n  standardizePath() {\r\n    abort(\"FS.standardizePath has been removed; use PATH.normalize instead\");\r\n  }\r\n};\r\n\r\nvar SYSCALLS = {\r\n  DEFAULT_POLLMASK: 5,\r\n  calculateAt(dirfd, path, allowEmpty) {\r\n    if (PATH.isAbs(path)) {\r\n      return path;\r\n    }\r\n    // relative path\r\n    var dir;\r\n    if (dirfd === -100) {\r\n      dir = FS.cwd();\r\n    } else {\r\n      var dirstream = SYSCALLS.getStreamFromFD(dirfd);\r\n      dir = dirstream.path;\r\n    }\r\n    if (path.length == 0) {\r\n      if (!allowEmpty) {\r\n        throw new FS.ErrnoError(44);\r\n      }\r\n      return dir;\r\n    }\r\n    return dir + \"/\" + path;\r\n  },\r\n  writeStat(buf, stat) {\r\n    GROWABLE_HEAP_I32()[((buf) >> 2)] = stat.dev;\r\n    GROWABLE_HEAP_I32()[(((buf) + (4)) >> 2)] = stat.mode;\r\n    GROWABLE_HEAP_U32()[(((buf) + (8)) >> 2)] = stat.nlink;\r\n    GROWABLE_HEAP_I32()[(((buf) + (12)) >> 2)] = stat.uid;\r\n    GROWABLE_HEAP_I32()[(((buf) + (16)) >> 2)] = stat.gid;\r\n    GROWABLE_HEAP_I32()[(((buf) + (20)) >> 2)] = stat.rdev;\r\n    HEAP64[(((buf) + (24)) >> 3)] = BigInt(stat.size);\r\n    GROWABLE_HEAP_I32()[(((buf) + (32)) >> 2)] = 4096;\r\n    GROWABLE_HEAP_I32()[(((buf) + (36)) >> 2)] = stat.blocks;\r\n    var atime = stat.atime.getTime();\r\n    var mtime = stat.mtime.getTime();\r\n    var ctime = stat.ctime.getTime();\r\n    HEAP64[(((buf) + (40)) >> 3)] = BigInt(Math.floor(atime / 1e3));\r\n    GROWABLE_HEAP_U32()[(((buf) + (48)) >> 2)] = (atime % 1e3) * 1e3 * 1e3;\r\n    HEAP64[(((buf) + (56)) >> 3)] = BigInt(Math.floor(mtime / 1e3));\r\n    GROWABLE_HEAP_U32()[(((buf) + (64)) >> 2)] = (mtime % 1e3) * 1e3 * 1e3;\r\n    HEAP64[(((buf) + (72)) >> 3)] = BigInt(Math.floor(ctime / 1e3));\r\n    GROWABLE_HEAP_U32()[(((buf) + (80)) >> 2)] = (ctime % 1e3) * 1e3 * 1e3;\r\n    HEAP64[(((buf) + (88)) >> 3)] = BigInt(stat.ino);\r\n    return 0;\r\n  },\r\n  writeStatFs(buf, stats) {\r\n    GROWABLE_HEAP_I32()[(((buf) + (4)) >> 2)] = stats.bsize;\r\n    GROWABLE_HEAP_I32()[(((buf) + (40)) >> 2)] = stats.bsize;\r\n    GROWABLE_HEAP_I32()[(((buf) + (8)) >> 2)] = stats.blocks;\r\n    GROWABLE_HEAP_I32()[(((buf) + (12)) >> 2)] = stats.bfree;\r\n    GROWABLE_HEAP_I32()[(((buf) + (16)) >> 2)] = stats.bavail;\r\n    GROWABLE_HEAP_I32()[(((buf) + (20)) >> 2)] = stats.files;\r\n    GROWABLE_HEAP_I32()[(((buf) + (24)) >> 2)] = stats.ffree;\r\n    GROWABLE_HEAP_I32()[(((buf) + (28)) >> 2)] = stats.fsid;\r\n    GROWABLE_HEAP_I32()[(((buf) + (44)) >> 2)] = stats.flags;\r\n    // ST_NOSUID\r\n    GROWABLE_HEAP_I32()[(((buf) + (36)) >> 2)] = stats.namelen;\r\n  },\r\n  doMsync(addr, stream, len, flags, offset) {\r\n    if (!FS.isFile(stream.node.mode)) {\r\n      throw new FS.ErrnoError(43);\r\n    }\r\n    if (flags & 2) {\r\n      // MAP_PRIVATE calls need not to be synced back to underlying fs\r\n      return 0;\r\n    }\r\n    var buffer = GROWABLE_HEAP_U8().slice(addr, addr + len);\r\n    FS.msync(stream, buffer, offset, len, flags);\r\n  },\r\n  getStreamFromFD(fd) {\r\n    var stream = FS.getStreamChecked(fd);\r\n    return stream;\r\n  },\r\n  varargs: undefined,\r\n  getStr(ptr) {\r\n    var ret = UTF8ToString(ptr);\r\n    return ret;\r\n  }\r\n};\r\n\r\nfunction _fd_close(fd) {\r\n  if (ENVIRONMENT_IS_PTHREAD) return proxyToMainThread(3, 0, 1, fd);\r\n  try {\r\n    var stream = SYSCALLS.getStreamFromFD(fd);\r\n    FS.close(stream);\r\n    return 0;\r\n  } catch (e) {\r\n    if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\r\n    return e.errno;\r\n  }\r\n}\r\n\r\n/** @param {number=} offset */ var doReadv = (stream, iov, iovcnt, offset) => {\r\n  var ret = 0;\r\n  for (var i = 0; i < iovcnt; i++) {\r\n    var ptr = GROWABLE_HEAP_U32()[((iov) >> 2)];\r\n    var len = GROWABLE_HEAP_U32()[(((iov) + (4)) >> 2)];\r\n    iov += 8;\r\n    var curr = FS.read(stream, GROWABLE_HEAP_I8(), ptr, len, offset);\r\n    if (curr < 0) return -1;\r\n    ret += curr;\r\n    if (curr < len) break;\r\n    // nothing more to read\r\n    if (typeof offset != \"undefined\") {\r\n      offset += curr;\r\n    }\r\n  }\r\n  return ret;\r\n};\r\n\r\nfunction _fd_read(fd, iov, iovcnt, pnum) {\r\n  if (ENVIRONMENT_IS_PTHREAD) return proxyToMainThread(4, 0, 1, fd, iov, iovcnt, pnum);\r\n  try {\r\n    var stream = SYSCALLS.getStreamFromFD(fd);\r\n    var num = doReadv(stream, iov, iovcnt);\r\n    GROWABLE_HEAP_U32()[((pnum) >> 2)] = num;\r\n    return 0;\r\n  } catch (e) {\r\n    if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\r\n    return e.errno;\r\n  }\r\n}\r\n\r\nfunction _fd_seek(fd, offset, whence, newOffset) {\r\n  if (ENVIRONMENT_IS_PTHREAD) return proxyToMainThread(5, 0, 1, fd, offset, whence, newOffset);\r\n  offset = bigintToI53Checked(offset);\r\n  try {\r\n    if (isNaN(offset)) return 61;\r\n    var stream = SYSCALLS.getStreamFromFD(fd);\r\n    FS.llseek(stream, offset, whence);\r\n    HEAP64[((newOffset) >> 3)] = BigInt(stream.position);\r\n    if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null;\r\n    // reset readdir state\r\n    return 0;\r\n  } catch (e) {\r\n    if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\r\n    return e.errno;\r\n  }\r\n}\r\n\r\n/** @param {number=} offset */ var doWritev = (stream, iov, iovcnt, offset) => {\r\n  var ret = 0;\r\n  for (var i = 0; i < iovcnt; i++) {\r\n    var ptr = GROWABLE_HEAP_U32()[((iov) >> 2)];\r\n    var len = GROWABLE_HEAP_U32()[(((iov) + (4)) >> 2)];\r\n    iov += 8;\r\n    var curr = FS.write(stream, GROWABLE_HEAP_I8(), ptr, len, offset);\r\n    if (curr < 0) return -1;\r\n    ret += curr;\r\n    if (curr < len) {\r\n      // No more space to write.\r\n      break;\r\n    }\r\n    if (typeof offset != \"undefined\") {\r\n      offset += curr;\r\n    }\r\n  }\r\n  return ret;\r\n};\r\n\r\nfunction _fd_write(fd, iov, iovcnt, pnum) {\r\n  if (ENVIRONMENT_IS_PTHREAD) return proxyToMainThread(6, 0, 1, fd, iov, iovcnt, pnum);\r\n  try {\r\n    var stream = SYSCALLS.getStreamFromFD(fd);\r\n    var num = doWritev(stream, iov, iovcnt);\r\n    GROWABLE_HEAP_U32()[((pnum) >> 2)] = num;\r\n    return 0;\r\n  } catch (e) {\r\n    if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\r\n    return e.errno;\r\n  }\r\n}\r\n\r\nfunction _random_get(buffer, size) {\r\n  try {\r\n    randomFill(GROWABLE_HEAP_U8().subarray(buffer, buffer + size));\r\n    return 0;\r\n  } catch (e) {\r\n    if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\r\n    return e.errno;\r\n  }\r\n}\r\n\r\nvar getCFunc = ident => {\r\n  var func = Module[\"_\" + ident];\r\n  // closure exported function\r\n  assert(func, \"Cannot call unknown function \" + ident + \", make sure it is exported\");\r\n  return func;\r\n};\r\n\r\nvar writeArrayToMemory = (array, buffer) => {\r\n  assert(array.length >= 0, \"writeArrayToMemory array must have a length (should be an array or typed array)\");\r\n  GROWABLE_HEAP_I8().set(array, buffer);\r\n};\r\n\r\nvar stringToUTF8OnStack = str => {\r\n  var size = lengthBytesUTF8(str) + 1;\r\n  var ret = stackAlloc(size);\r\n  stringToUTF8(str, ret, size);\r\n  return ret;\r\n};\r\n\r\n/**\r\n     * @param {string|null=} returnType\r\n     * @param {Array=} argTypes\r\n     * @param {Arguments|Array=} args\r\n     * @param {Object=} opts\r\n     */ var ccall = (ident, returnType, argTypes, args, opts) => {\r\n  // For fast lookup of conversion functions\r\n  var toC = {\r\n    \"string\": str => {\r\n      var ret = 0;\r\n      if (str !== null && str !== undefined && str !== 0) {\r\n        // null string\r\n        ret = stringToUTF8OnStack(str);\r\n      }\r\n      return ret;\r\n    },\r\n    \"array\": arr => {\r\n      var ret = stackAlloc(arr.length);\r\n      writeArrayToMemory(arr, ret);\r\n      return ret;\r\n    }\r\n  };\r\n  function convertReturnValue(ret) {\r\n    if (returnType === \"string\") {\r\n      return UTF8ToString(ret);\r\n    }\r\n    if (returnType === \"boolean\") return Boolean(ret);\r\n    return ret;\r\n  }\r\n  var func = getCFunc(ident);\r\n  var cArgs = [];\r\n  var stack = 0;\r\n  assert(returnType !== \"array\", 'Return type should not be \"array\".');\r\n  if (args) {\r\n    for (var i = 0; i < args.length; i++) {\r\n      var converter = toC[argTypes[i]];\r\n      if (converter) {\r\n        if (stack === 0) stack = stackSave();\r\n        cArgs[i] = converter(args[i]);\r\n      } else {\r\n        cArgs[i] = args[i];\r\n      }\r\n    }\r\n  }\r\n  var ret = func(...cArgs);\r\n  function onDone(ret) {\r\n    if (stack !== 0) stackRestore(stack);\r\n    return convertReturnValue(ret);\r\n  }\r\n  ret = onDone(ret);\r\n  return ret;\r\n};\r\n\r\n/**\r\n     * @param {string=} returnType\r\n     * @param {Array=} argTypes\r\n     * @param {Object=} opts\r\n     */ var cwrap = (ident, returnType, argTypes, opts) => (...args) => ccall(ident, returnType, argTypes, args, opts);\r\n\r\nvar incrementExceptionRefcount = ptr => ___cxa_increment_exception_refcount(ptr);\r\n\r\nvar decrementExceptionRefcount = ptr => ___cxa_decrement_exception_refcount(ptr);\r\n\r\nvar getExceptionMessageCommon = ptr => {\r\n  var sp = stackSave();\r\n  var type_addr_addr = stackAlloc(4);\r\n  var message_addr_addr = stackAlloc(4);\r\n  ___get_exception_message(ptr, type_addr_addr, message_addr_addr);\r\n  var type_addr = GROWABLE_HEAP_U32()[((type_addr_addr) >> 2)];\r\n  var message_addr = GROWABLE_HEAP_U32()[((message_addr_addr) >> 2)];\r\n  var type = UTF8ToString(type_addr);\r\n  _free(type_addr);\r\n  var message;\r\n  if (message_addr) {\r\n    message = UTF8ToString(message_addr);\r\n    _free(message_addr);\r\n  }\r\n  stackRestore(sp);\r\n  return [ type, message ];\r\n};\r\n\r\nvar getExceptionMessage = ptr => getExceptionMessageCommon(ptr);\r\n\r\nPThread.init();\r\n\r\nembind_init_charCodes();\r\n\r\ninit_ClassHandle();\r\n\r\ninit_RegisteredPointer();\r\n\r\ninit_emval();\r\n\r\nFS.createPreloadedFile = FS_createPreloadedFile;\r\n\r\nFS.staticInit();\r\n\r\n// End JS library code\r\n// include: postlibrary.js\r\n// This file is included after the automatically-generated JS library code\r\n// but before the wasm module is created.\r\n{\r\n  // With WASM_ESM_INTEGRATION this has to happen at the top level and not\r\n  // delayed until processModuleArgs.\r\n  initMemory();\r\n  // No ATMODULES hooks\r\n  checkIncomingModuleAPI();\r\n  // Assertions on removed incoming Module JS APIs.\r\n  assert(typeof Module[\"memoryInitializerPrefixURL\"] == \"undefined\", \"Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead\");\r\n  assert(typeof Module[\"pthreadMainPrefixURL\"] == \"undefined\", \"Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead\");\r\n  assert(typeof Module[\"cdInitializerPrefixURL\"] == \"undefined\", \"Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead\");\r\n  assert(typeof Module[\"filePackagePrefixURL\"] == \"undefined\", \"Module.filePackagePrefixURL option was removed, use Module.locateFile instead\");\r\n  assert(typeof Module[\"read\"] == \"undefined\", \"Module.read option was removed\");\r\n  assert(typeof Module[\"readAsync\"] == \"undefined\", \"Module.readAsync option was removed (modify readAsync in JS)\");\r\n  assert(typeof Module[\"readBinary\"] == \"undefined\", \"Module.readBinary option was removed (modify readBinary in JS)\");\r\n  assert(typeof Module[\"setWindowTitle\"] == \"undefined\", \"Module.setWindowTitle option was removed (modify emscripten_set_window_title in JS)\");\r\n  assert(typeof Module[\"TOTAL_MEMORY\"] == \"undefined\", \"Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY\");\r\n  assert(typeof Module[\"ENVIRONMENT\"] == \"undefined\", \"Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -sENVIRONMENT=web or -sENVIRONMENT=node)\");\r\n  assert(typeof Module[\"STACK_SIZE\"] == \"undefined\", \"STACK_SIZE can no longer be set at runtime.  Use -sSTACK_SIZE at link time\");\r\n}\r\n\r\n// Begin runtime exports\r\nModule[\"ccall\"] = ccall;\r\n\r\nModule[\"cwrap\"] = cwrap;\r\n\r\nvar missingLibrarySymbols = [ \"writeI53ToI64\", \"writeI53ToI64Clamped\", \"writeI53ToI64Signaling\", \"writeI53ToU64Clamped\", \"writeI53ToU64Signaling\", \"readI53FromI64\", \"readI53FromU64\", \"convertI32PairToI53\", \"convertI32PairToI53Checked\", \"convertU32PairToI53\", \"getTempRet0\", \"zeroMemory\", \"inetPton4\", \"inetNtop4\", \"inetPton6\", \"inetNtop6\", \"readSockaddr\", \"writeSockaddr\", \"emscriptenLog\", \"readEmAsmArgs\", \"jstoi_q\", \"getExecutableName\", \"listenOnce\", \"autoResumeAudioContext\", \"getDynCaller\", \"dynCall\", \"asmjsMangle\", \"HandleAllocator\", \"getNativeTypeSize\", \"addOnInit\", \"addOnPostCtor\", \"addOnPreMain\", \"addOnExit\", \"addOnPostRun\", \"STACK_SIZE\", \"STACK_ALIGN\", \"POINTER_SIZE\", \"ASSERTIONS\", \"uleb128Encode\", \"sigToWasmTypes\", \"generateFuncType\", \"convertJsFunctionToWasm\", \"getEmptyTableSlot\", \"updateTableMap\", \"getFunctionAddress\", \"addFunction\", \"removeFunction\", \"reallyNegative\", \"unSign\", \"strLen\", \"reSign\", \"formatString\", \"intArrayToString\", \"AsciiToString\", \"stringToAscii\", \"stringToNewUTF8\", \"registerKeyEventCallback\", \"maybeCStringToJsString\", \"findEventTarget\", \"getBoundingClientRect\", \"fillMouseEventData\", \"registerMouseEventCallback\", \"registerWheelEventCallback\", \"registerUiEventCallback\", \"registerFocusEventCallback\", \"fillDeviceOrientationEventData\", \"registerDeviceOrientationEventCallback\", \"fillDeviceMotionEventData\", \"registerDeviceMotionEventCallback\", \"screenOrientation\", \"fillOrientationChangeEventData\", \"registerOrientationChangeEventCallback\", \"fillFullscreenChangeEventData\", \"registerFullscreenChangeEventCallback\", \"JSEvents_requestFullscreen\", \"JSEvents_resizeCanvasForFullscreen\", \"registerRestoreOldStyle\", \"hideEverythingExceptGivenElement\", \"restoreHiddenElements\", \"setLetterbox\", \"softFullscreenResizeWebGLRenderTarget\", \"doRequestFullscreen\", \"fillPointerlockChangeEventData\", \"registerPointerlockChangeEventCallback\", \"registerPointerlockErrorEventCallback\", \"requestPointerLock\", \"fillVisibilityChangeEventData\", \"registerVisibilityChangeEventCallback\", \"registerTouchEventCallback\", \"fillGamepadEventData\", \"registerGamepadEventCallback\", \"registerBeforeUnloadEventCallback\", \"fillBatteryEventData\", \"battery\", \"registerBatteryEventCallback\", \"setCanvasElementSizeCallingThread\", \"setCanvasElementSizeMainThread\", \"setCanvasElementSize\", \"getCanvasSizeCallingThread\", \"getCanvasSizeMainThread\", \"getCanvasElementSize\", \"jsStackTrace\", \"getCallstack\", \"convertPCtoSourceLocation\", \"getEnvStrings\", \"wasiRightsToMuslOFlags\", \"wasiOFlagsToMuslOFlags\", \"safeSetTimeout\", \"setImmediateWrapped\", \"safeRequestAnimationFrame\", \"clearImmediateWrapped\", \"registerPostMainLoop\", \"registerPreMainLoop\", \"getPromise\", \"makePromise\", \"idsToPromises\", \"makePromiseCallback\", \"Browser_asyncPrepareDataCounter\", \"isLeapYear\", \"ydayFromDate\", \"arraySum\", \"addDays\", \"getSocketFromFD\", \"getSocketAddress\", \"FS_mkdirTree\", \"_setNetworkCallback\", \"heapObjectForWebGLType\", \"toTypedArrayIndex\", \"webgl_enable_ANGLE_instanced_arrays\", \"webgl_enable_OES_vertex_array_object\", \"webgl_enable_WEBGL_draw_buffers\", \"webgl_enable_WEBGL_multi_draw\", \"webgl_enable_EXT_polygon_offset_clamp\", \"webgl_enable_EXT_clip_control\", \"webgl_enable_WEBGL_polygon_mode\", \"emscriptenWebGLGet\", \"computeUnpackAlignedImageSize\", \"colorChannelsInGlTextureFormat\", \"emscriptenWebGLGetTexPixelData\", \"emscriptenWebGLGetUniform\", \"webglGetUniformLocation\", \"webglPrepareUniformLocationsBeforeFirstUse\", \"webglGetLeftBracePos\", \"emscriptenWebGLGetVertexAttrib\", \"__glGetActiveAttribOrUniform\", \"writeGLArray\", \"emscripten_webgl_destroy_context_before_on_calling_thread\", \"registerWebGlEventCallback\", \"runAndAbortIfError\", \"ALLOC_NORMAL\", \"ALLOC_STACK\", \"allocate\", \"writeStringToMemory\", \"writeAsciiToMemory\", \"demangle\", \"stackTrace\", \"getFunctionArgsName\", \"createJsInvokerSignature\", \"PureVirtualError\", \"registerInheritedInstance\", \"unregisterInheritedInstance\", \"getInheritedInstanceCount\", \"getLiveInheritedInstances\", \"enumReadValueFromPointer\", \"setDelayFunction\" ];\r\n\r\nmissingLibrarySymbols.forEach(missingLibrarySymbol);\r\n\r\nvar unexportedSymbols = [ \"run\", \"addRunDependency\", \"removeRunDependency\", \"out\", \"err\", \"callMain\", \"abort\", \"wasmMemory\", \"wasmExports\", \"HEAPF64\", \"HEAP8\", \"HEAP16\", \"HEAPU16\", \"HEAPU32\", \"HEAP64\", \"HEAPU64\", \"GROWABLE_HEAP_I8\", \"GROWABLE_HEAP_U8\", \"GROWABLE_HEAP_I16\", \"GROWABLE_HEAP_U16\", \"GROWABLE_HEAP_I32\", \"GROWABLE_HEAP_U32\", \"GROWABLE_HEAP_F32\", \"GROWABLE_HEAP_F64\", \"writeStackCookie\", \"checkStackCookie\", \"INT53_MAX\", \"INT53_MIN\", \"bigintToI53Checked\", \"stackSave\", \"stackRestore\", \"stackAlloc\", \"setTempRet0\", \"ptrToString\", \"exitJS\", \"getHeapMax\", \"growMemory\", \"ENV\", \"ERRNO_CODES\", \"strError\", \"DNS\", \"Protocols\", \"Sockets\", \"timers\", \"warnOnce\", \"readEmAsmArgsArray\", \"handleException\", \"keepRuntimeAlive\", \"runtimeKeepalivePush\", \"runtimeKeepalivePop\", \"callUserCallback\", \"maybeExit\", \"asyncLoad\", \"alignMemory\", \"mmapAlloc\", \"wasmTable\", \"noExitRuntime\", \"addOnPreRun\", \"getCFunc\", \"freeTableIndexes\", \"functionsInTableMap\", \"setValue\", \"getValue\", \"PATH\", \"PATH_FS\", \"UTF8Decoder\", \"UTF8ArrayToString\", \"UTF8ToString\", \"stringToUTF8Array\", \"stringToUTF8\", \"lengthBytesUTF8\", \"intArrayFromString\", \"UTF16Decoder\", \"UTF16ToString\", \"stringToUTF16\", \"lengthBytesUTF16\", \"UTF32ToString\", \"stringToUTF32\", \"lengthBytesUTF32\", \"stringToUTF8OnStack\", \"writeArrayToMemory\", \"JSEvents\", \"specialHTMLTargets\", \"findCanvasEventTarget\", \"currentFullscreenStrategy\", \"restoreOldWindowedStyle\", \"UNWIND_CACHE\", \"ExitStatus\", \"checkWasiClock\", \"doReadv\", \"doWritev\", \"initRandomFill\", \"randomFill\", \"emSetImmediate\", \"emClearImmediate_deps\", \"emClearImmediate\", \"promiseMap\", \"uncaughtExceptionCount\", \"exceptionLast\", \"exceptionCaught\", \"ExceptionInfo\", \"findMatchingCatch\", \"getExceptionMessageCommon\", \"Browser\", \"getPreloadedImageData__data\", \"wget\", \"MONTH_DAYS_REGULAR\", \"MONTH_DAYS_LEAP\", \"MONTH_DAYS_REGULAR_CUMULATIVE\", \"MONTH_DAYS_LEAP_CUMULATIVE\", \"SYSCALLS\", \"preloadPlugins\", \"FS_createPreloadedFile\", \"FS_modeStringToFlags\", \"FS_getMode\", \"FS_stdin_getChar_buffer\", \"FS_stdin_getChar\", \"FS_unlink\", \"FS_createPath\", \"FS_createDevice\", \"FS_readFile\", \"FS\", \"FS_root\", \"FS_mounts\", \"FS_devices\", \"FS_streams\", \"FS_nextInode\", \"FS_nameTable\", \"FS_currentPath\", \"FS_initialized\", \"FS_ignorePermissions\", \"FS_filesystems\", \"FS_syncFSRequests\", \"FS_lookupPath\", \"FS_getPath\", \"FS_hashName\", \"FS_hashAddNode\", \"FS_hashRemoveNode\", \"FS_lookupNode\", \"FS_createNode\", \"FS_destroyNode\", \"FS_isRoot\", \"FS_isMountpoint\", \"FS_isFile\", \"FS_isDir\", \"FS_isLink\", \"FS_isChrdev\", \"FS_isBlkdev\", \"FS_isFIFO\", \"FS_isSocket\", \"FS_flagsToPermissionString\", \"FS_nodePermissions\", \"FS_mayLookup\", \"FS_mayCreate\", \"FS_mayDelete\", \"FS_mayOpen\", \"FS_checkOpExists\", \"FS_nextfd\", \"FS_getStreamChecked\", \"FS_getStream\", \"FS_createStream\", \"FS_closeStream\", \"FS_dupStream\", \"FS_doSetAttr\", \"FS_chrdev_stream_ops\", \"FS_major\", \"FS_minor\", \"FS_makedev\", \"FS_registerDevice\", \"FS_getDevice\", \"FS_getMounts\", \"FS_syncfs\", \"FS_mount\", \"FS_unmount\", \"FS_lookup\", \"FS_mknod\", \"FS_statfs\", \"FS_statfsStream\", \"FS_statfsNode\", \"FS_create\", \"FS_mkdir\", \"FS_mkdev\", \"FS_symlink\", \"FS_rename\", \"FS_rmdir\", \"FS_readdir\", \"FS_readlink\", \"FS_stat\", \"FS_fstat\", \"FS_lstat\", \"FS_doChmod\", \"FS_chmod\", \"FS_lchmod\", \"FS_fchmod\", \"FS_doChown\", \"FS_chown\", \"FS_lchown\", \"FS_fchown\", \"FS_doTruncate\", \"FS_truncate\", \"FS_ftruncate\", \"FS_utime\", \"FS_open\", \"FS_close\", \"FS_isClosed\", \"FS_llseek\", \"FS_read\", \"FS_write\", \"FS_mmap\", \"FS_msync\", \"FS_ioctl\", \"FS_writeFile\", \"FS_cwd\", \"FS_chdir\", \"FS_createDefaultDirectories\", \"FS_createDefaultDevices\", \"FS_createSpecialDirectories\", \"FS_createStandardStreams\", \"FS_staticInit\", \"FS_init\", \"FS_quit\", \"FS_findObject\", \"FS_analyzePath\", \"FS_createFile\", \"FS_createDataFile\", \"FS_forceLoadFile\", \"FS_createLazyFile\", \"FS_absolutePath\", \"FS_createFolder\", \"FS_createLink\", \"FS_joinPath\", \"FS_mmapAlloc\", \"FS_standardizePath\", \"MEMFS\", \"TTY\", \"PIPEFS\", \"SOCKFS\", \"tempFixedLengthArray\", \"miniTempWebGLFloatBuffers\", \"miniTempWebGLIntBuffers\", \"GL\", \"AL\", \"GLUT\", \"EGL\", \"GLEW\", \"IDBStore\", \"SDL\", \"SDL_gfx\", \"allocateUTF8\", \"allocateUTF8OnStack\", \"print\", \"printErr\", \"jstoi_s\", \"PThread\", \"terminateWorker\", \"cleanupThread\", \"registerTLSInit\", \"spawnThread\", \"exitOnMainThread\", \"proxyToMainThread\", \"proxiedJSCallArgs\", \"invokeEntryPoint\", \"checkMailbox\", \"InternalError\", \"BindingError\", \"throwInternalError\", \"throwBindingError\", \"registeredTypes\", \"awaitingDependencies\", \"typeDependencies\", \"tupleRegistrations\", \"structRegistrations\", \"sharedRegisterType\", \"whenDependentTypesAreResolved\", \"embind_charCodes\", \"embind_init_charCodes\", \"readLatin1String\", \"getTypeName\", \"getFunctionName\", \"heap32VectorToArray\", \"requireRegisteredType\", \"usesDestructorStack\", \"checkArgCount\", \"getRequiredArgCount\", \"createJsInvoker\", \"UnboundTypeError\", \"GenericWireTypeSize\", \"EmValType\", \"EmValOptionalType\", \"throwUnboundTypeError\", \"ensureOverloadTable\", \"exposePublicSymbol\", \"replacePublicSymbol\", \"createNamedFunction\", \"embindRepr\", \"registeredInstances\", \"getBasestPointer\", \"getInheritedInstance\", \"registeredPointers\", \"registerType\", \"integerReadValueFromPointer\", \"floatReadValueFromPointer\", \"readPointer\", \"runDestructors\", \"craftInvokerFunction\", \"embind__requireFunction\", \"genericPointerToWireType\", \"constNoSmartPtrRawPointerToWireType\", \"nonConstNoSmartPtrRawPointerToWireType\", \"init_RegisteredPointer\", \"RegisteredPointer\", \"RegisteredPointer_fromWireType\", \"runDestructor\", \"releaseClassHandle\", \"finalizationRegistry\", \"detachFinalizer_deps\", \"detachFinalizer\", \"attachFinalizer\", \"makeClassHandle\", \"init_ClassHandle\", \"ClassHandle\", \"throwInstanceAlreadyDeleted\", \"deletionQueue\", \"flushPendingDeletes\", \"delayFunction\", \"RegisteredClass\", \"shallowCopyInternalPointer\", \"downcastPointer\", \"upcastPointer\", \"validateThis\", \"char_0\", \"char_9\", \"makeLegalFunctionName\", \"emval_freelist\", \"emval_handles\", \"emval_symbols\", \"init_emval\", \"count_emval_handles\", \"getStringOrSymbol\", \"Emval\", \"emval_get_global\", \"emval_returnValue\", \"emval_lookupTypes\", \"emval_methodCallers\", \"emval_addMethodCaller\", \"reflectConstruct\" ];\r\n\r\nunexportedSymbols.forEach(unexportedRuntimeSymbol);\r\n\r\n// End runtime exports\r\n// Begin JS library exports\r\nModule[\"incrementExceptionRefcount\"] = incrementExceptionRefcount;\r\n\r\nModule[\"decrementExceptionRefcount\"] = decrementExceptionRefcount;\r\n\r\nModule[\"getExceptionMessage\"] = getExceptionMessage;\r\n\r\n// End JS library exports\r\n// end include: postlibrary.js\r\n// proxiedFunctionTable specifies the list of functions that can be called\r\n// either synchronously or asynchronously from other threads in postMessage()d\r\n// or internally queued events. This way a pthread in a Worker can synchronously\r\n// access e.g. the DOM on the main thread.\r\nvar proxiedFunctionTable = [ _proc_exit, exitOnMainThread, pthreadCreateProxied, _fd_close, _fd_read, _fd_seek, _fd_write ];\r\n\r\nfunction checkIncomingModuleAPI() {\r\n  ignoredModuleProp(\"ENVIRONMENT\");\r\n  ignoredModuleProp(\"GL_MAX_TEXTURE_IMAGE_UNITS\");\r\n  ignoredModuleProp(\"SDL_canPlayWithWebAudio\");\r\n  ignoredModuleProp(\"SDL_numSimultaneouslyQueuedBuffers\");\r\n  ignoredModuleProp(\"INITIAL_MEMORY\");\r\n  ignoredModuleProp(\"wasmMemory\");\r\n  ignoredModuleProp(\"arguments\");\r\n  ignoredModuleProp(\"buffer\");\r\n  ignoredModuleProp(\"canvas\");\r\n  ignoredModuleProp(\"doNotCaptureKeyboard\");\r\n  ignoredModuleProp(\"dynamicLibraries\");\r\n  ignoredModuleProp(\"elementPointerLock\");\r\n  ignoredModuleProp(\"extraStackTrace\");\r\n  ignoredModuleProp(\"forcedAspectRatio\");\r\n  ignoredModuleProp(\"instantiateWasm\");\r\n  ignoredModuleProp(\"keyboardListeningElement\");\r\n  ignoredModuleProp(\"freePreloadedMediaOnUse\");\r\n  ignoredModuleProp(\"loadSplitModule\");\r\n  ignoredModuleProp(\"logReadFiles\");\r\n  ignoredModuleProp(\"mainScriptUrlOrBlob\");\r\n  ignoredModuleProp(\"mem\");\r\n  ignoredModuleProp(\"monitorRunDependencies\");\r\n  ignoredModuleProp(\"noExitRuntime\");\r\n  ignoredModuleProp(\"noInitialRun\");\r\n  ignoredModuleProp(\"onAbort\");\r\n  ignoredModuleProp(\"onCustomMessage\");\r\n  ignoredModuleProp(\"onExit\");\r\n  ignoredModuleProp(\"onFree\");\r\n  ignoredModuleProp(\"onFullScreen\");\r\n  ignoredModuleProp(\"onMalloc\");\r\n  ignoredModuleProp(\"onRealloc\");\r\n  ignoredModuleProp(\"onRuntimeInitialized\");\r\n  ignoredModuleProp(\"postMainLoop\");\r\n  ignoredModuleProp(\"postRun\");\r\n  ignoredModuleProp(\"preInit\");\r\n  ignoredModuleProp(\"preMainLoop\");\r\n  ignoredModuleProp(\"preRun\");\r\n  ignoredModuleProp(\"preinitializedWebGLContext\");\r\n  ignoredModuleProp(\"preloadPlugins\");\r\n  ignoredModuleProp(\"print\");\r\n  ignoredModuleProp(\"printErr\");\r\n  ignoredModuleProp(\"setStatus\");\r\n  ignoredModuleProp(\"statusMessage\");\r\n  ignoredModuleProp(\"stderr\");\r\n  ignoredModuleProp(\"stdin\");\r\n  ignoredModuleProp(\"stdout\");\r\n  ignoredModuleProp(\"thisProgram\");\r\n  ignoredModuleProp(\"wasm\");\r\n  ignoredModuleProp(\"wasmBinary\");\r\n  ignoredModuleProp(\"websocket\");\r\n  ignoredModuleProp(\"fetchSettings\");\r\n}\r\n\r\nvar wasmImports;\r\n\r\nfunction assignWasmImports() {\r\n  wasmImports = {\r\n    /** @export */ __assert_fail: ___assert_fail,\r\n    /** @export */ __cxa_begin_catch: ___cxa_begin_catch,\r\n    /** @export */ __cxa_find_matching_catch_2: ___cxa_find_matching_catch_2,\r\n    /** @export */ __cxa_find_matching_catch_3: ___cxa_find_matching_catch_3,\r\n    /** @export */ __cxa_rethrow_primary_exception: ___cxa_rethrow_primary_exception,\r\n    /** @export */ __cxa_throw: ___cxa_throw,\r\n    /** @export */ __pthread_create_js: ___pthread_create_js,\r\n    /** @export */ __resumeException: ___resumeException,\r\n    /** @export */ _abort_js: __abort_js,\r\n    /** @export */ _embind_finalize_value_object: __embind_finalize_value_object,\r\n    /** @export */ _embind_register_bigint: __embind_register_bigint,\r\n    /** @export */ _embind_register_bool: __embind_register_bool,\r\n    /** @export */ _embind_register_class: __embind_register_class,\r\n    /** @export */ _embind_register_class_constructor: __embind_register_class_constructor,\r\n    /** @export */ _embind_register_class_function: __embind_register_class_function,\r\n    /** @export */ _embind_register_class_property: __embind_register_class_property,\r\n    /** @export */ _embind_register_emval: __embind_register_emval,\r\n    /** @export */ _embind_register_float: __embind_register_float,\r\n    /** @export */ _embind_register_function: __embind_register_function,\r\n    /** @export */ _embind_register_integer: __embind_register_integer,\r\n    /** @export */ _embind_register_memory_view: __embind_register_memory_view,\r\n    /** @export */ _embind_register_optional: __embind_register_optional,\r\n    /** @export */ _embind_register_std_string: __embind_register_std_string,\r\n    /** @export */ _embind_register_std_wstring: __embind_register_std_wstring,\r\n    /** @export */ _embind_register_value_object: __embind_register_value_object,\r\n    /** @export */ _embind_register_value_object_field: __embind_register_value_object_field,\r\n    /** @export */ _embind_register_void: __embind_register_void,\r\n    /** @export */ _emscripten_init_main_thread_js: __emscripten_init_main_thread_js,\r\n    /** @export */ _emscripten_notify_mailbox_postmessage: __emscripten_notify_mailbox_postmessage,\r\n    /** @export */ _emscripten_receive_on_main_thread_js: __emscripten_receive_on_main_thread_js,\r\n    /** @export */ _emscripten_thread_cleanup: __emscripten_thread_cleanup,\r\n    /** @export */ _emscripten_thread_mailbox_await: __emscripten_thread_mailbox_await,\r\n    /** @export */ _emscripten_thread_set_strongref: __emscripten_thread_set_strongref,\r\n    /** @export */ _emval_call_method: __emval_call_method,\r\n    /** @export */ _emval_decref: __emval_decref,\r\n    /** @export */ _emval_get_global: __emval_get_global,\r\n    /** @export */ _emval_get_method_caller: __emval_get_method_caller,\r\n    /** @export */ _emval_run_destructors: __emval_run_destructors,\r\n    /** @export */ _emval_take_value: __emval_take_value,\r\n    /** @export */ clock_time_get: _clock_time_get,\r\n    /** @export */ emscripten_check_blocking_allowed: _emscripten_check_blocking_allowed,\r\n    /** @export */ emscripten_exit_with_live_runtime: _emscripten_exit_with_live_runtime,\r\n    /** @export */ emscripten_get_heap_max: _emscripten_get_heap_max,\r\n    /** @export */ emscripten_get_now: _emscripten_get_now,\r\n    /** @export */ emscripten_num_logical_cores: _emscripten_num_logical_cores,\r\n    /** @export */ emscripten_resize_heap: _emscripten_resize_heap,\r\n    /** @export */ emscripten_runtime_keepalive_check: _emscripten_runtime_keepalive_check,\r\n    /** @export */ exit: _exit,\r\n    /** @export */ fd_close: _fd_close,\r\n    /** @export */ fd_read: _fd_read,\r\n    /** @export */ fd_seek: _fd_seek,\r\n    /** @export */ fd_write: _fd_write,\r\n    /** @export */ invoke_i,\r\n    /** @export */ invoke_ii,\r\n    /** @export */ invoke_iii,\r\n    /** @export */ invoke_iiii,\r\n    /** @export */ invoke_v,\r\n    /** @export */ invoke_vi,\r\n    /** @export */ invoke_vii,\r\n    /** @export */ invoke_viii,\r\n    /** @export */ invoke_viiii,\r\n    /** @export */ memory: wasmMemory,\r\n    /** @export */ random_get: _random_get\r\n  };\r\n}\r\n\r\nvar wasmExports = await createWasm();\r\n\r\nvar ___wasm_call_ctors = createExportWrapper(\"__wasm_call_ctors\", 0);\r\n\r\nvar ___getTypeName = createExportWrapper(\"__getTypeName\", 1);\r\n\r\nvar __embind_initialize_bindings = createExportWrapper(\"_embind_initialize_bindings\", 0);\r\n\r\nvar _stepSimulation = Module[\"_stepSimulation\"] = createExportWrapper(\"stepSimulation\", 1);\r\n\r\nvar _currentFirstBoidX = Module[\"_currentFirstBoidX\"] = createExportWrapper(\"currentFirstBoidX\", 0);\r\n\r\nvar _build = Module[\"_build\"] = createExportWrapper(\"build\", 2);\r\n\r\nvar _posPtr = Module[\"_posPtr\"] = createExportWrapper(\"posPtr\", 0);\r\n\r\nvar _velPtr = Module[\"_velPtr\"] = createExportWrapper(\"velPtr\", 0);\r\n\r\nvar _oriPtr = Module[\"_oriPtr\"] = createExportWrapper(\"oriPtr\", 0);\r\n\r\nvar _boidCount = Module[\"_boidCount\"] = createExportWrapper(\"boidCount\", 0);\r\n\r\nvar _update = Module[\"_update\"] = createExportWrapper(\"update\", 1);\r\n\r\nvar _setFlockSize = Module[\"_setFlockSize\"] = createExportWrapper(\"setFlockSize\", 3);\r\n\r\nvar _setSpeciesParams = Module[\"_setSpeciesParams\"] = createExportWrapper(\"setSpeciesParams\", 2);\r\n\r\nvar _boidUnitMappingPtr = Module[\"_boidUnitMappingPtr\"] = createExportWrapper(\"boidUnitMappingPtr\", 0);\r\n\r\nvar _free = Module[\"_free\"] = createExportWrapper(\"free\", 1);\r\n\r\nvar _pthread_self = () => (_pthread_self = wasmExports[\"pthread_self\"])();\r\n\r\nvar _malloc = Module[\"_malloc\"] = createExportWrapper(\"malloc\", 1);\r\n\r\nvar _main = Module[\"_main\"] = createExportWrapper(\"main\", 2);\r\n\r\nvar __emscripten_tls_init = createExportWrapper(\"_emscripten_tls_init\", 0);\r\n\r\nvar __emscripten_proxy_main = Module[\"__emscripten_proxy_main\"] = createExportWrapper(\"_emscripten_proxy_main\", 2);\r\n\r\nvar _emscripten_stack_get_base = () => (_emscripten_stack_get_base = wasmExports[\"emscripten_stack_get_base\"])();\r\n\r\nvar _emscripten_stack_get_end = () => (_emscripten_stack_get_end = wasmExports[\"emscripten_stack_get_end\"])();\r\n\r\nvar __emscripten_thread_init = createExportWrapper(\"_emscripten_thread_init\", 6);\r\n\r\nvar __emscripten_thread_crashed = createExportWrapper(\"_emscripten_thread_crashed\", 0);\r\n\r\nvar _fflush = createExportWrapper(\"fflush\", 1);\r\n\r\nvar __emscripten_run_on_main_thread_js = createExportWrapper(\"_emscripten_run_on_main_thread_js\", 5);\r\n\r\nvar __emscripten_thread_free_data = createExportWrapper(\"_emscripten_thread_free_data\", 1);\r\n\r\nvar __emscripten_thread_exit = createExportWrapper(\"_emscripten_thread_exit\", 1);\r\n\r\nvar _strerror = createExportWrapper(\"strerror\", 1);\r\n\r\nvar __emscripten_check_mailbox = createExportWrapper(\"_emscripten_check_mailbox\", 0);\r\n\r\nvar _setThrew = createExportWrapper(\"setThrew\", 2);\r\n\r\nvar __emscripten_tempret_set = createExportWrapper(\"_emscripten_tempret_set\", 1);\r\n\r\nvar _emscripten_stack_init = () => (_emscripten_stack_init = wasmExports[\"emscripten_stack_init\"])();\r\n\r\nvar _emscripten_stack_set_limits = (a0, a1) => (_emscripten_stack_set_limits = wasmExports[\"emscripten_stack_set_limits\"])(a0, a1);\r\n\r\nvar _emscripten_stack_get_free = () => (_emscripten_stack_get_free = wasmExports[\"emscripten_stack_get_free\"])();\r\n\r\nvar __emscripten_stack_restore = a0 => (__emscripten_stack_restore = wasmExports[\"_emscripten_stack_restore\"])(a0);\r\n\r\nvar __emscripten_stack_alloc = a0 => (__emscripten_stack_alloc = wasmExports[\"_emscripten_stack_alloc\"])(a0);\r\n\r\nvar _emscripten_stack_get_current = () => (_emscripten_stack_get_current = wasmExports[\"emscripten_stack_get_current\"])();\r\n\r\nvar ___cxa_decrement_exception_refcount = createExportWrapper(\"__cxa_decrement_exception_refcount\", 1);\r\n\r\nvar ___cxa_increment_exception_refcount = createExportWrapper(\"__cxa_increment_exception_refcount\", 1);\r\n\r\nvar ___cxa_free_exception = createExportWrapper(\"__cxa_free_exception\", 1);\r\n\r\nvar ___get_exception_message = createExportWrapper(\"__get_exception_message\", 3);\r\n\r\nvar ___cxa_can_catch = createExportWrapper(\"__cxa_can_catch\", 3);\r\n\r\nvar ___cxa_get_exception_ptr = createExportWrapper(\"__cxa_get_exception_ptr\", 1);\r\n\r\nfunction invoke_ii(index, a1) {\r\n  var sp = stackSave();\r\n  try {\r\n    return getWasmTableEntry(index)(a1);\r\n  } catch (e) {\r\n    stackRestore(sp);\r\n    if (!(e instanceof EmscriptenEH)) throw e;\r\n    _setThrew(1, 0);\r\n  }\r\n}\r\n\r\nfunction invoke_iii(index, a1, a2) {\r\n  var sp = stackSave();\r\n  try {\r\n    return getWasmTableEntry(index)(a1, a2);\r\n  } catch (e) {\r\n    stackRestore(sp);\r\n    if (!(e instanceof EmscriptenEH)) throw e;\r\n    _setThrew(1, 0);\r\n  }\r\n}\r\n\r\nfunction invoke_vii(index, a1, a2) {\r\n  var sp = stackSave();\r\n  try {\r\n    getWasmTableEntry(index)(a1, a2);\r\n  } catch (e) {\r\n    stackRestore(sp);\r\n    if (!(e instanceof EmscriptenEH)) throw e;\r\n    _setThrew(1, 0);\r\n  }\r\n}\r\n\r\nfunction invoke_iiii(index, a1, a2, a3) {\r\n  var sp = stackSave();\r\n  try {\r\n    return getWasmTableEntry(index)(a1, a2, a3);\r\n  } catch (e) {\r\n    stackRestore(sp);\r\n    if (!(e instanceof EmscriptenEH)) throw e;\r\n    _setThrew(1, 0);\r\n  }\r\n}\r\n\r\nfunction invoke_vi(index, a1) {\r\n  var sp = stackSave();\r\n  try {\r\n    getWasmTableEntry(index)(a1);\r\n  } catch (e) {\r\n    stackRestore(sp);\r\n    if (!(e instanceof EmscriptenEH)) throw e;\r\n    _setThrew(1, 0);\r\n  }\r\n}\r\n\r\nfunction invoke_i(index) {\r\n  var sp = stackSave();\r\n  try {\r\n    return getWasmTableEntry(index)();\r\n  } catch (e) {\r\n    stackRestore(sp);\r\n    if (!(e instanceof EmscriptenEH)) throw e;\r\n    _setThrew(1, 0);\r\n  }\r\n}\r\n\r\nfunction invoke_v(index) {\r\n  var sp = stackSave();\r\n  try {\r\n    getWasmTableEntry(index)();\r\n  } catch (e) {\r\n    stackRestore(sp);\r\n    if (!(e instanceof EmscriptenEH)) throw e;\r\n    _setThrew(1, 0);\r\n  }\r\n}\r\n\r\nfunction invoke_viiii(index, a1, a2, a3, a4) {\r\n  var sp = stackSave();\r\n  try {\r\n    getWasmTableEntry(index)(a1, a2, a3, a4);\r\n  } catch (e) {\r\n    stackRestore(sp);\r\n    if (!(e instanceof EmscriptenEH)) throw e;\r\n    _setThrew(1, 0);\r\n  }\r\n}\r\n\r\nfunction invoke_viii(index, a1, a2, a3) {\r\n  var sp = stackSave();\r\n  try {\r\n    getWasmTableEntry(index)(a1, a2, a3);\r\n  } catch (e) {\r\n    stackRestore(sp);\r\n    if (!(e instanceof EmscriptenEH)) throw e;\r\n    _setThrew(1, 0);\r\n  }\r\n}\r\n\r\n// include: postamble.js\r\n// === Auto-generated postamble setup entry stuff ===\r\nvar calledRun;\r\n\r\nfunction callMain() {\r\n  assert(runDependencies == 0, 'cannot call main when async dependencies remain! (listen on Module[\"onRuntimeInitialized\"])');\r\n  assert(typeof onPreRuns === \"undefined\" || onPreRuns.length == 0, \"cannot call main when preRun functions remain to be called\");\r\n  var entryFunction = __emscripten_proxy_main;\r\n  // With PROXY_TO_PTHREAD make sure we keep the runtime alive until the\r\n  // proxied main calls exit (see exitOnMainThread() for where Pop is called).\r\n  runtimeKeepalivePush();\r\n  var argc = 0;\r\n  var argv = 0;\r\n  try {\r\n    var ret = entryFunction(argc, argv);\r\n    // if we're not running an evented main loop, it's time to exit\r\n    exitJS(ret, /* implicit = */ true);\r\n    return ret;\r\n  } catch (e) {\r\n    return handleException(e);\r\n  }\r\n}\r\n\r\nfunction stackCheckInit() {\r\n  // This is normally called automatically during __wasm_call_ctors but need to\r\n  // get these values before even running any of the ctors so we call it redundantly\r\n  // here.\r\n  // See $establishStackSpace for the equivalent code that runs on a thread\r\n  assert(!ENVIRONMENT_IS_PTHREAD);\r\n  _emscripten_stack_init();\r\n  // TODO(sbc): Move writeStackCookie to native to to avoid this.\r\n  writeStackCookie();\r\n}\r\n\r\nfunction run() {\r\n  if (runDependencies > 0) {\r\n    dependenciesFulfilled = run;\r\n    return;\r\n  }\r\n  if ((ENVIRONMENT_IS_PTHREAD)) {\r\n    readyPromiseResolve(Module);\r\n    initRuntime();\r\n    return;\r\n  }\r\n  stackCheckInit();\r\n  preRun();\r\n  // a preRun added a dependency, run will be called later\r\n  if (runDependencies > 0) {\r\n    dependenciesFulfilled = run;\r\n    return;\r\n  }\r\n  function doRun() {\r\n    // run may have just been called through dependencies being fulfilled just in this very frame,\r\n    // or while the async setStatus time below was happening\r\n    assert(!calledRun);\r\n    calledRun = true;\r\n    Module[\"calledRun\"] = true;\r\n    if (ABORT) return;\r\n    initRuntime();\r\n    preMain();\r\n    readyPromiseResolve(Module);\r\n    var noInitialRun = false;\r\n    if (!noInitialRun) callMain();\r\n    postRun();\r\n  }\r\n  {\r\n    doRun();\r\n  }\r\n  checkStackCookie();\r\n}\r\n\r\nfunction checkUnflushedContent() {\r\n  // Compiler settings do not allow exiting the runtime, so flushing\r\n  // the streams is not possible. but in ASSERTIONS mode we check\r\n  // if there was something to flush, and if so tell the user they\r\n  // should request that the runtime be exitable.\r\n  // Normally we would not even include flush() at all, but in ASSERTIONS\r\n  // builds we do so just for this check, and here we see if there is any\r\n  // content to flush, that is, we check if there would have been\r\n  // something a non-ASSERTIONS build would have not seen.\r\n  // How we flush the streams depends on whether we are in SYSCALLS_REQUIRE_FILESYSTEM=0\r\n  // mode (which has its own special function for this; otherwise, all\r\n  // the code is inside libc)\r\n  var oldOut = out;\r\n  var oldErr = err;\r\n  var has = false;\r\n  out = err = x => {\r\n    has = true;\r\n  };\r\n  try {\r\n    // it doesn't matter if it fails\r\n    _fflush(0);\r\n    // also flush in the JS FS layer\r\n    [ \"stdout\", \"stderr\" ].forEach(name => {\r\n      var info = FS.analyzePath(\"/dev/\" + name);\r\n      if (!info) return;\r\n      var stream = info.object;\r\n      var rdev = stream.rdev;\r\n      var tty = TTY.ttys[rdev];\r\n      if (tty?.output?.length) {\r\n        has = true;\r\n      }\r\n    });\r\n  } catch (e) {}\r\n  out = oldOut;\r\n  err = oldErr;\r\n  if (has) {\r\n    warnOnce(\"stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the Emscripten FAQ), or make sure to emit a newline when you printf etc.\");\r\n  }\r\n}\r\n\r\nfunction preInit() {}\r\n\r\npreInit();\r\n\r\nrun();\r\n\r\n// end include: postamble.js\r\n// include: postamble_modularize.js\r\n// In MODULARIZE mode we wrap the generated code in a factory function\r\n// and return either the Module itself, or a promise of the module.\r\n// We assign to the `moduleRtn` global here and configure closure to see\r\n// this as and extern so it won't get minified.\r\nmoduleRtn = readyPromise;\r\n\r\n// Assertion for attempting to access module properties on the incoming\r\n// moduleArg.  In the past we used this object as the prototype of the module\r\n// and assigned properties to it, but now we return a distinct object.  This\r\n// keeps the instance private until it is ready (i.e the promise has been\r\n// resolved).\r\nfor (const prop of Object.keys(Module)) {\r\n  if (!(prop in moduleArg)) {\r\n    Object.defineProperty(moduleArg, prop, {\r\n      configurable: true,\r\n      get() {\r\n        abort(`Access to module property ('${prop}') is no longer possible via the module constructor argument; Instead, use the result of the module constructor.`);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\n\r\n  return moduleRtn;\r\n}\r\n);\r\n})();\r\nexport default createBoidsModule;\r\nvar isPthread = globalThis.self?.name?.startsWith('em-pthread');\r\nvar isNode = typeof globalThis.process?.versions?.node == 'string';\r\nif (isNode) isPthread = (await import('worker_threads')).workerData === 'em-pthread';\r\n\r\n// When running as a pthread, construct a new instance on startup\r\nisPthread && createBoidsModule();\r\n"],"names":["createBoidsModule","moduleArg","moduleRtn","readyPromiseResolve","readyPromiseReject","Module","readyPromise","Promise","resolve","reject","ENVIRONMENT_IS_WEB","window","ENVIRONMENT_IS_WORKER","WorkerGlobalScope","ENVIRONMENT_IS_NODE","process","versions","node","type","ENVIRONMENT_IS_SHELL","ENVIRONMENT_IS_PTHREAD","self","name","startsWith","assert","globalThis","moduleLoaded","createRequire","require","worker_threads","g","Worker","isMainThread","readAsync","readBinary","quit_","status","toThrow","_scriptName","scriptDirectory","locateFile","path","release","Error","nodeVersion","numericVersion","split","slice","fs","nodePath","dirname","fileURLToPath","filename","isFileURI","URL","ret","readFileSync","Buffer","isBuffer","async","binary","undefined","argv","length","replace","exitCode","href","url","xhr","XMLHttpRequest","open","responseType","send","Uint8Array","response","fetch","credentials","ok","arrayBuffer","defaultPrint","console","log","bind","defaultPrintErr","error","utils","stringify","a","inspect","args","writeSync","map","join","wasmBinary","wasmMemory","wasmModule","out","err","WebAssembly","EXITSTATUS","HEAP8","HEAPU8","HEAP16","HEAPU16","HEAP32","HEAPU32","HEAPF32","HEAP64","HEAPU64","HEAPF64","ABORT","condition","text","abort","runtimeInitialized","writeStackCookie","max","_emscripten_stack_get_end","GROWABLE_HEAP_U32","checkStackCookie","cookie1","cookie2","ptrToString","EmscriptenEH","CppException","constructor","excPtr","super","this","excInfo","getExceptionMessage","message","wasmModuleReceived","runtimeDebug","dbg","warn","ignoredModuleProp","prop","Object","getOwnPropertyDescriptor","isExportedByForceFilesystem","hookGlobalSymbolAccess","sym","func","defineProperty","configurable","get","missingGlobal","msg","warnOnce","missingLibrarySymbol","librarySymbol","unexportedRuntimeSymbol","initWorkerLogging","getLogPrefix","t","_pthread_self","workerID","origDbg","GROWABLE_HEAP_I8","buffer","updateMemoryViews","GROWABLE_HEAP_U8","GROWABLE_HEAP_I16","GROWABLE_HEAP_U16","GROWABLE_HEAP_I32","GROWABLE_HEAP_F32","GROWABLE_HEAP_F64","h16","Int16Array","h8","Int8Array","parentPort","on","onmessage","data","assign","postMessage","initializedJS","handleMessage","e","msgData","cmd","messageQueue","push","startWorker","instance","handler","handlers","proxy","pthread_ptr","establishStackSpace","__emscripten_thread_init","PThread","threadInitTLS","__emscripten_thread_mailbox_await","__embind_initialize_bindings","invokeEntryPoint","start_routine","arg","ex","target","checkMailbox","stack","__emscripten_thread_crashed","onunhandledrejection","reason","b","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","BigInt64Array","BigUint64Array","initMemory","INITIAL_MEMORY","Memory","preRun","callRuntimeCallbacks","onPreRuns","initRuntime","FS","initialized","init","TTY","wasmExports","ignorePermissions","preMain","postRun","prototype","subarray","set","wasmBinaryFile","runDependencies","dependenciesFulfilled","runDependencyTracking","runDependencyWatcher","getUniqueRunDependency","id","orig","Math","random","addRunDependency","setInterval","clearInterval","shown","dep","removeRunDependency","callback","what","RuntimeError","createExportWrapper","nargs","f","findWasmBinary","getBinarySync","file","getWasmBinary","binaryFile","instantiateArrayBuffer","imports","instantiate","instantiateAsync","instantiateStreaming","instantiationResult","getWasmImports","assignWasmImports","wasmImports","createWasm","receiveInstance","module","exports","registerTLSInit","wasmTable","trueModule","receiveInstantiationResult","result","info","Instance","ExitStatus","terminateWorker","worker","terminate","cleanupThread","pthreads","returnWorkerToPool","callbacks","shift","addOnPreRun","cb","spawnThread","threadParams","getNewWorker","runningWorkers","startRoutine","unref","transferList","runtimeKeepaliveCounter","keepRuntimeAlive","stackSave","_emscripten_stack_get_current","stackRestore","val","__emscripten_stack_restore","stackAlloc","sz","__emscripten_stack_alloc","proxyToMainThread","funcIndex","emAsmAddr","sync","callArgs","serializedNumCallArgs","sp","i","rtn","__emscripten_run_on_main_thread_js","_proc_exit","code","terminateAllThreads","runtimeKeepalivePop","exitOnMainThread","returnCode","_exit","exitJS","implicit","checkUnflushedContent","ptr","toString","padStart","unusedWorkers","tlsInitFunctions","nextWorkerID","initMainThread","pthreadPoolSize","navigator","hardwareConcurrency","allocateUnusedWorker","loadWasmModuleToAllWorkers","splice","indexOf","__emscripten_thread_free_data","forEach","loadWasmModuleToWorker","onFinishedLoading","d","targetThread","targetWorker","thread","loaded","onerror","lineno","knownHandlers","propertyIsEnumerable","onMaybeReady","pthreadPoolReady","all","then","pop","stackHigh","stackSize","stackLow","_emscripten_stack_set_limits","wasmTableMirror","getWasmTableEntry","funcPtr","finish","__emscripten_thread_exit","tlsInitFunc","runtimeKeepalivePush","UTF8Decoder","TextDecoder","UTF8ArrayToString","heapOrArray","idx","maxBytesToRead","NaN","endIdx","endPtr","decode","ArrayBuffer","str","u0","u1","u2","String","fromCharCode","ch","UTF8ToString","___assert_fail","line","exceptionCaught","___cxa_begin_catch","ExceptionInfo","get_caught","set_caught","set_rethrown","___cxa_increment_exception_refcount","___cxa_get_exception_ptr","exceptionLast","set_type","get_type","set_destructor","destructor","get_destructor","caught","rethrown","get_rethrown","set_adjusted_ptr","adjustedPtr","get_adjusted_ptr","setTempRet0","__emscripten_tempret_set","findMatchingCatch","thrown","thrownType","caughtType","adjusted_ptr_addr","___cxa_can_catch","___cxa_find_matching_catch_2","___cxa_find_matching_catch_3","arg0","___cxa_rethrow","___cxa_rethrow_primary_exception","___cxa_throw","pthreadCreateProxied","attr","___pthread_create_js","_emscripten_has_threading_support","SharedArrayBuffer","___resumeException","__abort_js","structRegistrations","runDestructors","destructors","del","readPointer","pointer","embind_charCodes","awaitingDependencies","registeredTypes","typeDependencies","InternalError","throwInternalError","whenDependentTypesAreResolved","myTypes","dependentTypes","getTypeConverters","onComplete","typeConverters","myTypeConverters","registerType","Array","unregisteredTypes","registered","dt","hasOwnProperty","__embind_finalize_value_object","structType","reg","rawConstructor","rawDestructor","fieldRecords","fields","fieldTypes","field","getterReturnType","concat","setterArgumentType","fieldName","optional","getter","getterContext","setter","setterContext","read","write","o","rv","TypeError","argPackAdvance","GenericWireTypeSize","destructorFunction","embindRepr","v","embind_init_charCodes","codes","readLatin1String","c","BindingError","throwBindingError","sharedRegisterType","rawType","registeredInstance","options","ignoreDuplicateRegistrations","integerReadValueFromPointer","width","signed","__embind_register_bigint","primitiveType","size","minRange","maxRange","isUnsignedType","value","BigInt","__embind_register_bool","trueValue","falseValue","wt","shallowCopyInternalPointer","count","deleteScheduled","preservePointerOnDelete","ptrType","smartPtr","smartPtrType","throwInstanceAlreadyDeleted","obj","getInstanceTypeName","handle","$$","registeredClass","finalizationRegistry","detachFinalizer","runDestructor","releaseClassHandle","toDelete","downcastPointer","ptrClass","desiredClass","baseClass","downcast","registeredPointers","registeredInstances","getBasestPointer","class_","upcast","getInheritedInstance","makeClassHandle","record","hasSmartPtrType","hasSmartPtr","attachFinalizer","create","writable","RegisteredPointer_fromWireType","rawPointer","getPointee","makeDefaultHandle","isSmartPointer","instancePrototype","pointeeType","toType","actualType","getActualType","registeredPointerRecord","call","isConst","constPointerType","pointerType","dp","delayFunction","FinalizationRegistry","leakWarning","cls","captureStackTrace","register","unregister","deletionQueue","flushPendingDeletes","init_ClassHandle","proto","ClassHandle","other","leftClass","left","rightClass","right","clone","getPrototypeOf","symbolDispose","Symbol","dispose","createNamedFunction","ensureOverloadTable","methodName","humanName","overloadTable","prevFunc","apply","argCount","exposePublicSymbol","numArguments","char_0","char_9","makeLegalFunctionName","charCodeAt","RegisteredClass","pureVirtualFunctions","upcastPointer","constNoSmartPtrRawPointerToWireType","isReference","handleClass","genericPointerToWireType","sharingPolicy","clonedHandle","rawShare","Emval","toHandle","nonConstNoSmartPtrRawPointerToWireType","init_RegisteredPointer","RegisteredPointer","rawGetPointee","replacePublicSymbol","embind__requireFunction","signature","rawFunction","isAsync","makeDynCaller","fp","UnboundTypeError","getTypeName","___getTypeName","_free","throwUnboundTypeError","types","unboundTypes","seen","visit","__embind_register_class","rawPointerType","rawConstPointerType","baseClassRawType","getActualTypeSignature","upcastSignature","downcastSignature","destructorSignature","legalFunctionName","base","basePrototype","constructor_body","body","keys","__derivedClasses","referenceConverter","pointerConverter","constPointerConverter","heap32VectorToArray","firstElement","array","usesDestructorStack","argTypes","checkArgCount","numArgs","minArgs","maxArgs","argCountMessage","createJsInvoker","isClassMethodFunc","returns","needsDestructorStack","argsList","argsListWired","invokerFnBody","dtorStack","args1","paramName","getRequiredArgCount","requiredArgCount","craftInvokerFunction","classType","cppInvokerFunc","cppTargetFunc","expectedArgCount","closureArgs","invokerFn","Function","__embind_register_class_constructor","rawClassType","rawArgTypesAddr","invokerSignature","invoker","rawArgTypes","getFunctionName","trim","argsIndex","endsWith","__embind_register_class_function","rawInvoker","context","isPureVirtual","isNonnullReturn","unboundTypesHandler","substring","method","className","memberFunction","validateThis","this_","__embind_register_class_property","getterSignature","setterSignature","desc","enumerable","emval_freelist","emval_handles","__emval_decref","count_emval_handles","init_emval","toValue","EmValType","__embind_register_emval","floatReadValueFromPointer","__embind_register_float","__embind_register_function","fn","invokerArgsArray","__embind_register_integer","fromWireType","bitshift","toWireType","includes","checkAssertions","toTypeName","__embind_register_memory_view","dataTypeIndex","typeMapping","TA","decodeMemoryView","EmValOptionalType","__embind_register_optional","rawOptionalType","stringToUTF8Array","heap","outIdx","maxBytesToWrite","startIdx","u","stringToUTF8","outPtr","lengthBytesUTF8","len","__embind_register_std_string","stdStringIsUTF8","payload","decodeStartPtr","currentBytePtr","maxRead","stringSegment","valueIsOfTypeString","isView","BYTES_PER_ELEMENT","_malloc","charCode","UTF16Decoder","UTF16ToString","maxIdx","codeUnit","stringToUTF16","startPtr","numCharsToWrite","lengthBytesUTF16","UTF32ToString","utf32","stringToUTF32","trailSurrogate","lengthBytesUTF32","__embind_register_std_wstring","charSize","decodeString","encodeString","readCharAt","lengthBytesUTF","maxReadBytes","__embind_register_value_object","constructorSignature","__embind_register_value_object_field","__embind_register_void","isVoid","__emscripten_init_main_thread_js","tb","handleException","maybeExit","callUserCallback","Atomics","waitAsync","wait","waitingAsync","store","__emscripten_check_mailbox","__emscripten_notify_mailbox_postmessage","currThreadId","setTimeout","proxiedJSCallArgs","__emscripten_receive_on_main_thread_js","callingThread","numCallArgs","proxiedFunctionTable","currentProxiedOperationCallerThread","__emscripten_thread_cleanup","__emscripten_thread_set_strongref","ref","emval_symbols","getStringOrSymbol","address","symbol","emval_methodCallers","__emval_call_method","caller","objHandle","destructorsRef","emval_get_global","__emval_get_global","emval_addMethodCaller","requireRegisteredType","impl","emval_lookupTypes","emval_returnValue","returnType","__emval_get_method_caller","kind","retType","functionBody","offset","params","invokerFunction","functionName","__emval_run_destructors","__emval_take_value","_emscripten_get_now","performance","timeOrigin","now","_emscripten_date_now","Date","nowIsMonotonic","checkWasiClock","clock_id","INT53_MAX","INT53_MIN","bigintToI53Checked","num","Number","_clock_time_get","clk_id","ignored_precision","ptime","nsec","round","_emscripten_check_blocking_allowed","_emscripten_exit_with_live_runtime","getHeapMax","_emscripten_get_heap_max","_emscripten_num_logical_cores","cpus","alignMemory","alignment","ceil","growMemory","pages","byteLength","grow","_emscripten_resize_heap","requestedSize","oldSize","maxHeapSize","cutDown","overGrownHeapSize","min","newSize","replacement","_emscripten_runtime_keepalive_check","PATH","isAbs","charAt","splitPath","splitPathRe","exec","normalizeArray","parts","allowAboveRoot","up","last","unshift","normalize","isAbsolute","trailingSlash","filter","p","root","dir","basename","match","paths","join2","l","r","initRandomFill","nodeCrypto","view","randomFillSync","crypto","getRandomValues","randomFill","PATH_FS","resolvedPath","resolvedAbsolute","cwd","relative","from","to","arr","start","end","fromParts","toParts","samePartsLength","outputParts","FS_stdin_getChar_buffer","intArrayFromString","stringy","dontAddNull","u8array","numBytesWritten","FS_stdin_getChar","BUFSIZE","buf","alloc","bytesRead","fd","stdin","readSync","prompt","ttys","shutdown","dev","ops","input","output","registerDevice","stream_ops","stream","tty","rdev","ErrnoError","seekable","close","fsync","pos","get_char","atime","put_char","mtime","ctime","default_tty_ops","ioctl_tcgets","c_iflag","c_oflag","c_cflag","c_lflag","c_cc","ioctl_tcsets","optional_actions","ioctl_tiocgwinsz","default_tty1_ops","mmapAlloc","MEMFS","ops_table","mount","createNode","parent","mode","isBlkdev","isFIFO","getattr","node_ops","setattr","lookup","mknod","rename","unlink","rmdir","readdir","symlink","llseek","mmap","msync","link","readlink","chrdev","chrdev_stream_ops","isDir","contents","isFile","usedBytes","isLink","isChrdev","getFileDataAsTypedArray","expandFileStorage","newCapacity","prevCapacity","CAPACITY_DOUBLING_MAX","oldContents","resizeFileStorage","ino","nlink","uid","gid","blksize","blocks","key","old_node","new_dir","new_name","new_node","lookupNode","hashRemoveNode","newname","oldpath","position","canOwn","whence","prot","flags","allocated","byteOffset","mmapFlags","asyncLoad","FS_createDataFile","createDataFile","preloadPlugins","FS_handledByPreloadPlugin","byteArray","fullname","Browser","handled","plugin","FS_createPreloadedFile","canRead","canWrite","onload","dontCreateFile","preFinish","processData","FS_modeStringToFlags","flagModes","FS_getMode","strError","errno","_strerror","ERRNO_CODES","mounts","devices","streams","nextInode","nameTable","currentPath","filesystems","syncFSRequests","FSStream","shared","object","isRead","isWrite","isAppend","FSNode","readMode","writeMode","mounted","isFolder","isDevice","lookupPath","opts","follow_mount","linkloop","nlinks","current","current_path","islast","noent_okay","isMountpoint","follow","isRoot","getPath","mountpoint","hashName","parentid","hash","hashAddNode","name_next","errCode","mayLookup","nodeName","destroyNode","isSocket","flagsToPermissionString","flag","perms","nodePermissions","mayCreate","mayDelete","isdir","mayOpen","checkOpExists","op","MAX_OPEN_FDS","nextfd","getStreamChecked","getStream","createStream","closeStream","dupStream","origStream","dup","doSetAttr","device","getDevice","major","minor","makedev","ma","mi","getMounts","check","m","syncfs","populate","completed","doCallback","done","errored","pseudo","mountRoot","unmount","next","statfs","statfsNode","statfsStream","bsize","frsize","bfree","bavail","files","ffree","fsid","namelen","mkdir","mkdirTree","dirs","mkdev","newpath","old_path","new_path","old_dir","old_dirname","new_dirname","old_name","stat","dontFollow","fstat","lstat","doChmod","chmod","lchmod","fchmod","doChown","timestamp","chown","lchown","fchown","doTruncate","truncate","ftruncate","utime","isDirPath","created","ungotten","isClosed","getdents","seeking","bytesWritten","ioctl","readFile","encoding","writeFile","actualNumBytes","chdir","createDefaultDirectories","createDefaultDevices","randomBuffer","randomLeft","randomByte","createDevice","createSpecialDirectories","proc_self","entries","k","createStandardStreams","stdout","stderr","staticInit","quit","_fflush","findObject","dontResolveLastLink","analyzePath","exists","parentExists","parentPath","parentObject","createPath","reverse","part","createFile","properties","forceLoadFile","createLazyFile","LazyUint8Array","lengthKnown","chunks","chunkOffset","chunkSize","chunkNum","setDataGetter","cacheLength","header","datalength","getResponseHeader","hasByteServing","usesGzip","doXHR","setRequestHeader","overrideMimeType","responseText","lazyArray","_length","_chunkSize","defineProperties","writeChunks","absolutePath","createFolder","createLink","joinPath","standardizePath","SYSCALLS","DEFAULT_POLLMASK","calculateAt","dirfd","allowEmpty","dirstream","getStreamFromFD","writeStat","getTime","floor","writeStatFs","stats","doMsync","addr","varargs","getStr","_fd_close","doReadv","iov","iovcnt","curr","_fd_read","pnum","_fd_seek","newOffset","isNaN","doWritev","_fd_write","_random_get","getCFunc","ident","writeArrayToMemory","stringToUTF8OnStack","ccall","toC","convertReturnValue","Boolean","cArgs","converter","onDone","cwrap","incrementExceptionRefcount","decrementExceptionRefcount","___cxa_decrement_exception_refcount","getExceptionMessageCommon","type_addr_addr","message_addr_addr","___get_exception_message","type_addr","message_addr","createPreloadedFile","checkIncomingModuleAPI","missingLibrarySymbols","unexportedSymbols","__assert_fail","__cxa_begin_catch","__cxa_find_matching_catch_2","__cxa_find_matching_catch_3","__cxa_rethrow_primary_exception","__cxa_throw","__pthread_create_js","__resumeException","_abort_js","_embind_finalize_value_object","_embind_register_bigint","_embind_register_bool","_embind_register_class","_embind_register_class_constructor","_embind_register_class_function","_embind_register_class_property","_embind_register_emval","_embind_register_float","_embind_register_function","_embind_register_integer","_embind_register_memory_view","_embind_register_optional","_embind_register_std_string","_embind_register_std_wstring","_embind_register_value_object","_embind_register_value_object_field","_embind_register_void","_emscripten_init_main_thread_js","_emscripten_notify_mailbox_postmessage","_emscripten_receive_on_main_thread_js","_emscripten_thread_cleanup","_emscripten_thread_mailbox_await","_emscripten_thread_set_strongref","_emval_call_method","_emval_decref","_emval_get_global","_emval_get_method_caller","_emval_run_destructors","_emval_take_value","clock_time_get","emscripten_check_blocking_allowed","emscripten_exit_with_live_runtime","emscripten_get_heap_max","emscripten_get_now","emscripten_num_logical_cores","emscripten_resize_heap","emscripten_runtime_keepalive_check","exit","fd_close","fd_read","fd_seek","fd_write","invoke_i","invoke_ii","invoke_iii","invoke_iiii","invoke_v","invoke_vi","invoke_vii","invoke_viii","invoke_viiii","memory","random_get","calledRun","__emscripten_proxy_main","_setThrew","_emscripten_stack_init","a0","a1","index","a2","a3","a4","callMain","entryFunction","argc","stackCheckInit","run","doRun","noInitialRun","oldOut","oldErr","has","x","preInit","isPthread","isNode","workerData"],"sourceRoot":""}